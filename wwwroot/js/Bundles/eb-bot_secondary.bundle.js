/*!
 * Vue.js v2.1.10
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.Vue = factory());
}(this, (function () {
    'use strict';

    /*  */

    /**
     * Convert a value to a string that is actually rendered.
     */
    function _toString(val) {
        return val == null
            ? ''
            : typeof val === 'object'
                ? JSON.stringify(val, null, 2)
                : String(val)
    }

    /**
     * Convert a input value to a number for persistence.
     * If the conversion fails, return original string.
     */
    function toNumber(val) {
        var n = parseFloat(val);
        return isNaN(n) ? val : n
    }

    /**
     * Make a map and return a function for checking if a key
     * is in that map.
     */
    function makeMap(
        str,
        expectsLowerCase
    ) {
        var map = Object.create(null);
        var list = str.split(',');
        for (var i = 0; i < list.length; i++) {
            map[list[i]] = true;
        }
        return expectsLowerCase
            ? function (val) { return map[val.toLowerCase()]; }
            : function (val) { return map[val]; }
    }

    /**
     * Check if a tag is a built-in tag.
     */
    var isBuiltInTag = makeMap('slot,component', true);

    /**
     * Remove an item from an array
     */
    function remove$1(arr, item) {
        if (arr.length) {
            var index = arr.indexOf(item);
            if (index > -1) {
                return arr.splice(index, 1)
            }
        }
    }

    /**
     * Check whether the object has the property.
     */
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwn(obj, key) {
        return hasOwnProperty.call(obj, key)
    }

    /**
     * Check if value is primitive
     */
    function isPrimitive(value) {
        return typeof value === 'string' || typeof value === 'number'
    }

    /**
     * Create a cached version of a pure function.
     */
    function cached(fn) {
        var cache = Object.create(null);
        return (function cachedFn(str) {
            var hit = cache[str];
            return hit || (cache[str] = fn(str))
        })
    }

    /**
     * Camelize a hyphen-delimited string.
     */
    var camelizeRE = /-(\w)/g;
    var camelize = cached(function (str) {
        return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
    });

    /**
     * Capitalize a string.
     */
    var capitalize = cached(function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1)
    });

    /**
     * Hyphenate a camelCase string.
     */
    var hyphenateRE = /([^-])([A-Z])/g;
    var hyphenate = cached(function (str) {
        return str
            .replace(hyphenateRE, '$1-$2')
            .replace(hyphenateRE, '$1-$2')
            .toLowerCase()
    });

    /**
     * Simple bind, faster than native
     */
    function bind$1(fn, ctx) {
        function boundFn(a) {
            var l = arguments.length;
            return l
                ? l > 1
                    ? fn.apply(ctx, arguments)
                    : fn.call(ctx, a)
                : fn.call(ctx)
        }
        // record original fn length
        boundFn._length = fn.length;
        return boundFn
    }

    /**
     * Convert an Array-like object to a real Array.
     */
    function toArray(list, start) {
        start = start || 0;
        var i = list.length - start;
        var ret = new Array(i);
        while (i--) {
            ret[i] = list[i + start];
        }
        return ret
    }

    /**
     * Mix properties into target object.
     */
    function extend(to, _from) {
        for (var key in _from) {
            to[key] = _from[key];
        }
        return to
    }

    /**
     * Quick object check - this is primarily used to tell
     * Objects from primitive values when we know the value
     * is a JSON-compliant type.
     */
    function isObject(obj) {
        return obj !== null && typeof obj === 'object'
    }

    /**
     * Strict object type check. Only returns true
     * for plain JavaScript objects.
     */
    var toString = Object.prototype.toString;
    var OBJECT_STRING = '[object Object]';
    function isPlainObject(obj) {
        return toString.call(obj) === OBJECT_STRING
    }

    /**
     * Merge an Array of Objects into a single Object.
     */
    function toObject(arr) {
        var res = {};
        for (var i = 0; i < arr.length; i++) {
            if (arr[i]) {
                extend(res, arr[i]);
            }
        }
        return res
    }

    /**
     * Perform no operation.
     */
    function noop() { }

    /**
     * Always return false.
     */
    var no = function () { return false; };

    /**
     * Return same value
     */
    var identity = function (_) { return _; };

    /**
     * Generate a static keys string from compiler modules.
     */
    function genStaticKeys(modules) {
        return modules.reduce(function (keys, m) {
            return keys.concat(m.staticKeys || [])
        }, []).join(',')
    }

    /**
     * Check if two values are loosely equal - that is,
     * if they are plain objects, do they have the same shape?
     */
    function looseEqual(a, b) {
        var isObjectA = isObject(a);
        var isObjectB = isObject(b);
        if (isObjectA && isObjectB) {
            return JSON.stringify(a) === JSON.stringify(b)
        } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b)
        } else {
            return false
        }
    }

    function looseIndexOf(arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) { return i }
        }
        return -1
    }

    /*  */

    var config = {
        /**
         * Option merge strategies (used in core/util/options)
         */
        optionMergeStrategies: Object.create(null),

        /**
         * Whether to suppress warnings.
         */
        silent: false,

        /**
         * Whether to enable devtools
         */
        devtools: "development" !== 'production',

        /**
         * Error handler for watcher errors
         */
        errorHandler: null,

        /**
         * Ignore certain custom elements
         */
        ignoredElements: [],

        /**
         * Custom user key aliases for v-on
         */
        keyCodes: Object.create(null),

        /**
         * Check if a tag is reserved so that it cannot be registered as a
         * component. This is platform-dependent and may be overwritten.
         */
        isReservedTag: no,

        /**
         * Check if a tag is an unknown element.
         * Platform-dependent.
         */
        isUnknownElement: no,

        /**
         * Get the namespace of an element
         */
        getTagNamespace: noop,

        /**
         * Parse the real tag name for the specific platform.
         */
        parsePlatformTagName: identity,

        /**
         * Check if an attribute must be bound using property, e.g. value
         * Platform-dependent.
         */
        mustUseProp: no,

        /**
         * List of asset types that a component can own.
         */
        _assetTypes: [
            'component',
            'directive',
            'filter'
        ],

        /**
         * List of lifecycle hooks.
         */
        _lifecycleHooks: [
            'beforeCreate',
            'created',
            'beforeMount',
            'mounted',
            'beforeUpdate',
            'updated',
            'beforeDestroy',
            'destroyed',
            'activated',
            'deactivated'
        ],

        /**
         * Max circular updates allowed in a scheduler flush cycle.
         */
        _maxUpdateCount: 100
    };

    /*  */

    /**
     * Check if a string starts with $ or _
     */
    function isReserved(str) {
        var c = (str + '').charCodeAt(0);
        return c === 0x24 || c === 0x5F
    }

    /**
     * Define a property.
     */
    function def(obj, key, val, enumerable) {
        Object.defineProperty(obj, key, {
            value: val,
            enumerable: !!enumerable,
            writable: true,
            configurable: true
        });
    }

    /**
     * Parse simple path.
     */
    var bailRE = /[^\w.$]/;
    function parsePath(path) {
        if (bailRE.test(path)) {
            return
        } else {
            var segments = path.split('.');
            return function (obj) {
                for (var i = 0; i < segments.length; i++) {
                    if (!obj) { return }
                    obj = obj[segments[i]];
                }
                return obj
            }
        }
    }

    /*  */
    /* globals MutationObserver */

    // can we use __proto__?
    var hasProto = '__proto__' in {};

    // Browser environment sniffing
    var inBrowser = typeof window !== 'undefined';
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();
    var isIE = UA && /msie|trident/.test(UA);
    var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
    var isEdge = UA && UA.indexOf('edge/') > 0;
    var isAndroid = UA && UA.indexOf('android') > 0;
    var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

    // this needs to be lazy-evaled because vue may be required before
    // vue-server-renderer can set VUE_ENV
    var _isServer;
    var isServerRendering = function () {
        if (_isServer === undefined) {
            /* istanbul ignore if */
            if (!inBrowser && typeof global !== 'undefined') {
                // detect presence of vue-server-renderer and avoid
                // Webpack shimming the process
                _isServer = global['process'].env.VUE_ENV === 'server';
            } else {
                _isServer = false;
            }
        }
        return _isServer
    };

    // detect devtools
    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

    /* istanbul ignore next */
    function isNative(Ctor) {
        return /native code/.test(Ctor.toString())
    }

    /**
     * Defer a task to execute it asynchronously.
     */
    var nextTick = (function () {
        var callbacks = [];
        var pending = false;
        var timerFunc;

        function nextTickHandler() {
            pending = false;
            var copies = callbacks.slice(0);
            callbacks.length = 0;
            for (var i = 0; i < copies.length; i++) {
                copies[i]();
            }
        }

        // the nextTick behavior leverages the microtask queue, which can be accessed
        // via either native Promise.then or MutationObserver.
        // MutationObserver has wider support, however it is seriously bugged in
        // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
        // completely stops working after triggering a few times... so, if native
        // Promise is available, we will use it:
        /* istanbul ignore if */
        if (typeof Promise !== 'undefined' && isNative(Promise)) {
            var p = Promise.resolve();
            var logError = function (err) { console.error(err); };
            timerFunc = function () {
                p.then(nextTickHandler).catch(logError);
                // in problematic UIWebViews, Promise.then doesn't completely break, but
                // it can get stuck in a weird state where callbacks are pushed into the
                // microtask queue but the queue isn't being flushed, until the browser
                // needs to do some other work, e.g. handle a timer. Therefore we can
                // "force" the microtask queue to be flushed by adding an empty timer.
                if (isIOS) { setTimeout(noop); }
            };
        } else if (typeof MutationObserver !== 'undefined' && (
            isNative(MutationObserver) ||
            // PhantomJS and iOS 7.x
            MutationObserver.toString() === '[object MutationObserverConstructor]'
        )) {
            // use MutationObserver where native Promise is not available,
            // e.g. PhantomJS IE11, iOS7, Android 4.4
            var counter = 1;
            var observer = new MutationObserver(nextTickHandler);
            var textNode = document.createTextNode(String(counter));
            observer.observe(textNode, {
                characterData: true
            });
            timerFunc = function () {
                counter = (counter + 1) % 2;
                textNode.data = String(counter);
            };
        } else {
            // fallback to setTimeout
            /* istanbul ignore next */
            timerFunc = function () {
                setTimeout(nextTickHandler, 0);
            };
        }

        return function queueNextTick(cb, ctx) {
            var _resolve;
            callbacks.push(function () {
                if (cb) { cb.call(ctx); }
                if (_resolve) { _resolve(ctx); }
            });
            if (!pending) {
                pending = true;
                timerFunc();
            }
            if (!cb && typeof Promise !== 'undefined') {
                return new Promise(function (resolve) {
                    _resolve = resolve;
                })
            }
        }
    })();

    var _Set;
    /* istanbul ignore if */
    if (typeof Set !== 'undefined' && isNative(Set)) {
        // use native Set when available.
        _Set = Set;
    } else {
        // a non-standard Set polyfill that only works with primitive keys.
        _Set = (function () {
            function Set() {
                this.set = Object.create(null);
            }
            Set.prototype.has = function has(key) {
                return this.set[key] === true
            };
            Set.prototype.add = function add(key) {
                this.set[key] = true;
            };
            Set.prototype.clear = function clear() {
                this.set = Object.create(null);
            };

            return Set;
        }());
    }

    var warn = noop;
    var formatComponentName;

    {
        var hasConsole = typeof console !== 'undefined';

        warn = function (msg, vm) {
            if (hasConsole && (!config.silent)) {
                console.error("[Vue warn]: " + msg + " " + (
                    vm ? formatLocation(formatComponentName(vm)) : ''
                ));
            }
        };

        formatComponentName = function (vm) {
            if (vm.$root === vm) {
                return 'root instance'
            }
            var name = vm._isVue
                ? vm.$options.name || vm.$options._componentTag
                : vm.name;
            return (
                (name ? ("component <" + name + ">") : "anonymous component") +
                (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
            )
        };

        var formatLocation = function (str) {
            if (str === 'anonymous component') {
                str += " - use the \"name\" option for better debugging messages.";
            }
            return ("\n(found in " + str + ")")
        };
    }

    /*  */


    var uid$1 = 0;

    /**
     * A dep is an observable that can have multiple
     * directives subscribing to it.
     */
    var Dep = function Dep() {
        this.id = uid$1++;
        this.subs = [];
    };

    Dep.prototype.addSub = function addSub(sub) {
        this.subs.push(sub);
    };

    Dep.prototype.removeSub = function removeSub(sub) {
        remove$1(this.subs, sub);
    };

    Dep.prototype.depend = function depend() {
        if (Dep.target) {
            Dep.target.addDep(this);
        }
    };

    Dep.prototype.notify = function notify() {
        // stablize the subscriber list first
        var subs = this.subs.slice();
        for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
        }
    };

    // the current target watcher being evaluated.
    // this is globally unique because there could be only one
    // watcher being evaluated at any time.
    Dep.target = null;
    var targetStack = [];

    function pushTarget(_target) {
        if (Dep.target) { targetStack.push(Dep.target); }
        Dep.target = _target;
    }

    function popTarget() {
        Dep.target = targetStack.pop();
    }

    /*
     * not type checking this file because flow doesn't play well with
     * dynamically accessing methods on Array prototype
     */

    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);[
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'sort',
        'reverse'
    ]
        .forEach(function (method) {
            // cache original method
            var original = arrayProto[method];
            def(arrayMethods, method, function mutator() {
                var arguments$1 = arguments;

                // avoid leaking arguments:
                // http://jsperf.com/closure-with-arguments
                var i = arguments.length;
                var args = new Array(i);
                while (i--) {
                    args[i] = arguments$1[i];
                }
                var result = original.apply(this, args);
                var ob = this.__ob__;
                var inserted;
                switch (method) {
                    case 'push':
                        inserted = args;
                        break
                    case 'unshift':
                        inserted = args;
                        break
                    case 'splice':
                        inserted = args.slice(2);
                        break
                }
                if (inserted) { ob.observeArray(inserted); }
                // notify change
                ob.dep.notify();
                return result
            });
        });

    /*  */

    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

    /**
     * By default, when a reactive property is set, the new value is
     * also converted to become reactive. However when passing down props,
     * we don't want to force conversion because the value may be a nested value
     * under a frozen data structure. Converting it would defeat the optimization.
     */
    var observerState = {
        shouldConvert: true,
        isSettingProps: false
    };

    /**
     * Observer class that are attached to each observed
     * object. Once attached, the observer converts target
     * object's property keys into getter/setters that
     * collect dependencies and dispatches updates.
     */
    var Observer = function Observer(value) {
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (Array.isArray(value)) {
            var augment = hasProto
                ? protoAugment
                : copyAugment;
            augment(value, arrayMethods, arrayKeys);
            this.observeArray(value);
        } else {
            this.walk(value);
        }
    };

    /**
     * Walk through each property and convert them into
     * getter/setters. This method should only be called when
     * value type is Object.
     */
    Observer.prototype.walk = function walk(obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
            defineReactive$$1(obj, keys[i], obj[keys[i]]);
        }
    };

    /**
     * Observe a list of Array items.
     */
    Observer.prototype.observeArray = function observeArray(items) {
        for (var i = 0, l = items.length; i < l; i++) {
            observe(items[i]);
        }
    };

    // helpers

    /**
     * Augment an target Object or Array by intercepting
     * the prototype chain using __proto__
     */
    function protoAugment(target, src) {
        /* eslint-disable no-proto */
        target.__proto__ = src;
        /* eslint-enable no-proto */
    }

    /**
     * Augment an target Object or Array by defining
     * hidden properties.
     */
    /* istanbul ignore next */
    function copyAugment(target, src, keys) {
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            def(target, key, src[key]);
        }
    }

    /**
     * Attempt to create an observer instance for a value,
     * returns the new observer if successfully observed,
     * or the existing observer if the value already has one.
     */
    function observe(value, asRootData) {
        if (!isObject(value)) {
            return
        }
        var ob;
        if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
            ob = value.__ob__;
        } else if (
            observerState.shouldConvert &&
            !isServerRendering() &&
            (Array.isArray(value) || isPlainObject(value)) &&
            Object.isExtensible(value) &&
            !value._isVue
        ) {
            ob = new Observer(value);
        }
        if (asRootData && ob) {
            ob.vmCount++;
        }
        return ob
    }

    /**
     * Define a reactive property on an Object.
     */
    function defineReactive$$1(
        obj,
        key,
        val,
        customSetter
    ) {
        var dep = new Dep();

        var property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
            return
        }

        // cater for pre-defined getter/setters
        var getter = property && property.get;
        var setter = property && property.set;

        var childOb = observe(val);
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter() {
                var value = getter ? getter.call(obj) : val;
                if (Dep.target) {
                    dep.depend();
                    if (childOb) {
                        childOb.dep.depend();
                    }
                    if (Array.isArray(value)) {
                        dependArray(value);
                    }
                }
                return value
            },
            set: function reactiveSetter(newVal) {
                var value = getter ? getter.call(obj) : val;
                /* eslint-disable no-self-compare */
                if (newVal === value || (newVal !== newVal && value !== value)) {
                    return
                }
                /* eslint-enable no-self-compare */
                if ("development" !== 'production' && customSetter) {
                    customSetter();
                }
                if (setter) {
                    setter.call(obj, newVal);
                } else {
                    val = newVal;
                }
                childOb = observe(newVal);
                dep.notify();
            }
        });
    }

    /**
     * Set a property on an object. Adds the new property and
     * triggers change notification if the property doesn't
     * already exist.
     */
    function set$1(obj, key, val) {
        if (Array.isArray(obj)) {
            obj.length = Math.max(obj.length, key);
            obj.splice(key, 1, val);
            return val
        }
        if (hasOwn(obj, key)) {
            obj[key] = val;
            return
        }
        var ob = obj.__ob__;
        if (obj._isVue || (ob && ob.vmCount)) {
            "development" !== 'production' && warn(
                'Avoid adding reactive properties to a Vue instance or its root $data ' +
                'at runtime - declare it upfront in the data option.'
            );
            return
        }
        if (!ob) {
            obj[key] = val;
            return
        }
        defineReactive$$1(ob.value, key, val);
        ob.dep.notify();
        return val
    }

    /**
     * Delete a property and trigger change if necessary.
     */
    function del(obj, key) {
        var ob = obj.__ob__;
        if (obj._isVue || (ob && ob.vmCount)) {
            "development" !== 'production' && warn(
                'Avoid deleting properties on a Vue instance or its root $data ' +
                '- just set it to null.'
            );
            return
        }
        if (!hasOwn(obj, key)) {
            return
        }
        delete obj[key];
        if (!ob) {
            return
        }
        ob.dep.notify();
    }

    /**
     * Collect dependencies on array elements when the array is touched, since
     * we cannot intercept array element access like property getters.
     */
    function dependArray(value) {
        for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
            e = value[i];
            e && e.__ob__ && e.__ob__.dep.depend();
            if (Array.isArray(e)) {
                dependArray(e);
            }
        }
    }

    /*  */

    /**
     * Option overwriting strategies are functions that handle
     * how to merge a parent option value and a child option
     * value into the final value.
     */
    var strats = config.optionMergeStrategies;

    /**
     * Options with restrictions
     */
    {
        strats.el = strats.propsData = function (parent, child, vm, key) {
            if (!vm) {
                warn(
                    "option \"" + key + "\" can only be used during instance " +
                    'creation with the `new` keyword.'
                );
            }
            return defaultStrat(parent, child)
        };
    }

    /**
     * Helper that recursively merges two data objects together.
     */
    function mergeData(to, from) {
        if (!from) { return to }
        var key, toVal, fromVal;
        var keys = Object.keys(from);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            toVal = to[key];
            fromVal = from[key];
            if (!hasOwn(to, key)) {
                set$1(to, key, fromVal);
            } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
                mergeData(toVal, fromVal);
            }
        }
        return to
    }

    /**
     * Data
     */
    strats.data = function (
        parentVal,
        childVal,
        vm
    ) {
        if (!vm) {
            // in a Vue.extend merge, both should be functions
            if (!childVal) {
                return parentVal
            }
            if (typeof childVal !== 'function') {
                "development" !== 'production' && warn(
                    'The "data" option should be a function ' +
                    'that returns a per-instance value in component ' +
                    'definitions.',
                    vm
                );
                return parentVal
            }
            if (!parentVal) {
                return childVal
            }
            // when parentVal & childVal are both present,
            // we need to return a function that returns the
            // merged result of both functions... no need to
            // check if parentVal is a function here because
            // it has to be a function to pass previous merges.
            return function mergedDataFn() {
                return mergeData(
                    childVal.call(this),
                    parentVal.call(this)
                )
            }
        } else if (parentVal || childVal) {
            return function mergedInstanceDataFn() {
                // instance merge
                var instanceData = typeof childVal === 'function'
                    ? childVal.call(vm)
                    : childVal;
                var defaultData = typeof parentVal === 'function'
                    ? parentVal.call(vm)
                    : undefined;
                if (instanceData) {
                    return mergeData(instanceData, defaultData)
                } else {
                    return defaultData
                }
            }
        }
    };

    /**
     * Hooks and param attributes are merged as arrays.
     */
    function mergeHook(
        parentVal,
        childVal
    ) {
        return childVal
            ? parentVal
                ? parentVal.concat(childVal)
                : Array.isArray(childVal)
                    ? childVal
                    : [childVal]
            : parentVal
    }

    config._lifecycleHooks.forEach(function (hook) {
        strats[hook] = mergeHook;
    });

    /**
     * Assets
     *
     * When a vm is present (instance creation), we need to do
     * a three-way merge between constructor options, instance
     * options and parent options.
     */
    function mergeAssets(parentVal, childVal) {
        var res = Object.create(parentVal || null);
        return childVal
            ? extend(res, childVal)
            : res
    }

    config._assetTypes.forEach(function (type) {
        strats[type + 's'] = mergeAssets;
    });

    /**
     * Watchers.
     *
     * Watchers hashes should not overwrite one
     * another, so we merge them as arrays.
     */
    strats.watch = function (parentVal, childVal) {
        /* istanbul ignore if */
        if (!childVal) { return parentVal }
        if (!parentVal) { return childVal }
        var ret = {};
        extend(ret, parentVal);
        for (var key in childVal) {
            var parent = ret[key];
            var child = childVal[key];
            if (parent && !Array.isArray(parent)) {
                parent = [parent];
            }
            ret[key] = parent
                ? parent.concat(child)
                : [child];
        }
        return ret
    };

    /**
     * Other object hashes.
     */
    strats.props =
        strats.methods =
        strats.computed = function (parentVal, childVal) {
            if (!childVal) { return parentVal }
            if (!parentVal) { return childVal }
            var ret = Object.create(null);
            extend(ret, parentVal);
            extend(ret, childVal);
            return ret
        };

    /**
     * Default strategy.
     */
    var defaultStrat = function (parentVal, childVal) {
        return childVal === undefined
            ? parentVal
            : childVal
    };

    /**
     * Validate component names
     */
    function checkComponents(options) {
        for (var key in options.components) {
            var lower = key.toLowerCase();
            if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
                warn(
                    'Do not use built-in or reserved HTML elements as component ' +
                    'id: ' + key
                );
            }
        }
    }

    /**
     * Ensure all props option syntax are normalized into the
     * Object-based format.
     */
    function normalizeProps(options) {
        var props = options.props;
        if (!props) { return }
        var res = {};
        var i, val, name;
        if (Array.isArray(props)) {
            i = props.length;
            while (i--) {
                val = props[i];
                if (typeof val === 'string') {
                    name = camelize(val);
                    res[name] = { type: null };
                } else {
                    warn('props must be strings when using array syntax.');
                }
            }
        } else if (isPlainObject(props)) {
            for (var key in props) {
                val = props[key];
                name = camelize(key);
                res[name] = isPlainObject(val)
                    ? val
                    : { type: val };
            }
        }
        options.props = res;
    }

    /**
     * Normalize raw function directives into object format.
     */
    function normalizeDirectives(options) {
        var dirs = options.directives;
        if (dirs) {
            for (var key in dirs) {
                var def = dirs[key];
                if (typeof def === 'function') {
                    dirs[key] = { bind: def, update: def };
                }
            }
        }
    }

    /**
     * Merge two option objects into a new one.
     * Core utility used in both instantiation and inheritance.
     */
    function mergeOptions(
        parent,
        child,
        vm
    ) {
        {
            checkComponents(child);
        }
        normalizeProps(child);
        normalizeDirectives(child);
        var extendsFrom = child.extends;
        if (extendsFrom) {
            parent = typeof extendsFrom === 'function'
                ? mergeOptions(parent, extendsFrom.options, vm)
                : mergeOptions(parent, extendsFrom, vm);
        }
        if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                var mixin = child.mixins[i];
                if (mixin.prototype instanceof Vue$3) {
                    mixin = mixin.options;
                }
                parent = mergeOptions(parent, mixin, vm);
            }
        }
        var options = {};
        var key;
        for (key in parent) {
            mergeField(key);
        }
        for (key in child) {
            if (!hasOwn(parent, key)) {
                mergeField(key);
            }
        }
        function mergeField(key) {
            var strat = strats[key] || defaultStrat;
            options[key] = strat(parent[key], child[key], vm, key);
        }
        return options
    }

    /**
     * Resolve an asset.
     * This function is used because child instances need access
     * to assets defined in its ancestor chain.
     */
    function resolveAsset(
        options,
        type,
        id,
        warnMissing
    ) {
        /* istanbul ignore if */
        if (typeof id !== 'string') {
            return
        }
        var assets = options[type];
        // check local registration variations first
        if (hasOwn(assets, id)) { return assets[id] }
        var camelizedId = camelize(id);
        if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
        var PascalCaseId = capitalize(camelizedId);
        if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
        // fallback to prototype chain
        var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
        if ("development" !== 'production' && warnMissing && !res) {
            warn(
                'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
                options
            );
        }
        return res
    }

    /*  */

    function validateProp(
        key,
        propOptions,
        propsData,
        vm
    ) {
        var prop = propOptions[key];
        var absent = !hasOwn(propsData, key);
        var value = propsData[key];
        // handle boolean props
        if (isType(Boolean, prop.type)) {
            if (absent && !hasOwn(prop, 'default')) {
                value = false;
            } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
                value = true;
            }
        }
        // check default value
        if (value === undefined) {
            value = getPropDefaultValue(vm, prop, key);
            // since the default value is a fresh copy,
            // make sure to observe it.
            var prevShouldConvert = observerState.shouldConvert;
            observerState.shouldConvert = true;
            observe(value);
            observerState.shouldConvert = prevShouldConvert;
        }
        {
            assertProp(prop, key, value, vm, absent);
        }
        return value
    }

    /**
     * Get the default value of a prop.
     */
    function getPropDefaultValue(vm, prop, key) {
        // no default, return undefined
        if (!hasOwn(prop, 'default')) {
            return undefined
        }
        var def = prop.default;
        // warn against non-factory defaults for Object & Array
        if (isObject(def)) {
            "development" !== 'production' && warn(
                'Invalid default value for prop "' + key + '": ' +
                'Props with type Object/Array must use a factory function ' +
                'to return the default value.',
                vm
            );
        }
        // the raw prop value was also undefined from previous render,
        // return previous default value to avoid unnecessary watcher trigger
        if (vm && vm.$options.propsData &&
            vm.$options.propsData[key] === undefined &&
            vm[key] !== undefined) {
            return vm[key]
        }
        // call factory function for non-Function types
        return typeof def === 'function' && prop.type !== Function
            ? def.call(vm)
            : def
    }

    /**
     * Assert whether a prop is valid.
     */
    function assertProp(
        prop,
        name,
        value,
        vm,
        absent
    ) {
        if (prop.required && absent) {
            warn(
                'Missing required prop: "' + name + '"',
                vm
            );
            return
        }
        if (value == null && !prop.required) {
            return
        }
        var type = prop.type;
        var valid = !type || type === true;
        var expectedTypes = [];
        if (type) {
            if (!Array.isArray(type)) {
                type = [type];
            }
            for (var i = 0; i < type.length && !valid; i++) {
                var assertedType = assertType(value, type[i]);
                expectedTypes.push(assertedType.expectedType || '');
                valid = assertedType.valid;
            }
        }
        if (!valid) {
            warn(
                'Invalid prop: type check failed for prop "' + name + '".' +
                ' Expected ' + expectedTypes.map(capitalize).join(', ') +
                ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
                vm
            );
            return
        }
        var validator = prop.validator;
        if (validator) {
            if (!validator(value)) {
                warn(
                    'Invalid prop: custom validator check failed for prop "' + name + '".',
                    vm
                );
            }
        }
    }

    /**
     * Assert the type of a value
     */
    function assertType(value, type) {
        var valid;
        var expectedType = getType(type);
        if (expectedType === 'String') {
            valid = typeof value === (expectedType = 'string');
        } else if (expectedType === 'Number') {
            valid = typeof value === (expectedType = 'number');
        } else if (expectedType === 'Boolean') {
            valid = typeof value === (expectedType = 'boolean');
        } else if (expectedType === 'Function') {
            valid = typeof value === (expectedType = 'function');
        } else if (expectedType === 'Object') {
            valid = isPlainObject(value);
        } else if (expectedType === 'Array') {
            valid = Array.isArray(value);
        } else {
            valid = value instanceof type;
        }
        return {
            valid: valid,
            expectedType: expectedType
        }
    }

    /**
     * Use function string name to check built-in types,
     * because a simple equality check will fail when running
     * across different vms / iframes.
     */
    function getType(fn) {
        var match = fn && fn.toString().match(/^\s*function (\w+)/);
        return match && match[1]
    }

    function isType(type, fn) {
        if (!Array.isArray(fn)) {
            return getType(fn) === getType(type)
        }
        for (var i = 0, len = fn.length; i < len; i++) {
            if (getType(fn[i]) === getType(type)) {
                return true
            }
        }
        /* istanbul ignore next */
        return false
    }



    var util = Object.freeze({
        defineReactive: defineReactive$$1,
        _toString: _toString,
        toNumber: toNumber,
        makeMap: makeMap,
        isBuiltInTag: isBuiltInTag,
        remove: remove$1,
        hasOwn: hasOwn,
        isPrimitive: isPrimitive,
        cached: cached,
        camelize: camelize,
        capitalize: capitalize,
        hyphenate: hyphenate,
        bind: bind$1,
        toArray: toArray,
        extend: extend,
        isObject: isObject,
        isPlainObject: isPlainObject,
        toObject: toObject,
        noop: noop,
        no: no,
        identity: identity,
        genStaticKeys: genStaticKeys,
        looseEqual: looseEqual,
        looseIndexOf: looseIndexOf,
        isReserved: isReserved,
        def: def,
        parsePath: parsePath,
        hasProto: hasProto,
        inBrowser: inBrowser,
        UA: UA,
        isIE: isIE,
        isIE9: isIE9,
        isEdge: isEdge,
        isAndroid: isAndroid,
        isIOS: isIOS,
        isServerRendering: isServerRendering,
        devtools: devtools,
        nextTick: nextTick,
        get _Set() { return _Set; },
        mergeOptions: mergeOptions,
        resolveAsset: resolveAsset,
        get warn() { return warn; },
        get formatComponentName() { return formatComponentName; },
        validateProp: validateProp
    });

    /* not type checking this file because flow doesn't play well with Proxy */

    var initProxy;

    {
        var allowedGlobals = makeMap(
            'Infinity,undefined,NaN,isFinite,isNaN,' +
            'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
            'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
            'require' // for Webpack/Browserify
        );

        var warnNonPresent = function (target, key) {
            warn(
                "Property or method \"" + key + "\" is not defined on the instance but " +
                "referenced during render. Make sure to declare reactive data " +
                "properties in the data option.",
                target
            );
        };

        var hasProxy =
            typeof Proxy !== 'undefined' &&
            Proxy.toString().match(/native code/);

        if (hasProxy) {
            var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
            config.keyCodes = new Proxy(config.keyCodes, {
                set: function set(target, key, value) {
                    if (isBuiltInModifier(key)) {
                        warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
                        return false
                    } else {
                        target[key] = value;
                        return true
                    }
                }
            });
        }

        var hasHandler = {
            has: function has(target, key) {
                var has = key in target;
                var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
                if (!has && !isAllowed) {
                    warnNonPresent(target, key);
                }
                return has || !isAllowed
            }
        };

        var getHandler = {
            get: function get(target, key) {
                if (typeof key === 'string' && !(key in target)) {
                    warnNonPresent(target, key);
                }
                return target[key]
            }
        };

        initProxy = function initProxy(vm) {
            if (hasProxy) {
                // determine which proxy handler to use
                var options = vm.$options;
                var handlers = options.render && options.render._withStripped
                    ? getHandler
                    : hasHandler;
                vm._renderProxy = new Proxy(vm, handlers);
            } else {
                vm._renderProxy = vm;
            }
        };
    }

    /*  */

    var VNode = function VNode(
        tag,
        data,
        children,
        text,
        elm,
        context,
        componentOptions
    ) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.functionalContext = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
    };

    var prototypeAccessors = { child: {} };

    // DEPRECATED: alias for componentInstance for backwards compat.
    /* istanbul ignore next */
    prototypeAccessors.child.get = function () {
        return this.componentInstance
    };

    Object.defineProperties(VNode.prototype, prototypeAccessors);

    var createEmptyVNode = function () {
        var node = new VNode();
        node.text = '';
        node.isComment = true;
        return node
    };

    function createTextVNode(val) {
        return new VNode(undefined, undefined, undefined, String(val))
    }

    // optimized shallow clone
    // used for static nodes and slot nodes because they may be reused across
    // multiple renders, cloning them avoids errors when DOM manipulations rely
    // on their elm reference.
    function cloneVNode(vnode) {
        var cloned = new VNode(
            vnode.tag,
            vnode.data,
            vnode.children,
            vnode.text,
            vnode.elm,
            vnode.context,
            vnode.componentOptions
        );
        cloned.ns = vnode.ns;
        cloned.isStatic = vnode.isStatic;
        cloned.key = vnode.key;
        cloned.isCloned = true;
        return cloned
    }

    function cloneVNodes(vnodes) {
        var res = new Array(vnodes.length);
        for (var i = 0; i < vnodes.length; i++) {
            res[i] = cloneVNode(vnodes[i]);
        }
        return res
    }

    /*  */

    var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
    var hooksToMerge = Object.keys(hooks);

    function createComponent(
        Ctor,
        data,
        context,
        children,
        tag
    ) {
        if (!Ctor) {
            return
        }

        var baseCtor = context.$options._base;
        if (isObject(Ctor)) {
            Ctor = baseCtor.extend(Ctor);
        }

        if (typeof Ctor !== 'function') {
            {
                warn(("Invalid Component definition: " + (String(Ctor))), context);
            }
            return
        }

        // async component
        if (!Ctor.cid) {
            if (Ctor.resolved) {
                Ctor = Ctor.resolved;
            } else {
                Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
                    // it's ok to queue this on every render because
                    // $forceUpdate is buffered by the scheduler.
                    context.$forceUpdate();
                });
                if (!Ctor) {
                    // return nothing if this is indeed an async component
                    // wait for the callback to trigger parent update.
                    return
                }
            }
        }

        // resolve constructor options in case global mixins are applied after
        // component constructor creation
        resolveConstructorOptions(Ctor);

        data = data || {};

        // extract props
        var propsData = extractProps(data, Ctor);

        // functional component
        if (Ctor.options.functional) {
            return createFunctionalComponent(Ctor, propsData, data, context, children)
        }

        // extract listeners, since these needs to be treated as
        // child component listeners instead of DOM listeners
        var listeners = data.on;
        // replace with listeners with .native modifier
        data.on = data.nativeOn;

        if (Ctor.options.abstract) {
            // abstract components do not keep anything
            // other than props & listeners
            data = {};
        }

        // merge component management hooks onto the placeholder node
        mergeHooks(data);

        // return a placeholder vnode
        var name = Ctor.options.name || tag;
        var vnode = new VNode(
            ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
            data, undefined, undefined, undefined, context,
            { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
        );
        return vnode
    }

    function createFunctionalComponent(
        Ctor,
        propsData,
        data,
        context,
        children
    ) {
        var props = {};
        var propOptions = Ctor.options.props;
        if (propOptions) {
            for (var key in propOptions) {
                props[key] = validateProp(key, propOptions, propsData);
            }
        }
        // ensure the createElement function in functional components
        // gets a unique context - this is necessary for correct named slot check
        var _context = Object.create(context);
        var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
        var vnode = Ctor.options.render.call(null, h, {
            props: props,
            data: data,
            parent: context,
            children: children,
            slots: function () { return resolveSlots(children, context); }
        });
        if (vnode instanceof VNode) {
            vnode.functionalContext = context;
            if (data.slot) {
                (vnode.data || (vnode.data = {})).slot = data.slot;
            }
        }
        return vnode
    }

    function createComponentInstanceForVnode(
        vnode, // we know it's MountedComponentVNode but flow doesn't
        parent, // activeInstance in lifecycle state
        parentElm,
        refElm
    ) {
        var vnodeComponentOptions = vnode.componentOptions;
        var options = {
            _isComponent: true,
            parent: parent,
            propsData: vnodeComponentOptions.propsData,
            _componentTag: vnodeComponentOptions.tag,
            _parentVnode: vnode,
            _parentListeners: vnodeComponentOptions.listeners,
            _renderChildren: vnodeComponentOptions.children,
            _parentElm: parentElm || null,
            _refElm: refElm || null
        };
        // check inline-template render functions
        var inlineTemplate = vnode.data.inlineTemplate;
        if (inlineTemplate) {
            options.render = inlineTemplate.render;
            options.staticRenderFns = inlineTemplate.staticRenderFns;
        }
        return new vnodeComponentOptions.Ctor(options)
    }

    function init(
        vnode,
        hydrating,
        parentElm,
        refElm
    ) {
        if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
            var child = vnode.componentInstance = createComponentInstanceForVnode(
                vnode,
                activeInstance,
                parentElm,
                refElm
            );
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        } else if (vnode.data.keepAlive) {
            // kept-alive components, treat as a patch
            var mountedNode = vnode; // work around flow
            prepatch(mountedNode, mountedNode);
        }
    }

    function prepatch(
        oldVnode,
        vnode
    ) {
        var options = vnode.componentOptions;
        var child = vnode.componentInstance = oldVnode.componentInstance;
        child._updateFromParent(
            options.propsData, // updated props
            options.listeners, // updated listeners
            vnode, // new parent vnode
            options.children // new children
        );
    }

    function insert(vnode) {
        if (!vnode.componentInstance._isMounted) {
            vnode.componentInstance._isMounted = true;
            callHook(vnode.componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            vnode.componentInstance._inactive = false;
            callHook(vnode.componentInstance, 'activated');
        }
    }

    function destroy$1(vnode) {
        if (!vnode.componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                vnode.componentInstance.$destroy();
            } else {
                vnode.componentInstance._inactive = true;
                callHook(vnode.componentInstance, 'deactivated');
            }
        }
    }

    function resolveAsyncComponent(
        factory,
        baseCtor,
        cb
    ) {
        if (factory.requested) {
            // pool callbacks
            factory.pendingCallbacks.push(cb);
        } else {
            factory.requested = true;
            var cbs = factory.pendingCallbacks = [cb];
            var sync = true;

            var resolve = function (res) {
                if (isObject(res)) {
                    res = baseCtor.extend(res);
                }
                // cache resolved
                factory.resolved = res;
                // invoke callbacks only if this is not a synchronous resolve
                // (async resolves are shimmed as synchronous during SSR)
                if (!sync) {
                    for (var i = 0, l = cbs.length; i < l; i++) {
                        cbs[i](res);
                    }
                }
            };

            var reject = function (reason) {
                "development" !== 'production' && warn(
                    "Failed to resolve async component: " + (String(factory)) +
                    (reason ? ("\nReason: " + reason) : '')
                );
            };

            var res = factory(resolve, reject);

            // handle promise
            if (res && typeof res.then === 'function' && !factory.resolved) {
                res.then(resolve, reject);
            }

            sync = false;
            // return in case resolved synchronously
            return factory.resolved
        }
    }

    function extractProps(data, Ctor) {
        // we are only extracting raw values here.
        // validation and default values are handled in the child
        // component itself.
        var propOptions = Ctor.options.props;
        if (!propOptions) {
            return
        }
        var res = {};
        var attrs = data.attrs;
        var props = data.props;
        var domProps = data.domProps;
        if (attrs || props || domProps) {
            for (var key in propOptions) {
                var altKey = hyphenate(key);
                checkProp(res, props, key, altKey, true) ||
                    checkProp(res, attrs, key, altKey) ||
                    checkProp(res, domProps, key, altKey);
            }
        }
        return res
    }

    function checkProp(
        res,
        hash,
        key,
        altKey,
        preserve
    ) {
        if (hash) {
            if (hasOwn(hash, key)) {
                res[key] = hash[key];
                if (!preserve) {
                    delete hash[key];
                }
                return true
            } else if (hasOwn(hash, altKey)) {
                res[key] = hash[altKey];
                if (!preserve) {
                    delete hash[altKey];
                }
                return true
            }
        }
        return false
    }

    function mergeHooks(data) {
        if (!data.hook) {
            data.hook = {};
        }
        for (var i = 0; i < hooksToMerge.length; i++) {
            var key = hooksToMerge[i];
            var fromParent = data.hook[key];
            var ours = hooks[key];
            data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
        }
    }

    function mergeHook$1(one, two) {
        return function (a, b, c, d) {
            one(a, b, c, d);
            two(a, b, c, d);
        }
    }

    /*  */

    function mergeVNodeHook(def, hookKey, hook, key) {
        key = key + hookKey;
        var injectedHash = def.__injected || (def.__injected = {});
        if (!injectedHash[key]) {
            injectedHash[key] = true;
            var oldHook = def[hookKey];
            if (oldHook) {
                def[hookKey] = function () {
                    oldHook.apply(this, arguments);
                    hook.apply(this, arguments);
                };
            } else {
                def[hookKey] = hook;
            }
        }
    }

    /*  */

    var normalizeEvent = cached(function (name) {
        var once = name.charAt(0) === '~'; // Prefixed last, checked first
        name = once ? name.slice(1) : name;
        var capture = name.charAt(0) === '!';
        name = capture ? name.slice(1) : name;
        return {
            name: name,
            once: once,
            capture: capture
        }
    });

    function createEventHandle(fn) {
        var handle = {
            fn: fn,
            invoker: function () {
                var arguments$1 = arguments;

                var fn = handle.fn;
                if (Array.isArray(fn)) {
                    for (var i = 0; i < fn.length; i++) {
                        fn[i].apply(null, arguments$1);
                    }
                } else {
                    fn.apply(null, arguments);
                }
            }
        };
        return handle
    }

    function updateListeners(
        on,
        oldOn,
        add,
        remove$$1,
        vm
    ) {
        var name, cur, old, event;
        for (name in on) {
            cur = on[name];
            old = oldOn[name];
            event = normalizeEvent(name);
            if (!cur) {
                "development" !== 'production' && warn(
                    "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
                    vm
                );
            } else if (!old) {
                if (!cur.invoker) {
                    cur = on[name] = createEventHandle(cur);
                }
                add(event.name, cur.invoker, event.once, event.capture);
            } else if (cur !== old) {
                old.fn = cur;
                on[name] = old;
            }
        }
        for (name in oldOn) {
            if (!on[name]) {
                event = normalizeEvent(name);
                remove$$1(event.name, oldOn[name].invoker, event.capture);
            }
        }
    }

    /*  */

    // The template compiler attempts to minimize the need for normalization by
    // statically analyzing the template at compile time.
    //
    // For plain HTML markup, normalization can be completely skipped because the
    // generated render function is guaranteed to return Array<VNode>. There are
    // two cases where extra normalization is needed:

    // 1. When the children contains components - because a functional component
    // may return an Array instead of a single root. In this case, just a simple
    // nomralization is needed - if any child is an Array, we flatten the whole
    // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
    // because functional components already normalize their own children.
    function simpleNormalizeChildren(children) {
        for (var i = 0; i < children.length; i++) {
            if (Array.isArray(children[i])) {
                return Array.prototype.concat.apply([], children)
            }
        }
        return children
    }

    // 2. When the children contains constrcuts that always generated nested Arrays,
    // e.g. <template>, <slot>, v-for, or when the children is provided by user
    // with hand-written render functions / JSX. In such cases a full normalization
    // is needed to cater to all possible types of children values.
    function normalizeChildren(children) {
        return isPrimitive(children)
            ? [createTextVNode(children)]
            : Array.isArray(children)
                ? normalizeArrayChildren(children)
                : undefined
    }

    function normalizeArrayChildren(children, nestedIndex) {
        var res = [];
        var i, c, last;
        for (i = 0; i < children.length; i++) {
            c = children[i];
            if (c == null || typeof c === 'boolean') { continue }
            last = res[res.length - 1];
            //  nested
            if (Array.isArray(c)) {
                res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
            } else if (isPrimitive(c)) {
                if (last && last.text) {
                    last.text += String(c);
                } else if (c !== '') {
                    // convert primitive to vnode
                    res.push(createTextVNode(c));
                }
            } else {
                if (c.text && last && last.text) {
                    res[res.length - 1] = createTextVNode(last.text + c.text);
                } else {
                    // default key for nested array children (likely generated by v-for)
                    if (c.tag && c.key == null && nestedIndex != null) {
                        c.key = "__vlist" + nestedIndex + "_" + i + "__";
                    }
                    res.push(c);
                }
            }
        }
        return res
    }

    /*  */

    function getFirstComponentChild(children) {
        return children && children.filter(function (c) { return c && c.componentOptions; })[0]
    }

    /*  */

    var SIMPLE_NORMALIZE = 1;
    var ALWAYS_NORMALIZE = 2;

    // wrapper function for providing a more flexible interface
    // without getting yelled at by flow
    function createElement(
        context,
        tag,
        data,
        children,
        normalizationType,
        alwaysNormalize
    ) {
        if (Array.isArray(data) || isPrimitive(data)) {
            normalizationType = children;
            children = data;
            data = undefined;
        }
        if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
        return _createElement(context, tag, data, children, normalizationType)
    }

    function _createElement(
        context,
        tag,
        data,
        children,
        normalizationType
    ) {
        if (data && data.__ob__) {
            "development" !== 'production' && warn(
                "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
                'Always create fresh vnode data objects in each render!',
                context
            );
            return createEmptyVNode()
        }
        if (!tag) {
            // in case of component :is set to falsy value
            return createEmptyVNode()
        }
        // support single function children as default scoped slot
        if (Array.isArray(children) &&
            typeof children[0] === 'function') {
            data = data || {};
            data.scopedSlots = { default: children[0] };
            children.length = 0;
        }
        if (normalizationType === ALWAYS_NORMALIZE) {
            children = normalizeChildren(children);
        } else if (normalizationType === SIMPLE_NORMALIZE) {
            children = simpleNormalizeChildren(children);
        }
        var vnode, ns;
        if (typeof tag === 'string') {
            var Ctor;
            ns = config.getTagNamespace(tag);
            if (config.isReservedTag(tag)) {
                // platform built-in elements
                vnode = new VNode(
                    config.parsePlatformTagName(tag), data, children,
                    undefined, undefined, context
                );
            } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
                // component
                vnode = createComponent(Ctor, data, context, children, tag);
            } else {
                // unknown or unlisted namespaced elements
                // check at runtime because it may get assigned a namespace when its
                // parent normalizes children
                vnode = new VNode(
                    tag, data, children,
                    undefined, undefined, context
                );
            }
        } else {
            // direct component options / constructor
            vnode = createComponent(tag, data, context, children);
        }
        if (vnode) {
            if (ns) { applyNS(vnode, ns); }
            return vnode
        } else {
            return createEmptyVNode()
        }
    }

    function applyNS(vnode, ns) {
        vnode.ns = ns;
        if (vnode.tag === 'foreignObject') {
            // use default namespace inside foreignObject
            return
        }
        if (vnode.children) {
            for (var i = 0, l = vnode.children.length; i < l; i++) {
                var child = vnode.children[i];
                if (child.tag && !child.ns) {
                    applyNS(child, ns);
                }
            }
        }
    }

    /*  */

    function initRender(vm) {
        vm.$vnode = null; // the placeholder node in parent tree
        vm._vnode = null; // the root of the child tree
        vm._staticTrees = null;
        var parentVnode = vm.$options._parentVnode;
        var renderContext = parentVnode && parentVnode.context;
        vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
        vm.$scopedSlots = {};
        // bind the createElement fn to this instance
        // so that we get proper render context inside it.
        // args order: tag, data, children, normalizationType, alwaysNormalize
        // internal version is used by render functions compiled from templates
        vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
        // normalization is always applied for the public version, used in
        // user-written render functions.
        vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
    }

    function renderMixin(Vue) {
        Vue.prototype.$nextTick = function (fn) {
            return nextTick(fn, this)
        };

        Vue.prototype._render = function () {
            var vm = this;
            var ref = vm.$options;
            var render = ref.render;
            var staticRenderFns = ref.staticRenderFns;
            var _parentVnode = ref._parentVnode;

            if (vm._isMounted) {
                // clone slot nodes on re-renders
                for (var key in vm.$slots) {
                    vm.$slots[key] = cloneVNodes(vm.$slots[key]);
                }
            }

            if (_parentVnode && _parentVnode.data.scopedSlots) {
                vm.$scopedSlots = _parentVnode.data.scopedSlots;
            }

            if (staticRenderFns && !vm._staticTrees) {
                vm._staticTrees = [];
            }
            // set parent vnode. this allows render functions to have access
            // to the data on the placeholder node.
            vm.$vnode = _parentVnode;
            // render self
            var vnode;
            try {
                vnode = render.call(vm._renderProxy, vm.$createElement);
            } catch (e) {
                /* istanbul ignore else */
                if (config.errorHandler) {
                    config.errorHandler.call(null, e, vm);
                } else {
                    {
                        warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
                    }
                    throw e
                }
                // return previous vnode to prevent render error causing blank component
                vnode = vm._vnode;
            }
            // return empty vnode in case the render function errored out
            if (!(vnode instanceof VNode)) {
                if ("development" !== 'production' && Array.isArray(vnode)) {
                    warn(
                        'Multiple root nodes returned from render function. Render function ' +
                        'should return a single root node.',
                        vm
                    );
                }
                vnode = createEmptyVNode();
            }
            // set parent
            vnode.parent = _parentVnode;
            return vnode
        };

        // toString for mustaches
        Vue.prototype._s = _toString;
        // convert text to vnode
        Vue.prototype._v = createTextVNode;
        // number conversion
        Vue.prototype._n = toNumber;
        // empty vnode
        Vue.prototype._e = createEmptyVNode;
        // loose equal
        Vue.prototype._q = looseEqual;
        // loose indexOf
        Vue.prototype._i = looseIndexOf;

        // render static tree by index
        Vue.prototype._m = function renderStatic(
            index,
            isInFor
        ) {
            var tree = this._staticTrees[index];
            // if has already-rendered static tree and not inside v-for,
            // we can reuse the same tree by doing a shallow clone.
            if (tree && !isInFor) {
                return Array.isArray(tree)
                    ? cloneVNodes(tree)
                    : cloneVNode(tree)
            }
            // otherwise, render a fresh tree.
            tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
            markStatic(tree, ("__static__" + index), false);
            return tree
        };

        // mark node as static (v-once)
        Vue.prototype._o = function markOnce(
            tree,
            index,
            key
        ) {
            markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
            return tree
        };

        function markStatic(tree, key, isOnce) {
            if (Array.isArray(tree)) {
                for (var i = 0; i < tree.length; i++) {
                    if (tree[i] && typeof tree[i] !== 'string') {
                        markStaticNode(tree[i], (key + "_" + i), isOnce);
                    }
                }
            } else {
                markStaticNode(tree, key, isOnce);
            }
        }

        function markStaticNode(node, key, isOnce) {
            node.isStatic = true;
            node.key = key;
            node.isOnce = isOnce;
        }

        // filter resolution helper
        Vue.prototype._f = function resolveFilter(id) {
            return resolveAsset(this.$options, 'filters', id, true) || identity
        };

        // render v-for
        Vue.prototype._l = function renderList(
            val,
            render
        ) {
            var ret, i, l, keys, key;
            if (Array.isArray(val) || typeof val === 'string') {
                ret = new Array(val.length);
                for (i = 0, l = val.length; i < l; i++) {
                    ret[i] = render(val[i], i);
                }
            } else if (typeof val === 'number') {
                ret = new Array(val);
                for (i = 0; i < val; i++) {
                    ret[i] = render(i + 1, i);
                }
            } else if (isObject(val)) {
                keys = Object.keys(val);
                ret = new Array(keys.length);
                for (i = 0, l = keys.length; i < l; i++) {
                    key = keys[i];
                    ret[i] = render(val[key], key, i);
                }
            }
            return ret
        };

        // renderSlot
        Vue.prototype._t = function (
            name,
            fallback,
            props,
            bindObject
        ) {
            var scopedSlotFn = this.$scopedSlots[name];
            if (scopedSlotFn) { // scoped slot
                props = props || {};
                if (bindObject) {
                    extend(props, bindObject);
                }
                return scopedSlotFn(props) || fallback
            } else {
                var slotNodes = this.$slots[name];
                // warn duplicate slot usage
                if (slotNodes && "development" !== 'production') {
                    slotNodes._rendered && warn(
                        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
                        "- this will likely cause render errors.",
                        this
                    );
                    slotNodes._rendered = true;
                }
                return slotNodes || fallback
            }
        };

        // apply v-bind object
        Vue.prototype._b = function bindProps(
            data,
            tag,
            value,
            asProp
        ) {
            if (value) {
                if (!isObject(value)) {
                    "development" !== 'production' && warn(
                        'v-bind without argument expects an Object or Array value',
                        this
                    );
                } else {
                    if (Array.isArray(value)) {
                        value = toObject(value);
                    }
                    for (var key in value) {
                        if (key === 'class' || key === 'style') {
                            data[key] = value[key];
                        } else {
                            var type = data.attrs && data.attrs.type;
                            var hash = asProp || config.mustUseProp(tag, type, key)
                                ? data.domProps || (data.domProps = {})
                                : data.attrs || (data.attrs = {});
                            hash[key] = value[key];
                        }
                    }
                }
            }
            return data
        };

        // check v-on keyCodes
        Vue.prototype._k = function checkKeyCodes(
            eventKeyCode,
            key,
            builtInAlias
        ) {
            var keyCodes = config.keyCodes[key] || builtInAlias;
            if (Array.isArray(keyCodes)) {
                return keyCodes.indexOf(eventKeyCode) === -1
            } else {
                return keyCodes !== eventKeyCode
            }
        };
    }

    function resolveSlots(
        children,
        context
    ) {
        var slots = {};
        if (!children) {
            return slots
        }
        var defaultSlot = [];
        var name, child;
        for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            // named slots should only be respected if the vnode was rendered in the
            // same context.
            if ((child.context === context || child.functionalContext === context) &&
                child.data && (name = child.data.slot)) {
                var slot = (slots[name] || (slots[name] = []));
                if (child.tag === 'template') {
                    slot.push.apply(slot, child.children);
                } else {
                    slot.push(child);
                }
            } else {
                defaultSlot.push(child);
            }
        }
        // ignore single whitespace
        if (defaultSlot.length && !(
            defaultSlot.length === 1 &&
            (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
        )) {
            slots.default = defaultSlot;
        }
        return slots
    }

    /*  */

    function initEvents(vm) {
        vm._events = Object.create(null);
        vm._hasHookEvent = false;
        // init parent attached events
        var listeners = vm.$options._parentListeners;
        if (listeners) {
            updateComponentListeners(vm, listeners);
        }
    }

    var target;

    function add$1(event, fn, once) {
        if (once) {
            target.$once(event, fn);
        } else {
            target.$on(event, fn);
        }
    }

    function remove$2(event, fn) {
        target.$off(event, fn);
    }

    function updateComponentListeners(
        vm,
        listeners,
        oldListeners
    ) {
        target = vm;
        updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);
    }

    function eventsMixin(Vue) {
        var hookRE = /^hook:/;
        Vue.prototype.$on = function (event, fn) {
            var vm = this; (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
            return vm
        };

        Vue.prototype.$once = function (event, fn) {
            var vm = this;
            function on() {
                vm.$off(event, on);
                fn.apply(vm, arguments);
            }
            on.fn = fn;
            vm.$on(event, on);
            return vm
        };

        Vue.prototype.$off = function (event, fn) {
            var vm = this;
            // all
            if (!arguments.length) {
                vm._events = Object.create(null);
                return vm
            }
            // specific event
            var cbs = vm._events[event];
            if (!cbs) {
                return vm
            }
            if (arguments.length === 1) {
                vm._events[event] = null;
                return vm
            }
            // specific handler
            var cb;
            var i = cbs.length;
            while (i--) {
                cb = cbs[i];
                if (cb === fn || cb.fn === fn) {
                    cbs.splice(i, 1);
                    break
                }
            }
            return vm
        };

        Vue.prototype.$emit = function (event) {
            var vm = this;
            var cbs = vm._events[event];
            if (cbs) {
                cbs = cbs.length > 1 ? toArray(cbs) : cbs;
                var args = toArray(arguments, 1);
                for (var i = 0, l = cbs.length; i < l; i++) {
                    cbs[i].apply(vm, args);
                }
            }
            return vm
        };
    }

    /*  */

    var activeInstance = null;

    function initLifecycle(vm) {
        var options = vm.$options;

        // locate first non-abstract parent
        var parent = options.parent;
        if (parent && !options.abstract) {
            while (parent.$options.abstract && parent.$parent) {
                parent = parent.$parent;
            }
            parent.$children.push(vm);
        }

        vm.$parent = parent;
        vm.$root = parent ? parent.$root : vm;

        vm.$children = [];
        vm.$refs = {};

        vm._watcher = null;
        vm._inactive = false;
        vm._isMounted = false;
        vm._isDestroyed = false;
        vm._isBeingDestroyed = false;
    }

    function lifecycleMixin(Vue) {
        Vue.prototype._mount = function (
            el,
            hydrating
        ) {
            var vm = this;
            vm.$el = el;
            if (!vm.$options.render) {
                vm.$options.render = createEmptyVNode;
                {
                    /* istanbul ignore if */
                    if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {
                        warn(
                            'You are using the runtime-only build of Vue where the template ' +
                            'option is not available. Either pre-compile the templates into ' +
                            'render functions, or use the compiler-included build.',
                            vm
                        );
                    } else {
                        warn(
                            'Failed to mount component: template or render function not defined.',
                            vm
                        );
                    }
                }
            }
            callHook(vm, 'beforeMount');
            vm._watcher = new Watcher(vm, function updateComponent() {
                vm._update(vm._render(), hydrating);
            }, noop);
            hydrating = false;
            // manually mounted instance, call mounted on self
            // mounted is called for render-created child components in its inserted hook
            if (vm.$vnode == null) {
                vm._isMounted = true;
                callHook(vm, 'mounted');
            }
            return vm
        };

        Vue.prototype._update = function (vnode, hydrating) {
            var vm = this;
            if (vm._isMounted) {
                callHook(vm, 'beforeUpdate');
            }
            var prevEl = vm.$el;
            var prevVnode = vm._vnode;
            var prevActiveInstance = activeInstance;
            activeInstance = vm;
            vm._vnode = vnode;
            // Vue.prototype.__patch__ is injected in entry points
            // based on the rendering backend used.
            if (!prevVnode) {
                // initial render
                vm.$el = vm.__patch__(
                    vm.$el, vnode, hydrating, false /* removeOnly */,
                    vm.$options._parentElm,
                    vm.$options._refElm
                );
            } else {
                // updates
                vm.$el = vm.__patch__(prevVnode, vnode);
            }
            activeInstance = prevActiveInstance;
            // update __vue__ reference
            if (prevEl) {
                prevEl.__vue__ = null;
            }
            if (vm.$el) {
                vm.$el.__vue__ = vm;
            }
            // if parent is an HOC, update its $el as well
            if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
                vm.$parent.$el = vm.$el;
            }
            // updated hook is called by the scheduler to ensure that children are
            // updated in a parent's updated hook.
        };

        Vue.prototype._updateFromParent = function (
            propsData,
            listeners,
            parentVnode,
            renderChildren
        ) {
            var vm = this;
            var hasChildren = !!(vm.$options._renderChildren || renderChildren);
            vm.$options._parentVnode = parentVnode;
            vm.$vnode = parentVnode; // update vm's placeholder node without re-render
            if (vm._vnode) { // update child tree's parent
                vm._vnode.parent = parentVnode;
            }
            vm.$options._renderChildren = renderChildren;
            // update props
            if (propsData && vm.$options.props) {
                observerState.shouldConvert = false;
                {
                    observerState.isSettingProps = true;
                }
                var propKeys = vm.$options._propKeys || [];
                for (var i = 0; i < propKeys.length; i++) {
                    var key = propKeys[i];
                    vm[key] = validateProp(key, vm.$options.props, propsData, vm);
                }
                observerState.shouldConvert = true;
                {
                    observerState.isSettingProps = false;
                }
                vm.$options.propsData = propsData;
            }
            // update listeners
            if (listeners) {
                var oldListeners = vm.$options._parentListeners;
                vm.$options._parentListeners = listeners;
                updateComponentListeners(vm, listeners, oldListeners);
            }
            // resolve slots + force update if has children
            if (hasChildren) {
                vm.$slots = resolveSlots(renderChildren, parentVnode.context);
                vm.$forceUpdate();
            }
        };

        Vue.prototype.$forceUpdate = function () {
            var vm = this;
            if (vm._watcher) {
                vm._watcher.update();
            }
        };

        Vue.prototype.$destroy = function () {
            var vm = this;
            if (vm._isBeingDestroyed) {
                return
            }
            callHook(vm, 'beforeDestroy');
            vm._isBeingDestroyed = true;
            // remove self from parent
            var parent = vm.$parent;
            if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
                remove$1(parent.$children, vm);
            }
            // teardown watchers
            if (vm._watcher) {
                vm._watcher.teardown();
            }
            var i = vm._watchers.length;
            while (i--) {
                vm._watchers[i].teardown();
            }
            // remove reference from data ob
            // frozen object may not have observer.
            if (vm._data.__ob__) {
                vm._data.__ob__.vmCount--;
            }
            // call the last hook...
            vm._isDestroyed = true;
            callHook(vm, 'destroyed');
            // turn off all instance listeners.
            vm.$off();
            // remove __vue__ reference
            if (vm.$el) {
                vm.$el.__vue__ = null;
            }
            // invoke destroy hooks on current rendered tree
            vm.__patch__(vm._vnode, null);
        };
    }

    function callHook(vm, hook) {
        var handlers = vm.$options[hook];
        if (handlers) {
            for (var i = 0, j = handlers.length; i < j; i++) {
                handlers[i].call(vm);
            }
        }
        if (vm._hasHookEvent) {
            vm.$emit('hook:' + hook);
        }
    }

    /*  */


    var queue = [];
    var has$1 = {};
    var circular = {};
    var waiting = false;
    var flushing = false;
    var index = 0;

    /**
     * Reset the scheduler's state.
     */
    function resetSchedulerState() {
        queue.length = 0;
        has$1 = {};
        {
            circular = {};
        }
        waiting = flushing = false;
    }

    /**
     * Flush both queues and run the watchers.
     */
    function flushSchedulerQueue() {
        flushing = true;
        var watcher, id, vm;

        // Sort queue before flush.
        // This ensures that:
        // 1. Components are updated from parent to child. (because parent is always
        //    created before the child)
        // 2. A component's user watchers are run before its render watcher (because
        //    user watchers are created before the render watcher)
        // 3. If a component is destroyed during a parent component's watcher run,
        //    its watchers can be skipped.
        queue.sort(function (a, b) { return a.id - b.id; });

        // do not cache length because more watchers might be pushed
        // as we run existing watchers
        for (index = 0; index < queue.length; index++) {
            watcher = queue[index];
            id = watcher.id;
            has$1[id] = null;
            watcher.run();
            // in dev build, check and stop circular updates.
            if ("development" !== 'production' && has$1[id] != null) {
                circular[id] = (circular[id] || 0) + 1;
                if (circular[id] > config._maxUpdateCount) {
                    warn(
                        'You may have an infinite update loop ' + (
                            watcher.user
                                ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                                : "in a component render function."
                        ),
                        watcher.vm
                    );
                    break
                }
            }
        }

        // call updated hooks
        index = queue.length;
        while (index--) {
            watcher = queue[index];
            vm = watcher.vm;
            if (vm._watcher === watcher && vm._isMounted) {
                callHook(vm, 'updated');
            }
        }

        // devtool hook
        /* istanbul ignore if */
        if (devtools && config.devtools) {
            devtools.emit('flush');
        }

        resetSchedulerState();
    }

    /**
     * Push a watcher into the watcher queue.
     * Jobs with duplicate IDs will be skipped unless it's
     * pushed when the queue is being flushed.
     */
    function queueWatcher(watcher) {
        var id = watcher.id;
        if (has$1[id] == null) {
            has$1[id] = true;
            if (!flushing) {
                queue.push(watcher);
            } else {
                // if already flushing, splice the watcher based on its id
                // if already past its id, it will be run next immediately.
                var i = queue.length - 1;
                while (i >= 0 && queue[i].id > watcher.id) {
                    i--;
                }
                queue.splice(Math.max(i, index) + 1, 0, watcher);
            }
            // queue the flush
            if (!waiting) {
                waiting = true;
                nextTick(flushSchedulerQueue);
            }
        }
    }

    /*  */

    var uid$2 = 0;

    /**
     * A watcher parses an expression, collects dependencies,
     * and fires callback when the expression value changes.
     * This is used for both the $watch() api and directives.
     */
    var Watcher = function Watcher(
        vm,
        expOrFn,
        cb,
        options
    ) {
        this.vm = vm;
        vm._watchers.push(this);
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
        } else {
            this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$2; // uid for batching
        this.active = true;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression = expOrFn.toString();
        // parse expression for getter
        if (typeof expOrFn === 'function') {
            this.getter = expOrFn;
        } else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = function () { };
                "development" !== 'production' && warn(
                    "Failed watching path: \"" + expOrFn + "\" " +
                    'Watcher only accepts simple dot-delimited paths. ' +
                    'For full control, use a function instead.',
                    vm
                );
            }
        }
        this.value = this.lazy
            ? undefined
            : this.get();
    };

    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    Watcher.prototype.get = function get() {
        pushTarget(this);
        var value = this.getter.call(this.vm, this.vm);
        // "touch" every property so they are all tracked as
        // dependencies for deep watching
        if (this.deep) {
            traverse(value);
        }
        popTarget();
        this.cleanupDeps();
        return value
    };

    /**
     * Add a dependency to this directive.
     */
    Watcher.prototype.addDep = function addDep(dep) {
        var id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    };

    /**
     * Clean up for dependency collection.
     */
    Watcher.prototype.cleanupDeps = function cleanupDeps() {
        var this$1 = this;

        var i = this.deps.length;
        while (i--) {
            var dep = this$1.deps[i];
            if (!this$1.newDepIds.has(dep.id)) {
                dep.removeSub(this$1);
            }
        }
        var tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    };

    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    Watcher.prototype.update = function update() {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true;
        } else if (this.sync) {
            this.run();
        } else {
            queueWatcher(this);
        }
    };

    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    Watcher.prototype.run = function run() {
        if (this.active) {
            var value = this.get();
            if (
                value !== this.value ||
                // Deep watchers and watchers on Object/Arrays should fire even
                // when the value is the same, because the value may
                // have mutated.
                isObject(value) ||
                this.deep
            ) {
                // set new value
                var oldValue = this.value;
                this.value = value;
                if (this.user) {
                    try {
                        this.cb.call(this.vm, value, oldValue);
                    } catch (e) {
                        /* istanbul ignore else */
                        if (config.errorHandler) {
                            config.errorHandler.call(null, e, this.vm);
                        } else {
                            "development" !== 'production' && warn(
                                ("Error in watcher \"" + (this.expression) + "\""),
                                this.vm
                            );
                            throw e
                        }
                    }
                } else {
                    this.cb.call(this.vm, value, oldValue);
                }
            }
        }
    };

    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    Watcher.prototype.evaluate = function evaluate() {
        this.value = this.get();
        this.dirty = false;
    };

    /**
     * Depend on all deps collected by this watcher.
     */
    Watcher.prototype.depend = function depend() {
        var this$1 = this;

        var i = this.deps.length;
        while (i--) {
            this$1.deps[i].depend();
        }
    };

    /**
     * Remove self from all dependencies' subscriber list.
     */
    Watcher.prototype.teardown = function teardown() {
        var this$1 = this;

        if (this.active) {
            // remove self from vm's watcher list
            // this is a somewhat expensive operation so we skip it
            // if the vm is being destroyed.
            if (!this.vm._isBeingDestroyed) {
                remove$1(this.vm._watchers, this);
            }
            var i = this.deps.length;
            while (i--) {
                this$1.deps[i].removeSub(this$1);
            }
            this.active = false;
        }
    };

    /**
     * Recursively traverse an object to evoke all converted
     * getters, so that every nested property inside the object
     * is collected as a "deep" dependency.
     */
    var seenObjects = new _Set();
    function traverse(val) {
        seenObjects.clear();
        _traverse(val, seenObjects);
    }

    function _traverse(val, seen) {
        var i, keys;
        var isA = Array.isArray(val);
        if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
            return
        }
        if (val.__ob__) {
            var depId = val.__ob__.dep.id;
            if (seen.has(depId)) {
                return
            }
            seen.add(depId);
        }
        if (isA) {
            i = val.length;
            while (i--) { _traverse(val[i], seen); }
        } else {
            keys = Object.keys(val);
            i = keys.length;
            while (i--) { _traverse(val[keys[i]], seen); }
        }
    }

    /*  */

    function initState(vm) {
        vm._watchers = [];
        var opts = vm.$options;
        if (opts.props) { initProps(vm, opts.props); }
        if (opts.methods) { initMethods(vm, opts.methods); }
        if (opts.data) {
            initData(vm);
        } else {
            observe(vm._data = {}, true /* asRootData */);
        }
        if (opts.computed) { initComputed(vm, opts.computed); }
        if (opts.watch) { initWatch(vm, opts.watch); }
    }

    var isReservedProp = { key: 1, ref: 1, slot: 1 };

    function initProps(vm, props) {
        var propsData = vm.$options.propsData || {};
        var keys = vm.$options._propKeys = Object.keys(props);
        var isRoot = !vm.$parent;
        // root instance props should be converted
        observerState.shouldConvert = isRoot;
        var loop = function (i) {
            var key = keys[i];
            /* istanbul ignore else */
            {
                if (isReservedProp[key]) {
                    warn(
                        ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
                        vm
                    );
                }
                defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
                    if (vm.$parent && !observerState.isSettingProps) {
                        warn(
                            "Avoid mutating a prop directly since the value will be " +
                            "overwritten whenever the parent component re-renders. " +
                            "Instead, use a data or computed property based on the prop's " +
                            "value. Prop being mutated: \"" + key + "\"",
                            vm
                        );
                    }
                });
            }
        };

        for (var i = 0; i < keys.length; i++) loop(i);
        observerState.shouldConvert = true;
    }

    function initData(vm) {
        var data = vm.$options.data;
        data = vm._data = typeof data === 'function'
            ? data.call(vm)
            : data || {};
        if (!isPlainObject(data)) {
            data = {};
            "development" !== 'production' && warn(
                'data functions should return an object:\n' +
                'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
                vm
            );
        }
        // proxy data on instance
        var keys = Object.keys(data);
        var props = vm.$options.props;
        var i = keys.length;
        while (i--) {
            if (props && hasOwn(props, keys[i])) {
                "development" !== 'production' && warn(
                    "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
                    "Use prop default value instead.",
                    vm
                );
            } else {
                proxy(vm, keys[i]);
            }
        }
        // observe data
        observe(data, true /* asRootData */);
    }

    var computedSharedDefinition = {
        enumerable: true,
        configurable: true,
        get: noop,
        set: noop
    };

    function initComputed(vm, computed) {
        for (var key in computed) {
            /* istanbul ignore if */
            if ("development" !== 'production' && key in vm) {
                warn(
                    "existing instance property \"" + key + "\" will be " +
                    "overwritten by a computed property with the same name.",
                    vm
                );
            }
            var userDef = computed[key];
            if (typeof userDef === 'function') {
                computedSharedDefinition.get = makeComputedGetter(userDef, vm);
                computedSharedDefinition.set = noop;
            } else {
                computedSharedDefinition.get = userDef.get
                    ? userDef.cache !== false
                        ? makeComputedGetter(userDef.get, vm)
                        : bind$1(userDef.get, vm)
                    : noop;
                computedSharedDefinition.set = userDef.set
                    ? bind$1(userDef.set, vm)
                    : noop;
            }
            Object.defineProperty(vm, key, computedSharedDefinition);
        }
    }

    function makeComputedGetter(getter, owner) {
        var watcher = new Watcher(owner, getter, noop, {
            lazy: true
        });
        return function computedGetter() {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                watcher.depend();
            }
            return watcher.value
        }
    }

    function initMethods(vm, methods) {
        for (var key in methods) {
            vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
            if ("development" !== 'production' && methods[key] == null) {
                warn(
                    "method \"" + key + "\" has an undefined value in the component definition. " +
                    "Did you reference the function correctly?",
                    vm
                );
            }
        }
    }

    function initWatch(vm, watch) {
        for (var key in watch) {
            var handler = watch[key];
            if (Array.isArray(handler)) {
                for (var i = 0; i < handler.length; i++) {
                    createWatcher(vm, key, handler[i]);
                }
            } else {
                createWatcher(vm, key, handler);
            }
        }
    }

    function createWatcher(vm, key, handler) {
        var options;
        if (isPlainObject(handler)) {
            options = handler;
            handler = handler.handler;
        }
        if (typeof handler === 'string') {
            handler = vm[handler];
        }
        vm.$watch(key, handler, options);
    }

    function stateMixin(Vue) {
        // flow somehow has problems with directly declared definition object
        // when using Object.defineProperty, so we have to procedurally build up
        // the object here.
        var dataDef = {};
        dataDef.get = function () {
            return this._data
        };
        {
            dataDef.set = function (newData) {
                warn(
                    'Avoid replacing instance root $data. ' +
                    'Use nested data properties instead.',
                    this
                );
            };
        }
        Object.defineProperty(Vue.prototype, '$data', dataDef);

        Vue.prototype.$set = set$1;
        Vue.prototype.$delete = del;

        Vue.prototype.$watch = function (
            expOrFn,
            cb,
            options
        ) {
            var vm = this;
            options = options || {};
            options.user = true;
            var watcher = new Watcher(vm, expOrFn, cb, options);
            if (options.immediate) {
                cb.call(vm, watcher.value);
            }
            return function unwatchFn() {
                watcher.teardown();
            }
        };
    }

    function proxy(vm, key) {
        if (!isReserved(key)) {
            Object.defineProperty(vm, key, {
                configurable: true,
                enumerable: true,
                get: function proxyGetter() {
                    return vm._data[key]
                },
                set: function proxySetter(val) {
                    vm._data[key] = val;
                }
            });
        }
    }

    /*  */

    var uid = 0;

    function initMixin(Vue) {
        Vue.prototype._init = function (options) {
            var vm = this;
            // a uid
            vm._uid = uid++;
            // a flag to avoid this being observed
            vm._isVue = true;
            // merge options
            if (options && options._isComponent) {
                // optimize internal component instantiation
                // since dynamic options merging is pretty slow, and none of the
                // internal component options needs special treatment.
                initInternalComponent(vm, options);
            } else {
                vm.$options = mergeOptions(
                    resolveConstructorOptions(vm.constructor),
                    options || {},
                    vm
                );
            }
            /* istanbul ignore else */
            {
                initProxy(vm);
            }
            // expose real self
            vm._self = vm;
            initLifecycle(vm);
            initEvents(vm);
            initRender(vm);
            callHook(vm, 'beforeCreate');
            initState(vm);
            callHook(vm, 'created');
            if (vm.$options.el) {
                vm.$mount(vm.$options.el);
            }
        };
    }

    function initInternalComponent(vm, options) {
        var opts = vm.$options = Object.create(vm.constructor.options);
        // doing this because it's faster than dynamic enumeration.
        opts.parent = options.parent;
        opts.propsData = options.propsData;
        opts._parentVnode = options._parentVnode;
        opts._parentListeners = options._parentListeners;
        opts._renderChildren = options._renderChildren;
        opts._componentTag = options._componentTag;
        opts._parentElm = options._parentElm;
        opts._refElm = options._refElm;
        if (options.render) {
            opts.render = options.render;
            opts.staticRenderFns = options.staticRenderFns;
        }
    }

    function resolveConstructorOptions(Ctor) {
        var options = Ctor.options;
        if (Ctor.super) {
            var superOptions = Ctor.super.options;
            var cachedSuperOptions = Ctor.superOptions;
            var extendOptions = Ctor.extendOptions;
            if (superOptions !== cachedSuperOptions) {
                // super option changed
                Ctor.superOptions = superOptions;
                extendOptions.render = options.render;
                extendOptions.staticRenderFns = options.staticRenderFns;
                extendOptions._scopeId = options._scopeId;
                options = Ctor.options = mergeOptions(superOptions, extendOptions);
                if (options.name) {
                    options.components[options.name] = Ctor;
                }
            }
        }
        return options
    }

    function Vue$3(options) {
        if ("development" !== 'production' &&
            !(this instanceof Vue$3)) {
            warn('Vue is a constructor and should be called with the `new` keyword');
        }
        this._init(options);
    }

    initMixin(Vue$3);
    stateMixin(Vue$3);
    eventsMixin(Vue$3);
    lifecycleMixin(Vue$3);
    renderMixin(Vue$3);

    /*  */

    function initUse(Vue) {
        Vue.use = function (plugin) {
            /* istanbul ignore if */
            if (plugin.installed) {
                return
            }
            // additional parameters
            var args = toArray(arguments, 1);
            args.unshift(this);
            if (typeof plugin.install === 'function') {
                plugin.install.apply(plugin, args);
            } else {
                plugin.apply(null, args);
            }
            plugin.installed = true;
            return this
        };
    }

    /*  */

    function initMixin$1(Vue) {
        Vue.mixin = function (mixin) {
            this.options = mergeOptions(this.options, mixin);
        };
    }

    /*  */

    function initExtend(Vue) {
        /**
         * Each instance constructor, including Vue, has a unique
         * cid. This enables us to create wrapped "child
         * constructors" for prototypal inheritance and cache them.
         */
        Vue.cid = 0;
        var cid = 1;

        /**
         * Class inheritance
         */
        Vue.extend = function (extendOptions) {
            extendOptions = extendOptions || {};
            var Super = this;
            var SuperId = Super.cid;
            var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
            if (cachedCtors[SuperId]) {
                return cachedCtors[SuperId]
            }
            var name = extendOptions.name || Super.options.name;
            {
                if (!/^[a-zA-Z][\w-]*$/.test(name)) {
                    warn(
                        'Invalid component name: "' + name + '". Component names ' +
                        'can only contain alphanumeric characters and the hyphen, ' +
                        'and must start with a letter.'
                    );
                }
            }
            var Sub = function VueComponent(options) {
                this._init(options);
            };
            Sub.prototype = Object.create(Super.prototype);
            Sub.prototype.constructor = Sub;
            Sub.cid = cid++;
            Sub.options = mergeOptions(
                Super.options,
                extendOptions
            );
            Sub['super'] = Super;
            // allow further extension/mixin/plugin usage
            Sub.extend = Super.extend;
            Sub.mixin = Super.mixin;
            Sub.use = Super.use;
            // create asset registers, so extended classes
            // can have their private assets too.
            config._assetTypes.forEach(function (type) {
                Sub[type] = Super[type];
            });
            // enable recursive self-lookup
            if (name) {
                Sub.options.components[name] = Sub;
            }
            // keep a reference to the super options at extension time.
            // later at instantiation we can check if Super's options have
            // been updated.
            Sub.superOptions = Super.options;
            Sub.extendOptions = extendOptions;
            // cache constructor
            cachedCtors[SuperId] = Sub;
            return Sub
        };
    }

    /*  */

    function initAssetRegisters(Vue) {
        /**
         * Create asset registration methods.
         */
        config._assetTypes.forEach(function (type) {
            Vue[type] = function (
                id,
                definition
            ) {
                if (!definition) {
                    return this.options[type + 's'][id]
                } else {
                    /* istanbul ignore if */
                    {
                        if (type === 'component' && config.isReservedTag(id)) {
                            warn(
                                'Do not use built-in or reserved HTML elements as component ' +
                                'id: ' + id
                            );
                        }
                    }
                    if (type === 'component' && isPlainObject(definition)) {
                        definition.name = definition.name || id;
                        definition = this.options._base.extend(definition);
                    }
                    if (type === 'directive' && typeof definition === 'function') {
                        definition = { bind: definition, update: definition };
                    }
                    this.options[type + 's'][id] = definition;
                    return definition
                }
            };
        });
    }

    /*  */

    var patternTypes = [String, RegExp];

    function getComponentName(opts) {
        return opts && (opts.Ctor.options.name || opts.tag)
    }

    function matches(pattern, name) {
        if (typeof pattern === 'string') {
            return pattern.split(',').indexOf(name) > -1
        } else {
            return pattern.test(name)
        }
    }

    function pruneCache(cache, filter) {
        for (var key in cache) {
            var cachedNode = cache[key];
            if (cachedNode) {
                var name = getComponentName(cachedNode.componentOptions);
                if (name && !filter(name)) {
                    pruneCacheEntry(cachedNode);
                    cache[key] = null;
                }
            }
        }
    }

    function pruneCacheEntry(vnode) {
        if (vnode) {
            if (!vnode.componentInstance._inactive) {
                callHook(vnode.componentInstance, 'deactivated');
            }
            vnode.componentInstance.$destroy();
        }
    }

    var KeepAlive = {
        name: 'keep-alive',
        abstract: true,

        props: {
            include: patternTypes,
            exclude: patternTypes
        },

        created: function created() {
            this.cache = Object.create(null);
        },

        destroyed: function destroyed() {
            var this$1 = this;

            for (var key in this.cache) {
                pruneCacheEntry(this$1.cache[key]);
            }
        },

        watch: {
            include: function include(val) {
                pruneCache(this.cache, function (name) { return matches(val, name); });
            },
            exclude: function exclude(val) {
                pruneCache(this.cache, function (name) { return !matches(val, name); });
            }
        },

        render: function render() {
            var vnode = getFirstComponentChild(this.$slots.default);
            var componentOptions = vnode && vnode.componentOptions;
            if (componentOptions) {
                // check pattern
                var name = getComponentName(componentOptions);
                if (name && (
                    (this.include && !matches(this.include, name)) ||
                    (this.exclude && matches(this.exclude, name))
                )) {
                    return vnode
                }
                var key = vnode.key == null
                    // same constructor may get registered as different local components
                    // so cid alone is not enough (#3269)
                    ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
                    : vnode.key;
                if (this.cache[key]) {
                    vnode.componentInstance = this.cache[key].componentInstance;
                } else {
                    this.cache[key] = vnode;
                }
                vnode.data.keepAlive = true;
            }
            return vnode
        }
    };

    var builtInComponents = {
        KeepAlive: KeepAlive
    };

    /*  */

    function initGlobalAPI(Vue) {
        // config
        var configDef = {};
        configDef.get = function () { return config; };
        {
            configDef.set = function () {
                warn(
                    'Do not replace the Vue.config object, set individual fields instead.'
                );
            };
        }
        Object.defineProperty(Vue, 'config', configDef);
        Vue.util = util;
        Vue.set = set$1;
        Vue.delete = del;
        Vue.nextTick = nextTick;

        Vue.options = Object.create(null);
        config._assetTypes.forEach(function (type) {
            Vue.options[type + 's'] = Object.create(null);
        });

        // this is used to identify the "base" constructor to extend all plain-object
        // components with in Weex's multi-instance scenarios.
        Vue.options._base = Vue;

        extend(Vue.options.components, builtInComponents);

        initUse(Vue);
        initMixin$1(Vue);
        initExtend(Vue);
        initAssetRegisters(Vue);
    }

    initGlobalAPI(Vue$3);

    Object.defineProperty(Vue$3.prototype, '$isServer', {
        get: isServerRendering
    });

    Vue$3.version = '2.1.10';

    /*  */

    // attributes that should be using props for binding
    var acceptValue = makeMap('input,textarea,option,select');
    var mustUseProp = function (tag, type, attr) {
        return (
            (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
            (attr === 'selected' && tag === 'option') ||
            (attr === 'checked' && tag === 'input') ||
            (attr === 'muted' && tag === 'video')
        )
    };

    var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

    var isBooleanAttr = makeMap(
        'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
        'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
        'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
        'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
        'required,reversed,scoped,seamless,selected,sortable,translate,' +
        'truespeed,typemustmatch,visible'
    );

    var xlinkNS = 'http://www.w3.org/1999/xlink';

    var isXlink = function (name) {
        return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
    };

    var getXlinkProp = function (name) {
        return isXlink(name) ? name.slice(6, name.length) : ''
    };

    var isFalsyAttrValue = function (val) {
        return val == null || val === false
    };

    /*  */

    function genClassForVnode(vnode) {
        var data = vnode.data;
        var parentNode = vnode;
        var childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode.data) {
                data = mergeClassData(childNode.data, data);
            }
        }
        while ((parentNode = parentNode.parent)) {
            if (parentNode.data) {
                data = mergeClassData(data, parentNode.data);
            }
        }
        return genClassFromData(data)
    }

    function mergeClassData(child, parent) {
        return {
            staticClass: concat(child.staticClass, parent.staticClass),
            class: child.class
                ? [child.class, parent.class]
                : parent.class
        }
    }

    function genClassFromData(data) {
        var dynamicClass = data.class;
        var staticClass = data.staticClass;
        if (staticClass || dynamicClass) {
            return concat(staticClass, stringifyClass(dynamicClass))
        }
        /* istanbul ignore next */
        return ''
    }

    function concat(a, b) {
        return a ? b ? (a + ' ' + b) : a : (b || '')
    }

    function stringifyClass(value) {
        var res = '';
        if (!value) {
            return res
        }
        if (typeof value === 'string') {
            return value
        }
        if (Array.isArray(value)) {
            var stringified;
            for (var i = 0, l = value.length; i < l; i++) {
                if (value[i]) {
                    if ((stringified = stringifyClass(value[i]))) {
                        res += stringified + ' ';
                    }
                }
            }
            return res.slice(0, -1)
        }
        if (isObject(value)) {
            for (var key in value) {
                if (value[key]) { res += key + ' '; }
            }
            return res.slice(0, -1)
        }
        /* istanbul ignore next */
        return res
    }

    /*  */

    var namespaceMap = {
        svg: 'http://www.w3.org/2000/svg',
        math: 'http://www.w3.org/1998/Math/MathML'
    };

    var isHTMLTag = makeMap(
        'html,body,base,head,link,meta,style,title,' +
        'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
        'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
        'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
        's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
        'embed,object,param,source,canvas,script,noscript,del,ins,' +
        'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
        'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
        'output,progress,select,textarea,' +
        'details,dialog,menu,menuitem,summary,' +
        'content,element,shadow,template'
    );

    // this map is intentionally selective, only covering SVG elements that may
    // contain child elements.
    var isSVG = makeMap(
        'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +
        'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
        'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
        true
    );

    var isPreTag = function (tag) { return tag === 'pre'; };

    var isReservedTag = function (tag) {
        return isHTMLTag(tag) || isSVG(tag)
    };

    function getTagNamespace(tag) {
        if (isSVG(tag)) {
            return 'svg'
        }
        // basic support for MathML
        // note it doesn't support other MathML elements being component roots
        if (tag === 'math') {
            return 'math'
        }
    }

    var unknownElementCache = Object.create(null);
    function isUnknownElement(tag) {
        /* istanbul ignore if */
        if (!inBrowser) {
            return true
        }
        if (isReservedTag(tag)) {
            return false
        }
        tag = tag.toLowerCase();
        /* istanbul ignore if */
        if (unknownElementCache[tag] != null) {
            return unknownElementCache[tag]
        }
        var el = document.createElement(tag);
        if (tag.indexOf('-') > -1) {
            // http://stackoverflow.com/a/28210364/1070244
            return (unknownElementCache[tag] = (
                el.constructor === window.HTMLUnknownElement ||
                el.constructor === window.HTMLElement
            ))
        } else {
            return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
        }
    }

    /*  */

    /**
     * Query an element selector if it's not an element already.
     */
    function query(el) {
        if (typeof el === 'string') {
            var selector = el;
            el = document.querySelector(el);
            if (!el) {
                "development" !== 'production' && warn(
                    'Cannot find element: ' + selector
                );
                return document.createElement('div')
            }
        }
        return el
    }

    /*  */

    function createElement$1(tagName, vnode) {
        var elm = document.createElement(tagName);
        if (tagName !== 'select') {
            return elm
        }
        if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
            elm.setAttribute('multiple', 'multiple');
        }
        return elm
    }

    function createElementNS(namespace, tagName) {
        return document.createElementNS(namespaceMap[namespace], tagName)
    }

    function createTextNode(text) {
        return document.createTextNode(text)
    }

    function createComment(text) {
        return document.createComment(text)
    }

    function insertBefore(parentNode, newNode, referenceNode) {
        parentNode.insertBefore(newNode, referenceNode);
    }

    function removeChild(node, child) {
        node.removeChild(child);
    }

    function appendChild(node, child) {
        node.appendChild(child);
    }

    function parentNode(node) {
        return node.parentNode
    }

    function nextSibling(node) {
        return node.nextSibling
    }

    function tagName(node) {
        return node.tagName
    }

    function setTextContent(node, text) {
        node.textContent = text;
    }

    function setAttribute(node, key, val) {
        node.setAttribute(key, val);
    }


    var nodeOps = Object.freeze({
        createElement: createElement$1,
        createElementNS: createElementNS,
        createTextNode: createTextNode,
        createComment: createComment,
        insertBefore: insertBefore,
        removeChild: removeChild,
        appendChild: appendChild,
        parentNode: parentNode,
        nextSibling: nextSibling,
        tagName: tagName,
        setTextContent: setTextContent,
        setAttribute: setAttribute
    });

    /*  */

    var ref = {
        create: function create(_, vnode) {
            registerRef(vnode);
        },
        update: function update(oldVnode, vnode) {
            if (oldVnode.data.ref !== vnode.data.ref) {
                registerRef(oldVnode, true);
                registerRef(vnode);
            }
        },
        destroy: function destroy(vnode) {
            registerRef(vnode, true);
        }
    };

    function registerRef(vnode, isRemoval) {
        var key = vnode.data.ref;
        if (!key) { return }

        var vm = vnode.context;
        var ref = vnode.componentInstance || vnode.elm;
        var refs = vm.$refs;
        if (isRemoval) {
            if (Array.isArray(refs[key])) {
                remove$1(refs[key], ref);
            } else if (refs[key] === ref) {
                refs[key] = undefined;
            }
        } else {
            if (vnode.data.refInFor) {
                if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
                    refs[key].push(ref);
                } else {
                    refs[key] = [ref];
                }
            } else {
                refs[key] = ref;
            }
        }
    }

    /**
     * Virtual DOM patching algorithm based on Snabbdom by
     * Simon Friis Vindum (@paldepind)
     * Licensed under the MIT License
     * https://github.com/paldepind/snabbdom/blob/master/LICENSE
     *
     * modified by Evan You (@yyx990803)
     *
    
    /*
     * Not type-checking this because this file is perf-critical and the cost
     * of making flow understand it is not worth it.
     */

    var emptyNode = new VNode('', {}, []);

    var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];

    function isUndef(s) {
        return s == null
    }

    function isDef(s) {
        return s != null
    }

    function sameVnode(vnode1, vnode2) {
        return (
            vnode1.key === vnode2.key &&
            vnode1.tag === vnode2.tag &&
            vnode1.isComment === vnode2.isComment &&
            !vnode1.data === !vnode2.data
        )
    }

    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var i, key;
        var map = {};
        for (i = beginIdx; i <= endIdx; ++i) {
            key = children[i].key;
            if (isDef(key)) { map[key] = i; }
        }
        return map
    }

    function createPatchFunction(backend) {
        var i, j;
        var cbs = {};

        var modules = backend.modules;
        var nodeOps = backend.nodeOps;

        for (i = 0; i < hooks$1.length; ++i) {
            cbs[hooks$1[i]] = [];
            for (j = 0; j < modules.length; ++j) {
                if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
            }
        }

        function emptyNodeAt(elm) {
            return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
        }

        function createRmCb(childElm, listeners) {
            function remove$$1() {
                if (--remove$$1.listeners === 0) {
                    removeNode(childElm);
                }
            }
            remove$$1.listeners = listeners;
            return remove$$1
        }

        function removeNode(el) {
            var parent = nodeOps.parentNode(el);
            // element may have already been removed due to v-html / v-text
            if (parent) {
                nodeOps.removeChild(parent, el);
            }
        }

        var inPre = 0;
        function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
            vnode.isRootInsert = !nested; // for transition enter check
            if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
                return
            }

            var data = vnode.data;
            var children = vnode.children;
            var tag = vnode.tag;
            if (isDef(tag)) {
                {
                    if (data && data.pre) {
                        inPre++;
                    }
                    if (
                        !inPre &&
                        !vnode.ns &&
                        !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
                        config.isUnknownElement(tag)
                    ) {
                        warn(
                            'Unknown custom element: <' + tag + '> - did you ' +
                            'register the component correctly? For recursive components, ' +
                            'make sure to provide the "name" option.',
                            vnode.context
                        );
                    }
                }
                vnode.elm = vnode.ns
                    ? nodeOps.createElementNS(vnode.ns, tag)
                    : nodeOps.createElement(tag, vnode);
                setScope(vnode);

                /* istanbul ignore if */
                {
                    createChildren(vnode, children, insertedVnodeQueue);
                    if (isDef(data)) {
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                    }
                    insert(parentElm, vnode.elm, refElm);
                }

                if ("development" !== 'production' && data && data.pre) {
                    inPre--;
                }
            } else if (vnode.isComment) {
                vnode.elm = nodeOps.createComment(vnode.text);
                insert(parentElm, vnode.elm, refElm);
            } else {
                vnode.elm = nodeOps.createTextNode(vnode.text);
                insert(parentElm, vnode.elm, refElm);
            }
        }

        function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i = vnode.data;
            if (isDef(i)) {
                var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
                if (isDef(i = i.hook) && isDef(i = i.init)) {
                    i(vnode, false /* hydrating */, parentElm, refElm);
                }
                // after calling the init hook, if the vnode is a child component
                // it should've created a child instance and mounted it. the child
                // component also has set the placeholder vnode's elm.
                // in that case we can just return the element and be done.
                if (isDef(vnode.componentInstance)) {
                    initComponent(vnode, insertedVnodeQueue);
                    if (isReactivated) {
                        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                    }
                    return true
                }
            }
        }

        function initComponent(vnode, insertedVnodeQueue) {
            if (vnode.data.pendingInsert) {
                insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            }
            vnode.elm = vnode.componentInstance.$el;
            if (isPatchable(vnode)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
                setScope(vnode);
            } else {
                // empty component root.
                // skip all element-related modules except for ref (#3455)
                registerRef(vnode);
                // make sure to invoke the insert hook
                insertedVnodeQueue.push(vnode);
            }
        }

        function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i;
            // hack for #4339: a reactivated component with inner transition
            // does not trigger because the inner node's created hooks are not called
            // again. It's not ideal to involve module-specific logic in here but
            // there doesn't seem to be a better way to do it.
            var innerNode = vnode;
            while (innerNode.componentInstance) {
                innerNode = innerNode.componentInstance._vnode;
                if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                    for (i = 0; i < cbs.activate.length; ++i) {
                        cbs.activate[i](emptyNode, innerNode);
                    }
                    insertedVnodeQueue.push(innerNode);
                    break
                }
            }
            // unlike a newly created component,
            // a reactivated keep-alive component doesn't insert itself
            insert(parentElm, vnode.elm, refElm);
        }

        function insert(parent, elm, ref) {
            if (parent) {
                if (ref) {
                    nodeOps.insertBefore(parent, elm, ref);
                } else {
                    nodeOps.appendChild(parent, elm);
                }
            }
        }

        function createChildren(vnode, children, insertedVnodeQueue) {
            if (Array.isArray(children)) {
                for (var i = 0; i < children.length; ++i) {
                    createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
                }
            } else if (isPrimitive(vnode.text)) {
                nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
            }
        }

        function isPatchable(vnode) {
            while (vnode.componentInstance) {
                vnode = vnode.componentInstance._vnode;
            }
            return isDef(vnode.tag)
        }

        function invokeCreateHooks(vnode, insertedVnodeQueue) {
            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, vnode);
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create) { i.create(emptyNode, vnode); }
                if (i.insert) { insertedVnodeQueue.push(vnode); }
            }
        }

        // set scope id attribute for scoped CSS.
        // this is implemented as a special case to avoid the overhead
        // of going through the normal attribute patching process.
        function setScope(vnode) {
            var i;
            if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
                nodeOps.setAttribute(vnode.elm, i, '');
            }
            if (isDef(i = activeInstance) &&
                i !== vnode.context &&
                isDef(i = i.$options._scopeId)) {
                nodeOps.setAttribute(vnode.elm, i, '');
            }
        }

        function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
                createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
            }
        }

        function invokeDestroyHook(vnode) {
            var i, j;
            var data = vnode.data;
            if (isDef(data)) {
                if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
                for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
            }
            if (isDef(i = vnode.children)) {
                for (j = 0; j < vnode.children.length; ++j) {
                    invokeDestroyHook(vnode.children[j]);
                }
            }
        }

        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
                var ch = vnodes[startIdx];
                if (isDef(ch)) {
                    if (isDef(ch.tag)) {
                        removeAndInvokeRemoveHook(ch);
                        invokeDestroyHook(ch);
                    } else { // Text node
                        removeNode(ch.elm);
                    }
                }
            }
        }

        function removeAndInvokeRemoveHook(vnode, rm) {
            if (rm || isDef(vnode.data)) {
                var listeners = cbs.remove.length + 1;
                if (!rm) {
                    // directly removing
                    rm = createRmCb(vnode.elm, listeners);
                } else {
                    // we have a recursively passed down rm callback
                    // increase the listeners count
                    rm.listeners += listeners;
                }
                // recursively invoke hooks on child component root node
                if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
                    removeAndInvokeRemoveHook(i, rm);
                }
                for (i = 0; i < cbs.remove.length; ++i) {
                    cbs.remove[i](vnode, rm);
                }
                if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                    i(vnode, rm);
                } else {
                    rm();
                }
            } else {
                removeNode(vnode.elm);
            }
        }

        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
            var oldStartIdx = 0;
            var newStartIdx = 0;
            var oldEndIdx = oldCh.length - 1;
            var oldStartVnode = oldCh[0];
            var oldEndVnode = oldCh[oldEndIdx];
            var newEndIdx = newCh.length - 1;
            var newStartVnode = newCh[0];
            var newEndVnode = newCh[newEndIdx];
            var oldKeyToIdx, idxInOld, elmToMove, refElm;

            // removeOnly is a special flag used only by <transition-group>
            // to ensure removed elements stay in correct relative positions
            // during leaving transitions
            var canMove = !removeOnly;

            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                if (isUndef(oldStartVnode)) {
                    oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
                } else if (isUndef(oldEndVnode)) {
                    oldEndVnode = oldCh[--oldEndIdx];
                } else if (sameVnode(oldStartVnode, newStartVnode)) {
                    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                    oldStartVnode = oldCh[++oldStartIdx];
                    newStartVnode = newCh[++newStartIdx];
                } else if (sameVnode(oldEndVnode, newEndVnode)) {
                    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                    oldEndVnode = oldCh[--oldEndIdx];
                    newEndVnode = newCh[--newEndIdx];
                } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                    canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                    oldStartVnode = oldCh[++oldStartIdx];
                    newEndVnode = newCh[--newEndIdx];
                } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                    canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                    oldEndVnode = oldCh[--oldEndIdx];
                    newStartVnode = newCh[++newStartIdx];
                } else {
                    if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
                    idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
                    if (isUndef(idxInOld)) { // New element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
                        newStartVnode = newCh[++newStartIdx];
                    } else {
                        elmToMove = oldCh[idxInOld];
                        /* istanbul ignore if */
                        if ("development" !== 'production' && !elmToMove) {
                            warn(
                                'It seems there are duplicate keys that is causing an update error. ' +
                                'Make sure each v-for item has a unique key.'
                            );
                        }
                        if (sameVnode(elmToMove, newStartVnode)) {
                            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                            oldCh[idxInOld] = undefined;
                            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
                            newStartVnode = newCh[++newStartIdx];
                        } else {
                            // same key but different element. treat as new element
                            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
                            newStartVnode = newCh[++newStartIdx];
                        }
                    }
                }
            }
            if (oldStartIdx > oldEndIdx) {
                refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            } else if (newStartIdx > newEndIdx) {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }

        function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
            if (oldVnode === vnode) {
                return
            }
            // reuse element for static trees.
            // note we only do this if the vnode is cloned -
            // if the new node is not cloned it means the render functions have been
            // reset by the hot-reload-api and we need to do a proper re-render.
            if (vnode.isStatic &&
                oldVnode.isStatic &&
                vnode.key === oldVnode.key &&
                (vnode.isCloned || vnode.isOnce)) {
                vnode.elm = oldVnode.elm;
                vnode.componentInstance = oldVnode.componentInstance;
                return
            }
            var i;
            var data = vnode.data;
            var hasData = isDef(data);
            if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
                i(oldVnode, vnode);
            }
            var elm = vnode.elm = oldVnode.elm;
            var oldCh = oldVnode.children;
            var ch = vnode.children;
            if (hasData && isPatchable(vnode)) {
                for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
                if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
            }
            if (isUndef(vnode.text)) {
                if (isDef(oldCh) && isDef(ch)) {
                    if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
                } else if (isDef(ch)) {
                    if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
                    addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
                } else if (isDef(oldCh)) {
                    removeVnodes(elm, oldCh, 0, oldCh.length - 1);
                } else if (isDef(oldVnode.text)) {
                    nodeOps.setTextContent(elm, '');
                }
            } else if (oldVnode.text !== vnode.text) {
                nodeOps.setTextContent(elm, vnode.text);
            }
            if (hasData) {
                if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
            }
        }

        function invokeInsertHook(vnode, queue, initial) {
            // delay insert hooks for component root nodes, invoke them after the
            // element is really inserted
            if (initial && vnode.parent) {
                vnode.parent.data.pendingInsert = queue;
            } else {
                for (var i = 0; i < queue.length; ++i) {
                    queue[i].data.hook.insert(queue[i]);
                }
            }
        }

        var bailed = false;
        // list of modules that can skip create hook during hydration because they
        // are already rendered on the client or has no need for initialization
        var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

        // Note: this is a browser-only function so we can assume elms are DOM nodes.
        function hydrate(elm, vnode, insertedVnodeQueue) {
            {
                if (!assertNodeMatch(elm, vnode)) {
                    return false
                }
            }
            vnode.elm = elm;
            var tag = vnode.tag;
            var data = vnode.data;
            var children = vnode.children;
            if (isDef(data)) {
                if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
                if (isDef(i = vnode.componentInstance)) {
                    // child component. it should have hydrated its own tree.
                    initComponent(vnode, insertedVnodeQueue);
                    return true
                }
            }
            if (isDef(tag)) {
                if (isDef(children)) {
                    // empty element, allow client to pick up and populate children
                    if (!elm.hasChildNodes()) {
                        createChildren(vnode, children, insertedVnodeQueue);
                    } else {
                        var childrenMatch = true;
                        var childNode = elm.firstChild;
                        for (var i$1 = 0; i$1 < children.length; i$1++) {
                            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                                childrenMatch = false;
                                break
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            if ("development" !== 'production' &&
                                typeof console !== 'undefined' &&
                                !bailed) {
                                bailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false
                        }
                    }
                }
                if (isDef(data)) {
                    for (var key in data) {
                        if (!isRenderedModule(key)) {
                            invokeCreateHooks(vnode, insertedVnodeQueue);
                            break
                        }
                    }
                }
            } else if (elm.data !== vnode.text) {
                elm.data = vnode.text;
            }
            return true
        }

        function assertNodeMatch(node, vnode) {
            if (vnode.tag) {
                return (
                    vnode.tag.indexOf('vue-component') === 0 ||
                    vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
                )
            } else {
                return node.nodeType === (vnode.isComment ? 8 : 3)
            }
        }

        return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
            if (!vnode) {
                if (oldVnode) { invokeDestroyHook(oldVnode); }
                return
            }

            var isInitialPatch = false;
            var insertedVnodeQueue = [];

            if (!oldVnode) {
                // empty mount (likely as component), create new root element
                isInitialPatch = true;
                createElm(vnode, insertedVnodeQueue, parentElm, refElm);
            } else {
                var isRealElement = isDef(oldVnode.nodeType);
                if (!isRealElement && sameVnode(oldVnode, vnode)) {
                    // patch existing root node
                    patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
                } else {
                    if (isRealElement) {
                        // mounting to a real element
                        // check if this is server-rendered content and if we can perform
                        // a successful hydration.
                        if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
                            oldVnode.removeAttribute('server-rendered');
                            hydrating = true;
                        }
                        if (hydrating) {
                            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                                invokeInsertHook(vnode, insertedVnodeQueue, true);
                                return oldVnode
                            } else {
                                warn(
                                    'The client-side rendered virtual DOM tree is not matching ' +
                                    'server-rendered content. This is likely caused by incorrect ' +
                                    'HTML markup, for example nesting block-level elements inside ' +
                                    '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                    'full client-side render.'
                                );
                            }
                        }
                        // either not server-rendered, or hydration failed.
                        // create an empty node and replace it
                        oldVnode = emptyNodeAt(oldVnode);
                    }
                    // replacing existing element
                    var oldElm = oldVnode.elm;
                    var parentElm$1 = nodeOps.parentNode(oldElm);
                    createElm(
                        vnode,
                        insertedVnodeQueue,
                        // extremely rare edge case: do not insert if old element is in a
                        // leaving transition. Only happens when combining transition +
                        // keep-alive + HOCs. (#4590)
                        oldElm._leaveCb ? null : parentElm$1,
                        nodeOps.nextSibling(oldElm)
                    );

                    if (vnode.parent) {
                        // component root element replaced.
                        // update parent placeholder node element, recursively
                        var ancestor = vnode.parent;
                        while (ancestor) {
                            ancestor.elm = vnode.elm;
                            ancestor = ancestor.parent;
                        }
                        if (isPatchable(vnode)) {
                            for (var i = 0; i < cbs.create.length; ++i) {
                                cbs.create[i](emptyNode, vnode.parent);
                            }
                        }
                    }

                    if (parentElm$1 !== null) {
                        removeVnodes(parentElm$1, [oldVnode], 0, 0);
                    } else if (isDef(oldVnode.tag)) {
                        invokeDestroyHook(oldVnode);
                    }
                }
            }

            invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
            return vnode.elm
        }
    }

    /*  */

    var directives = {
        create: updateDirectives,
        update: updateDirectives,
        destroy: function unbindDirectives(vnode) {
            updateDirectives(vnode, emptyNode);
        }
    };

    function updateDirectives(oldVnode, vnode) {
        if (oldVnode.data.directives || vnode.data.directives) {
            _update(oldVnode, vnode);
        }
    }

    function _update(oldVnode, vnode) {
        var isCreate = oldVnode === emptyNode;
        var isDestroy = vnode === emptyNode;
        var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
        var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

        var dirsWithInsert = [];
        var dirsWithPostpatch = [];

        var key, oldDir, dir;
        for (key in newDirs) {
            oldDir = oldDirs[key];
            dir = newDirs[key];
            if (!oldDir) {
                // new directive, bind
                callHook$1(dir, 'bind', vnode, oldVnode);
                if (dir.def && dir.def.inserted) {
                    dirsWithInsert.push(dir);
                }
            } else {
                // existing directive, update
                dir.oldValue = oldDir.value;
                callHook$1(dir, 'update', vnode, oldVnode);
                if (dir.def && dir.def.componentUpdated) {
                    dirsWithPostpatch.push(dir);
                }
            }
        }

        if (dirsWithInsert.length) {
            var callInsert = function () {
                for (var i = 0; i < dirsWithInsert.length; i++) {
                    callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
                }
            };
            if (isCreate) {
                mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
            } else {
                callInsert();
            }
        }

        if (dirsWithPostpatch.length) {
            mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
                for (var i = 0; i < dirsWithPostpatch.length; i++) {
                    callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
                }
            }, 'dir-postpatch');
        }

        if (!isCreate) {
            for (key in oldDirs) {
                if (!newDirs[key]) {
                    // no longer present, unbind
                    callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
                }
            }
        }
    }

    var emptyModifiers = Object.create(null);

    function normalizeDirectives$1(
        dirs,
        vm
    ) {
        var res = Object.create(null);
        if (!dirs) {
            return res
        }
        var i, dir;
        for (i = 0; i < dirs.length; i++) {
            dir = dirs[i];
            if (!dir.modifiers) {
                dir.modifiers = emptyModifiers;
            }
            res[getRawDirName(dir)] = dir;
            dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
        }
        return res
    }

    function getRawDirName(dir) {
        return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
    }

    function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
        var fn = dir.def && dir.def[hook];
        if (fn) {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        }
    }

    var baseModules = [
        ref,
        directives
    ];

    /*  */

    function updateAttrs(oldVnode, vnode) {
        if (!oldVnode.data.attrs && !vnode.data.attrs) {
            return
        }
        var key, cur, old;
        var elm = vnode.elm;
        var oldAttrs = oldVnode.data.attrs || {};
        var attrs = vnode.data.attrs || {};
        // clone observed objects, as the user probably wants to mutate it
        if (attrs.__ob__) {
            attrs = vnode.data.attrs = extend({}, attrs);
        }

        for (key in attrs) {
            cur = attrs[key];
            old = oldAttrs[key];
            if (old !== cur) {
                setAttr(elm, key, cur);
            }
        }
        // #4391: in IE9, setting type can reset value for input[type=radio]
        /* istanbul ignore if */
        if (isIE9 && attrs.value !== oldAttrs.value) {
            setAttr(elm, 'value', attrs.value);
        }
        for (key in oldAttrs) {
            if (attrs[key] == null) {
                if (isXlink(key)) {
                    elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
                } else if (!isEnumeratedAttr(key)) {
                    elm.removeAttribute(key);
                }
            }
        }
    }

    function setAttr(el, key, value) {
        if (isBooleanAttr(key)) {
            // set attribute for blank value
            // e.g. <option disabled>Select one</option>
            if (isFalsyAttrValue(value)) {
                el.removeAttribute(key);
            } else {
                el.setAttribute(key, key);
            }
        } else if (isEnumeratedAttr(key)) {
            el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
        } else if (isXlink(key)) {
            if (isFalsyAttrValue(value)) {
                el.removeAttributeNS(xlinkNS, getXlinkProp(key));
            } else {
                el.setAttributeNS(xlinkNS, key, value);
            }
        } else {
            if (isFalsyAttrValue(value)) {
                el.removeAttribute(key);
            } else {
                el.setAttribute(key, value);
            }
        }
    }

    var attrs = {
        create: updateAttrs,
        update: updateAttrs
    };

    /*  */

    function updateClass(oldVnode, vnode) {
        var el = vnode.elm;
        var data = vnode.data;
        var oldData = oldVnode.data;
        if (!data.staticClass && !data.class &&
            (!oldData || (!oldData.staticClass && !oldData.class))) {
            return
        }

        var cls = genClassForVnode(vnode);

        // handle transition classes
        var transitionClass = el._transitionClasses;
        if (transitionClass) {
            cls = concat(cls, stringifyClass(transitionClass));
        }

        // set the class
        if (cls !== el._prevClass) {
            el.setAttribute('class', cls);
            el._prevClass = cls;
        }
    }

    var klass = {
        create: updateClass,
        update: updateClass
    };

    /*  */

    var target$1;

    function add$2(
        event,
        handler,
        once,
        capture
    ) {
        if (once) {
            var oldHandler = handler;
            var _target = target$1; // save current target element in closure
            handler = function (ev) {
                remove$3(event, handler, capture, _target);
                arguments.length === 1
                    ? oldHandler(ev)
                    : oldHandler.apply(null, arguments);
            };
        }
        target$1.addEventListener(event, handler, capture);
    }

    function remove$3(
        event,
        handler,
        capture,
        _target
    ) {
        (_target || target$1).removeEventListener(event, handler, capture);
    }

    function updateDOMListeners(oldVnode, vnode) {
        if (!oldVnode.data.on && !vnode.data.on) {
            return
        }
        var on = vnode.data.on || {};
        var oldOn = oldVnode.data.on || {};
        target$1 = vnode.elm;
        updateListeners(on, oldOn, add$2, remove$3, vnode.context);
    }

    var events = {
        create: updateDOMListeners,
        update: updateDOMListeners
    };

    /*  */

    function updateDOMProps(oldVnode, vnode) {
        if (!oldVnode.data.domProps && !vnode.data.domProps) {
            return
        }
        var key, cur;
        var elm = vnode.elm;
        var oldProps = oldVnode.data.domProps || {};
        var props = vnode.data.domProps || {};
        // clone observed objects, as the user probably wants to mutate it
        if (props.__ob__) {
            props = vnode.data.domProps = extend({}, props);
        }

        for (key in oldProps) {
            if (props[key] == null) {
                elm[key] = '';
            }
        }
        for (key in props) {
            cur = props[key];
            // ignore children if the node has textContent or innerHTML,
            // as these will throw away existing DOM nodes and cause removal errors
            // on subsequent patches (#3360)
            if (key === 'textContent' || key === 'innerHTML') {
                if (vnode.children) { vnode.children.length = 0; }
                if (cur === oldProps[key]) { continue }
            }

            if (key === 'value') {
                // store value as _value as well since
                // non-string values will be stringified
                elm._value = cur;
                // avoid resetting cursor position when value is the same
                var strCur = cur == null ? '' : String(cur);
                if (shouldUpdateValue(elm, vnode, strCur)) {
                    elm.value = strCur;
                }
            } else {
                elm[key] = cur;
            }
        }
    }

    // check platforms/web/util/attrs.js acceptValue


    function shouldUpdateValue(
        elm,
        vnode,
        checkVal
    ) {
        return (!elm.composing && (
            vnode.tag === 'option' ||
            isDirty(elm, checkVal) ||
            isInputChanged(vnode, checkVal)
        ))
    }

    function isDirty(elm, checkVal) {
        // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
        return document.activeElement !== elm && elm.value !== checkVal
    }

    function isInputChanged(vnode, newVal) {
        var value = vnode.elm.value;
        var modifiers = vnode.elm._vModifiers; // injected by v-model runtime
        if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {
            return toNumber(value) !== toNumber(newVal)
        }
        if (modifiers && modifiers.trim) {
            return value.trim() !== newVal.trim()
        }
        return value !== newVal
    }

    var domProps = {
        create: updateDOMProps,
        update: updateDOMProps
    };

    /*  */

    var parseStyleText = cached(function (cssText) {
        var res = {};
        var listDelimiter = /;(?![^(]*\))/g;
        var propertyDelimiter = /:(.+)/;
        cssText.split(listDelimiter).forEach(function (item) {
            if (item) {
                var tmp = item.split(propertyDelimiter);
                tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
            }
        });
        return res
    });

    // merge static and dynamic style data on the same vnode
    function normalizeStyleData(data) {
        var style = normalizeStyleBinding(data.style);
        // static style is pre-processed into an object during compilation
        // and is always a fresh object, so it's safe to merge into it
        return data.staticStyle
            ? extend(data.staticStyle, style)
            : style
    }

    // normalize possible array / string values into Object
    function normalizeStyleBinding(bindingStyle) {
        if (Array.isArray(bindingStyle)) {
            return toObject(bindingStyle)
        }
        if (typeof bindingStyle === 'string') {
            return parseStyleText(bindingStyle)
        }
        return bindingStyle
    }

    /**
     * parent component style should be after child's
     * so that parent component's style could override it
     */
    function getStyle(vnode, checkChild) {
        var res = {};
        var styleData;

        if (checkChild) {
            var childNode = vnode;
            while (childNode.componentInstance) {
                childNode = childNode.componentInstance._vnode;
                if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                    extend(res, styleData);
                }
            }
        }

        if ((styleData = normalizeStyleData(vnode.data))) {
            extend(res, styleData);
        }

        var parentNode = vnode;
        while ((parentNode = parentNode.parent)) {
            if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
                extend(res, styleData);
            }
        }
        return res
    }

    /*  */

    var cssVarRE = /^--/;
    var importantRE = /\s*!important$/;
    var setProp = function (el, name, val) {
        /* istanbul ignore if */
        if (cssVarRE.test(name)) {
            el.style.setProperty(name, val);
        } else if (importantRE.test(val)) {
            el.style.setProperty(name, val.replace(importantRE, ''), 'important');
        } else {
            el.style[normalize(name)] = val;
        }
    };

    var prefixes = ['Webkit', 'Moz', 'ms'];

    var testEl;
    var normalize = cached(function (prop) {
        testEl = testEl || document.createElement('div');
        prop = camelize(prop);
        if (prop !== 'filter' && (prop in testEl.style)) {
            return prop
        }
        var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
        for (var i = 0; i < prefixes.length; i++) {
            var prefixed = prefixes[i] + upper;
            if (prefixed in testEl.style) {
                return prefixed
            }
        }
    });

    function updateStyle(oldVnode, vnode) {
        var data = vnode.data;
        var oldData = oldVnode.data;

        if (!data.staticStyle && !data.style &&
            !oldData.staticStyle && !oldData.style) {
            return
        }

        var cur, name;
        var el = vnode.elm;
        var oldStaticStyle = oldVnode.data.staticStyle;
        var oldStyleBinding = oldVnode.data.style || {};

        // if static style exists, stylebinding already merged into it when doing normalizeStyleData
        var oldStyle = oldStaticStyle || oldStyleBinding;

        var style = normalizeStyleBinding(vnode.data.style) || {};

        vnode.data.style = style.__ob__ ? extend({}, style) : style;

        var newStyle = getStyle(vnode, true);

        for (name in oldStyle) {
            if (newStyle[name] == null) {
                setProp(el, name, '');
            }
        }
        for (name in newStyle) {
            cur = newStyle[name];
            if (cur !== oldStyle[name]) {
                // ie9 setting to null has no effect, must use empty string
                setProp(el, name, cur == null ? '' : cur);
            }
        }
    }

    var style = {
        create: updateStyle,
        update: updateStyle
    };

    /*  */

    /**
     * Add class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
    function addClass(el, cls) {
        /* istanbul ignore if */
        if (!cls || !cls.trim()) {
            return
        }

        /* istanbul ignore else */
        if (el.classList) {
            if (cls.indexOf(' ') > -1) {
                cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
            } else {
                el.classList.add(cls);
            }
        } else {
            var cur = ' ' + el.getAttribute('class') + ' ';
            if (cur.indexOf(' ' + cls + ' ') < 0) {
                el.setAttribute('class', (cur + cls).trim());
            }
        }
    }

    /**
     * Remove class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
    function removeClass(el, cls) {
        /* istanbul ignore if */
        if (!cls || !cls.trim()) {
            return
        }

        /* istanbul ignore else */
        if (el.classList) {
            if (cls.indexOf(' ') > -1) {
                cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
            } else {
                el.classList.remove(cls);
            }
        } else {
            var cur = ' ' + el.getAttribute('class') + ' ';
            var tar = ' ' + cls + ' ';
            while (cur.indexOf(tar) >= 0) {
                cur = cur.replace(tar, ' ');
            }
            el.setAttribute('class', cur.trim());
        }
    }

    /*  */

    var hasTransition = inBrowser && !isIE9;
    var TRANSITION = 'transition';
    var ANIMATION = 'animation';

    // Transition property/event sniffing
    var transitionProp = 'transition';
    var transitionEndEvent = 'transitionend';
    var animationProp = 'animation';
    var animationEndEvent = 'animationend';
    if (hasTransition) {
        /* istanbul ignore if */
        if (window.ontransitionend === undefined &&
            window.onwebkittransitionend !== undefined) {
            transitionProp = 'WebkitTransition';
            transitionEndEvent = 'webkitTransitionEnd';
        }
        if (window.onanimationend === undefined &&
            window.onwebkitanimationend !== undefined) {
            animationProp = 'WebkitAnimation';
            animationEndEvent = 'webkitAnimationEnd';
        }
    }

    // binding to window is necessary to make hot reload work in IE in strict mode
    var raf = inBrowser && window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout;

    function nextFrame(fn) {
        raf(function () {
            raf(fn);
        });
    }

    function addTransitionClass(el, cls) {
        (el._transitionClasses || (el._transitionClasses = [])).push(cls);
        addClass(el, cls);
    }

    function removeTransitionClass(el, cls) {
        if (el._transitionClasses) {
            remove$1(el._transitionClasses, cls);
        }
        removeClass(el, cls);
    }

    function whenTransitionEnds(
        el,
        expectedType,
        cb
    ) {
        var ref = getTransitionInfo(el, expectedType);
        var type = ref.type;
        var timeout = ref.timeout;
        var propCount = ref.propCount;
        if (!type) { return cb() }
        var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
        var ended = 0;
        var end = function () {
            el.removeEventListener(event, onEnd);
            cb();
        };
        var onEnd = function (e) {
            if (e.target === el) {
                if (++ended >= propCount) {
                    end();
                }
            }
        };
        setTimeout(function () {
            if (ended < propCount) {
                end();
            }
        }, timeout + 1);
        el.addEventListener(event, onEnd);
    }

    var transformRE = /\b(transform|all)(,|$)/;

    function getTransitionInfo(el, expectedType) {
        var styles = window.getComputedStyle(el);
        var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
        var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
        var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
        var animationDelays = styles[animationProp + 'Delay'].split(', ');
        var animationDurations = styles[animationProp + 'Duration'].split(', ');
        var animationTimeout = getTimeout(animationDelays, animationDurations);

        var type;
        var timeout = 0;
        var propCount = 0;
        /* istanbul ignore if */
        if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
                type = TRANSITION;
                timeout = transitionTimeout;
                propCount = transitionDurations.length;
            }
        } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
                type = ANIMATION;
                timeout = animationTimeout;
                propCount = animationDurations.length;
            }
        } else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type = timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
            propCount = type
                ? type === TRANSITION
                    ? transitionDurations.length
                    : animationDurations.length
                : 0;
        }
        var hasTransform =
            type === TRANSITION &&
            transformRE.test(styles[transitionProp + 'Property']);
        return {
            type: type,
            timeout: timeout,
            propCount: propCount,
            hasTransform: hasTransform
        }
    }

    function getTimeout(delays, durations) {
        /* istanbul ignore next */
        while (delays.length < durations.length) {
            delays = delays.concat(delays);
        }

        return Math.max.apply(null, durations.map(function (d, i) {
            return toMs(d) + toMs(delays[i])
        }))
    }

    function toMs(s) {
        return Number(s.slice(0, -1)) * 1000
    }

    /*  */

    function enter(vnode, toggleDisplay) {
        var el = vnode.elm;

        // call leave callback now
        if (el._leaveCb) {
            el._leaveCb.cancelled = true;
            el._leaveCb();
        }

        var data = resolveTransition(vnode.data.transition);
        if (!data) {
            return
        }

        /* istanbul ignore if */
        if (el._enterCb || el.nodeType !== 1) {
            return
        }

        var css = data.css;
        var type = data.type;
        var enterClass = data.enterClass;
        var enterToClass = data.enterToClass;
        var enterActiveClass = data.enterActiveClass;
        var appearClass = data.appearClass;
        var appearToClass = data.appearToClass;
        var appearActiveClass = data.appearActiveClass;
        var beforeEnter = data.beforeEnter;
        var enter = data.enter;
        var afterEnter = data.afterEnter;
        var enterCancelled = data.enterCancelled;
        var beforeAppear = data.beforeAppear;
        var appear = data.appear;
        var afterAppear = data.afterAppear;
        var appearCancelled = data.appearCancelled;

        // activeInstance will always be the <transition> component managing this
        // transition. One edge case to check is when the <transition> is placed
        // as the root node of a child component. In that case we need to check
        // <transition>'s parent for appear check.
        var context = activeInstance;
        var transitionNode = activeInstance.$vnode;
        while (transitionNode && transitionNode.parent) {
            transitionNode = transitionNode.parent;
            context = transitionNode.context;
        }

        var isAppear = !context._isMounted || !vnode.isRootInsert;

        if (isAppear && !appear && appear !== '') {
            return
        }

        var startClass = isAppear ? appearClass : enterClass;
        var activeClass = isAppear ? appearActiveClass : enterActiveClass;
        var toClass = isAppear ? appearToClass : enterToClass;
        var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
        var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
        var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
        var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

        var expectsCSS = css !== false && !isIE9;
        var userWantsControl =
            enterHook &&
            // enterHook may be a bound method which exposes
            // the length of original fn as _length
            (enterHook._length || enterHook.length) > 1;

        var cb = el._enterCb = once(function () {
            if (expectsCSS) {
                removeTransitionClass(el, toClass);
                removeTransitionClass(el, activeClass);
            }
            if (cb.cancelled) {
                if (expectsCSS) {
                    removeTransitionClass(el, startClass);
                }
                enterCancelledHook && enterCancelledHook(el);
            } else {
                afterEnterHook && afterEnterHook(el);
            }
            el._enterCb = null;
        });

        if (!vnode.data.show) {
            // remove pending leave element on enter by injecting an insert hook
            mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
                var parent = el.parentNode;
                var pendingNode = parent && parent._pending && parent._pending[vnode.key];
                if (pendingNode &&
                    pendingNode.tag === vnode.tag &&
                    pendingNode.elm._leaveCb) {
                    pendingNode.elm._leaveCb();
                }
                enterHook && enterHook(el, cb);
            }, 'transition-insert');
        }

        // start enter transition
        beforeEnterHook && beforeEnterHook(el);
        if (expectsCSS) {
            addTransitionClass(el, startClass);
            addTransitionClass(el, activeClass);
            nextFrame(function () {
                addTransitionClass(el, toClass);
                removeTransitionClass(el, startClass);
                if (!cb.cancelled && !userWantsControl) {
                    whenTransitionEnds(el, type, cb);
                }
            });
        }

        if (vnode.data.show) {
            toggleDisplay && toggleDisplay();
            enterHook && enterHook(el, cb);
        }

        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }

    function leave(vnode, rm) {
        var el = vnode.elm;

        // call enter callback now
        if (el._enterCb) {
            el._enterCb.cancelled = true;
            el._enterCb();
        }

        var data = resolveTransition(vnode.data.transition);
        if (!data) {
            return rm()
        }

        /* istanbul ignore if */
        if (el._leaveCb || el.nodeType !== 1) {
            return
        }

        var css = data.css;
        var type = data.type;
        var leaveClass = data.leaveClass;
        var leaveToClass = data.leaveToClass;
        var leaveActiveClass = data.leaveActiveClass;
        var beforeLeave = data.beforeLeave;
        var leave = data.leave;
        var afterLeave = data.afterLeave;
        var leaveCancelled = data.leaveCancelled;
        var delayLeave = data.delayLeave;

        var expectsCSS = css !== false && !isIE9;
        var userWantsControl =
            leave &&
            // leave hook may be a bound method which exposes
            // the length of original fn as _length
            (leave._length || leave.length) > 1;

        var cb = el._leaveCb = once(function () {
            if (el.parentNode && el.parentNode._pending) {
                el.parentNode._pending[vnode.key] = null;
            }
            if (expectsCSS) {
                removeTransitionClass(el, leaveToClass);
                removeTransitionClass(el, leaveActiveClass);
            }
            if (cb.cancelled) {
                if (expectsCSS) {
                    removeTransitionClass(el, leaveClass);
                }
                leaveCancelled && leaveCancelled(el);
            } else {
                rm();
                afterLeave && afterLeave(el);
            }
            el._leaveCb = null;
        });

        if (delayLeave) {
            delayLeave(performLeave);
        } else {
            performLeave();
        }

        function performLeave() {
            // the delayed leave may have already been cancelled
            if (cb.cancelled) {
                return
            }
            // record leaving element
            if (!vnode.data.show) {
                (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
            }
            beforeLeave && beforeLeave(el);
            if (expectsCSS) {
                addTransitionClass(el, leaveClass);
                addTransitionClass(el, leaveActiveClass);
                nextFrame(function () {
                    addTransitionClass(el, leaveToClass);
                    removeTransitionClass(el, leaveClass);
                    if (!cb.cancelled && !userWantsControl) {
                        whenTransitionEnds(el, type, cb);
                    }
                });
            }
            leave && leave(el, cb);
            if (!expectsCSS && !userWantsControl) {
                cb();
            }
        }
    }

    function resolveTransition(def$$1) {
        if (!def$$1) {
            return
        }
        /* istanbul ignore else */
        if (typeof def$$1 === 'object') {
            var res = {};
            if (def$$1.css !== false) {
                extend(res, autoCssTransition(def$$1.name || 'v'));
            }
            extend(res, def$$1);
            return res
        } else if (typeof def$$1 === 'string') {
            return autoCssTransition(def$$1)
        }
    }

    var autoCssTransition = cached(function (name) {
        return {
            enterClass: (name + "-enter"),
            leaveClass: (name + "-leave"),
            appearClass: (name + "-enter"),
            enterToClass: (name + "-enter-to"),
            leaveToClass: (name + "-leave-to"),
            appearToClass: (name + "-enter-to"),
            enterActiveClass: (name + "-enter-active"),
            leaveActiveClass: (name + "-leave-active"),
            appearActiveClass: (name + "-enter-active")
        }
    });

    function once(fn) {
        var called = false;
        return function () {
            if (!called) {
                called = true;
                fn();
            }
        }
    }

    function _enter(_, vnode) {
        if (!vnode.data.show) {
            enter(vnode);
        }
    }

    var transition = inBrowser ? {
        create: _enter,
        activate: _enter,
        remove: function remove(vnode, rm) {
            /* istanbul ignore else */
            if (!vnode.data.show) {
                leave(vnode, rm);
            } else {
                rm();
            }
        }
    } : {};

    var platformModules = [
        attrs,
        klass,
        events,
        domProps,
        style,
        transition
    ];

    /*  */

    // the directive module should be applied last, after all
    // built-in modules have been applied.
    var modules = platformModules.concat(baseModules);

    var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

    /**
     * Not type checking this file because flow doesn't like attaching
     * properties to Elements.
     */

    var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

    /* istanbul ignore if */
    if (isIE9) {
        // http://www.matts411.com/post/internet-explorer-9-oninput/
        document.addEventListener('selectionchange', function () {
            var el = document.activeElement;
            if (el && el.vmodel) {
                trigger(el, 'input');
            }
        });
    }

    var model = {
        inserted: function inserted(el, binding, vnode) {
            {
                if (!modelableTagRE.test(vnode.tag)) {
                    warn(
                        "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
                        'If you are working with contenteditable, it\'s recommended to ' +
                        'wrap a library dedicated for that purpose inside a custom component.',
                        vnode.context
                    );
                }
            }
            if (vnode.tag === 'select') {
                var cb = function () {
                    setSelected(el, binding, vnode.context);
                };
                cb();
                /* istanbul ignore if */
                if (isIE || isEdge) {
                    setTimeout(cb, 0);
                }
            } else if (vnode.tag === 'textarea' || el.type === 'text') {
                el._vModifiers = binding.modifiers;
                if (!binding.modifiers.lazy) {
                    if (!isAndroid) {
                        el.addEventListener('compositionstart', onCompositionStart);
                        el.addEventListener('compositionend', onCompositionEnd);
                    }
                    /* istanbul ignore if */
                    if (isIE9) {
                        el.vmodel = true;
                    }
                }
            }
        },
        componentUpdated: function componentUpdated(el, binding, vnode) {
            if (vnode.tag === 'select') {
                setSelected(el, binding, vnode.context);
                // in case the options rendered by v-for have changed,
                // it's possible that the value is out-of-sync with the rendered options.
                // detect such cases and filter out values that no longer has a matching
                // option in the DOM.
                var needReset = el.multiple
                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
                    : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    };

    function setSelected(el, binding, vm) {
        var value = binding.value;
        var isMultiple = el.multiple;
        if (isMultiple && !Array.isArray(value)) {
            "development" !== 'production' && warn(
                "<select multiple v-model=\"" + (binding.expression) + "\"> " +
                "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
                vm
            );
            return
        }
        var selected, option;
        for (var i = 0, l = el.options.length; i < l; i++) {
            option = el.options[i];
            if (isMultiple) {
                selected = looseIndexOf(value, getValue(option)) > -1;
                if (option.selected !== selected) {
                    option.selected = selected;
                }
            } else {
                if (looseEqual(getValue(option), value)) {
                    if (el.selectedIndex !== i) {
                        el.selectedIndex = i;
                    }
                    return
                }
            }
        }
        if (!isMultiple) {
            el.selectedIndex = -1;
        }
    }

    function hasNoMatchingOption(value, options) {
        for (var i = 0, l = options.length; i < l; i++) {
            if (looseEqual(getValue(options[i]), value)) {
                return false
            }
        }
        return true
    }

    function getValue(option) {
        return '_value' in option
            ? option._value
            : option.value
    }

    function onCompositionStart(e) {
        e.target.composing = true;
    }

    function onCompositionEnd(e) {
        e.target.composing = false;
        trigger(e.target, 'input');
    }

    function trigger(el, type) {
        var e = document.createEvent('HTMLEvents');
        e.initEvent(type, true, true);
        el.dispatchEvent(e);
    }

    /*  */

    // recursively search for possible transition defined inside the component root
    function locateNode(vnode) {
        return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
            ? locateNode(vnode.componentInstance._vnode)
            : vnode
    }

    var show = {
        bind: function bind(el, ref, vnode) {
            var value = ref.value;

            vnode = locateNode(vnode);
            var transition = vnode.data && vnode.data.transition;
            var originalDisplay = el.__vOriginalDisplay =
                el.style.display === 'none' ? '' : el.style.display;
            if (value && transition && !isIE9) {
                vnode.data.show = true;
                enter(vnode, function () {
                    el.style.display = originalDisplay;
                });
            } else {
                el.style.display = value ? originalDisplay : 'none';
            }
        },

        update: function update(el, ref, vnode) {
            var value = ref.value;
            var oldValue = ref.oldValue;

            /* istanbul ignore if */
            if (value === oldValue) { return }
            vnode = locateNode(vnode);
            var transition = vnode.data && vnode.data.transition;
            if (transition && !isIE9) {
                vnode.data.show = true;
                if (value) {
                    enter(vnode, function () {
                        el.style.display = el.__vOriginalDisplay;
                    });
                } else {
                    leave(vnode, function () {
                        el.style.display = 'none';
                    });
                }
            } else {
                el.style.display = value ? el.__vOriginalDisplay : 'none';
            }
        },

        unbind: function unbind(
            el,
            binding,
            vnode,
            oldVnode,
            isDestroy
        ) {
            if (!isDestroy) {
                el.style.display = el.__vOriginalDisplay;
            }
        }
    };

    var platformDirectives = {
        model: model,
        show: show
    };

    /*  */

    // Provides transition support for a single element/component.
    // supports transition mode (out-in / in-out)

    var transitionProps = {
        name: String,
        appear: Boolean,
        css: Boolean,
        mode: String,
        type: String,
        enterClass: String,
        leaveClass: String,
        enterToClass: String,
        leaveToClass: String,
        enterActiveClass: String,
        leaveActiveClass: String,
        appearClass: String,
        appearActiveClass: String,
        appearToClass: String
    };

    // in case the child is also an abstract component, e.g. <keep-alive>
    // we want to recursively retrieve the real component to be rendered
    function getRealChild(vnode) {
        var compOptions = vnode && vnode.componentOptions;
        if (compOptions && compOptions.Ctor.options.abstract) {
            return getRealChild(getFirstComponentChild(compOptions.children))
        } else {
            return vnode
        }
    }

    function extractTransitionData(comp) {
        var data = {};
        var options = comp.$options;
        // props
        for (var key in options.propsData) {
            data[key] = comp[key];
        }
        // events.
        // extract listeners and pass them directly to the transition methods
        var listeners = options._parentListeners;
        for (var key$1 in listeners) {
            data[camelize(key$1)] = listeners[key$1].fn;
        }
        return data
    }

    function placeholder(h, rawChild) {
        return /\d-keep-alive$/.test(rawChild.tag)
            ? h('keep-alive')
            : null
    }

    function hasParentTransition(vnode) {
        while ((vnode = vnode.parent)) {
            if (vnode.data.transition) {
                return true
            }
        }
    }

    function isSameChild(child, oldChild) {
        return oldChild.key === child.key && oldChild.tag === child.tag
    }

    var Transition = {
        name: 'transition',
        props: transitionProps,
        abstract: true,

        render: function render(h) {
            var this$1 = this;

            var children = this.$slots.default;
            if (!children) {
                return
            }

            // filter out text nodes (possible whitespaces)
            children = children.filter(function (c) { return c.tag; });
            /* istanbul ignore if */
            if (!children.length) {
                return
            }

            // warn multiple elements
            if ("development" !== 'production' && children.length > 1) {
                warn(
                    '<transition> can only be used on a single element. Use ' +
                    '<transition-group> for lists.',
                    this.$parent
                );
            }

            var mode = this.mode;

            // warn invalid mode
            if ("development" !== 'production' &&
                mode && mode !== 'in-out' && mode !== 'out-in') {
                warn(
                    'invalid <transition> mode: ' + mode,
                    this.$parent
                );
            }

            var rawChild = children[0];

            // if this is a component root node and the component's
            // parent container node also has transition, skip.
            if (hasParentTransition(this.$vnode)) {
                return rawChild
            }

            // apply transition data to child
            // use getRealChild() to ignore abstract components e.g. keep-alive
            var child = getRealChild(rawChild);
            /* istanbul ignore if */
            if (!child) {
                return rawChild
            }

            if (this._leaving) {
                return placeholder(h, rawChild)
            }

            // ensure a key that is unique to the vnode type and to this transition
            // component instance. This key will be used to remove pending leaving nodes
            // during entering.
            var id = "__transition-" + (this._uid) + "-";
            var key = child.key = child.key == null
                ? id + child.tag
                : isPrimitive(child.key)
                    ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
                    : child.key;
            var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
            var oldRawChild = this._vnode;
            var oldChild = getRealChild(oldRawChild);

            // mark v-show
            // so that the transition module can hand over the control to the directive
            if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
                child.data.show = true;
            }

            if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
                // replace old child transition data with fresh one
                // important for dynamic transitions!
                var oldData = oldChild && (oldChild.data.transition = extend({}, data));
                // handle transition mode
                if (mode === 'out-in') {
                    // return placeholder node and queue update when leave finishes
                    this._leaving = true;
                    mergeVNodeHook(oldData, 'afterLeave', function () {
                        this$1._leaving = false;
                        this$1.$forceUpdate();
                    }, key);
                    return placeholder(h, rawChild)
                } else if (mode === 'in-out') {
                    var delayedLeave;
                    var performLeave = function () { delayedLeave(); };
                    mergeVNodeHook(data, 'afterEnter', performLeave, key);
                    mergeVNodeHook(data, 'enterCancelled', performLeave, key);
                    mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                        delayedLeave = leave;
                    }, key);
                }
            }

            return rawChild
        }
    };

    /*  */

    // Provides transition support for list items.
    // supports move transitions using the FLIP technique.

    // Because the vdom's children update algorithm is "unstable" - i.e.
    // it doesn't guarantee the relative positioning of removed elements,
    // we force transition-group to update its children into two passes:
    // in the first pass, we remove all nodes that need to be removed,
    // triggering their leaving transition; in the second pass, we insert/move
    // into the final disired state. This way in the second pass removed
    // nodes will remain where they should be.

    var props = extend({
        tag: String,
        moveClass: String
    }, transitionProps);

    delete props.mode;

    var TransitionGroup = {
        props: props,

        render: function render(h) {
            var tag = this.tag || this.$vnode.data.tag || 'span';
            var map = Object.create(null);
            var prevChildren = this.prevChildren = this.children;
            var rawChildren = this.$slots.default || [];
            var children = this.children = [];
            var transitionData = extractTransitionData(this);

            for (var i = 0; i < rawChildren.length; i++) {
                var c = rawChildren[i];
                if (c.tag) {
                    if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                        children.push(c);
                        map[c.key] = c
                            ; (c.data || (c.data = {})).transition = transitionData;
                    } else {
                        var opts = c.componentOptions;
                        var name = opts
                            ? (opts.Ctor.options.name || opts.tag)
                            : c.tag;
                        warn(("<transition-group> children must be keyed: <" + name + ">"));
                    }
                }
            }

            if (prevChildren) {
                var kept = [];
                var removed = [];
                for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                    var c$1 = prevChildren[i$1];
                    c$1.data.transition = transitionData;
                    c$1.data.pos = c$1.elm.getBoundingClientRect();
                    if (map[c$1.key]) {
                        kept.push(c$1);
                    } else {
                        removed.push(c$1);
                    }
                }
                this.kept = h(tag, null, kept);
                this.removed = removed;
            }

            return h(tag, null, children)
        },

        beforeUpdate: function beforeUpdate() {
            // force removing pass
            this.__patch__(
                this._vnode,
                this.kept,
                false, // hydrating
                true // removeOnly (!important, avoids unnecessary moves)
            );
            this._vnode = this.kept;
        },

        updated: function updated() {
            var children = this.prevChildren;
            var moveClass = this.moveClass || ((this.name || 'v') + '-move');
            if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
                return
            }

            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            children.forEach(callPendingCbs);
            children.forEach(recordPosition);
            children.forEach(applyTranslation);

            // force reflow to put everything in position
            var f = document.body.offsetHeight; // eslint-disable-line

            children.forEach(function (c) {
                if (c.data.moved) {
                    var el = c.elm;
                    var s = el.style;
                    addTransitionClass(el, moveClass);
                    s.transform = s.WebkitTransform = s.transitionDuration = '';
                    el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                        if (!e || /transform$/.test(e.propertyName)) {
                            el.removeEventListener(transitionEndEvent, cb);
                            el._moveCb = null;
                            removeTransitionClass(el, moveClass);
                        }
                    });
                }
            });
        },

        methods: {
            hasMove: function hasMove(el, moveClass) {
                /* istanbul ignore if */
                if (!hasTransition) {
                    return false
                }
                if (this._hasMove != null) {
                    return this._hasMove
                }
                addTransitionClass(el, moveClass);
                var info = getTransitionInfo(el);
                removeTransitionClass(el, moveClass);
                return (this._hasMove = info.hasTransform)
            }
        }
    };

    function callPendingCbs(c) {
        /* istanbul ignore if */
        if (c.elm._moveCb) {
            c.elm._moveCb();
        }
        /* istanbul ignore if */
        if (c.elm._enterCb) {
            c.elm._enterCb();
        }
    }

    function recordPosition(c) {
        c.data.newPos = c.elm.getBoundingClientRect();
    }

    function applyTranslation(c) {
        var oldPos = c.data.pos;
        var newPos = c.data.newPos;
        var dx = oldPos.left - newPos.left;
        var dy = oldPos.top - newPos.top;
        if (dx || dy) {
            c.data.moved = true;
            var s = c.elm.style;
            s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
            s.transitionDuration = '0s';
        }
    }

    var platformComponents = {
        Transition: Transition,
        TransitionGroup: TransitionGroup
    };

    /*  */

    // install platform specific utils
    Vue$3.config.isUnknownElement = isUnknownElement;
    Vue$3.config.isReservedTag = isReservedTag;
    Vue$3.config.getTagNamespace = getTagNamespace;
    Vue$3.config.mustUseProp = mustUseProp;

    // install platform runtime directives & components
    extend(Vue$3.options.directives, platformDirectives);
    extend(Vue$3.options.components, platformComponents);

    // install platform patch function
    Vue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;

    // wrap mount
    Vue$3.prototype.$mount = function (
        el,
        hydrating
    ) {
        el = el && inBrowser ? query(el) : undefined;
        return this._mount(el, hydrating)
    };

    if ("development" !== 'production' &&
        inBrowser && typeof console !== 'undefined') {
        console[console.info ? 'info' : 'log'](
            "You are running Vue in development mode.\n" +
            "Make sure to turn on production mode when deploying for production.\n" +
            "See more tips at https://vuejs.org/guide/deployment.html"
        );
    }

    // devtools global hook
    /* istanbul ignore next */
    setTimeout(function () {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue$3);
            } else if (
                "development" !== 'production' &&
                inBrowser && !isEdge && /Chrome\/\d+/.test(window.navigator.userAgent)
            ) {
                console[console.info ? 'info' : 'log'](
                    'Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools'
                );
            }
        }
    }, 0);

    /*  */

    // check whether current browser encodes a char inside attribute values
    function shouldDecode(content, encoded) {
        var div = document.createElement('div');
        div.innerHTML = "<div a=\"" + content + "\">";
        return div.innerHTML.indexOf(encoded) > 0
    }

    // #3663
    // IE encodes newlines inside attribute values while other browsers don't
    var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

    /*  */

    var decoder;

    function decode(html) {
        decoder = decoder || document.createElement('div');
        decoder.innerHTML = html;
        return decoder.textContent
    }

    /*  */

    var isUnaryTag = makeMap(
        'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
        'link,meta,param,source,track,wbr',
        true
    );

    // Elements that you can, intentionally, leave open
    // (and which close themselves)
    var canBeLeftOpenTag = makeMap(
        'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
        true
    );

    // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
    // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
    var isNonPhrasingTag = makeMap(
        'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
        'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
        'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
        'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
        'title,tr,track',
        true
    );

    /**
     * Not type-checking this file because it's mostly vendor code.
     */

    /*!
     * HTML Parser By John Resig (ejohn.org)
     * Modified by Juriy "kangax" Zaytsev
     * Original code by Erik Arvidsson, Mozilla Public License
     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
     */

    // Regular Expressions for parsing tags and attributes
    var singleAttrIdentifier = /([^\s"'<>/=]+)/;
    var singleAttrAssign = /(?:=)/;
    var singleAttrValues = [
        // attr value double quotes
        /"([^"]*)"+/.source,
        // attr value, single quotes
        /'([^']*)'+/.source,
        // attr value, no quotes
        /([^\s"'=<>`]+)/.source
    ];
    var attribute = new RegExp(
        '^\\s*' + singleAttrIdentifier.source +
        '(?:\\s*(' + singleAttrAssign.source + ')' +
        '\\s*(?:' + singleAttrValues.join('|') + '))?'
    );

    // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
    // but for Vue templates we can enforce a simple charset
    var ncname = '[a-zA-Z_][\\w\\-\\.]*';
    var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
    var startTagOpen = new RegExp('^<' + qnameCapture);
    var startTagClose = /^\s*(\/?)>/;
    var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
    var doctype = /^<!DOCTYPE [^>]+>/i;
    var comment = /^<!--/;
    var conditionalComment = /^<!\[/;

    var IS_REGEX_CAPTURING_BROKEN = false;
    'x'.replace(/x(.)?/g, function (m, g) {
        IS_REGEX_CAPTURING_BROKEN = g === '';
    });

    // Special Elements (can contain anything)
    var isScriptOrStyle = makeMap('script,style', true);
    var reCache = {};

    var ltRE = /&lt;/g;
    var gtRE = /&gt;/g;
    var nlRE = /&#10;/g;
    var ampRE = /&amp;/g;
    var quoteRE = /&quot;/g;

    function decodeAttr(value, shouldDecodeNewlines) {
        if (shouldDecodeNewlines) {
            value = value.replace(nlRE, '\n');
        }
        return value
            .replace(ltRE, '<')
            .replace(gtRE, '>')
            .replace(ampRE, '&')
            .replace(quoteRE, '"')
    }

    function parseHTML(html, options) {
        var stack = [];
        var expectHTML = options.expectHTML;
        var isUnaryTag$$1 = options.isUnaryTag || no;
        var index = 0;
        var last, lastTag;
        while (html) {
            last = html;
            // Make sure we're not in a script or style element
            if (!lastTag || !isScriptOrStyle(lastTag)) {
                var textEnd = html.indexOf('<');
                if (textEnd === 0) {
                    // Comment:
                    if (comment.test(html)) {
                        var commentEnd = html.indexOf('-->');

                        if (commentEnd >= 0) {
                            advance(commentEnd + 3);
                            continue
                        }
                    }

                    // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                    if (conditionalComment.test(html)) {
                        var conditionalEnd = html.indexOf(']>');

                        if (conditionalEnd >= 0) {
                            advance(conditionalEnd + 2);
                            continue
                        }
                    }

                    // Doctype:
                    var doctypeMatch = html.match(doctype);
                    if (doctypeMatch) {
                        advance(doctypeMatch[0].length);
                        continue
                    }

                    // End tag:
                    var endTagMatch = html.match(endTag);
                    if (endTagMatch) {
                        var curIndex = index;
                        advance(endTagMatch[0].length);
                        parseEndTag(endTagMatch[1], curIndex, index);
                        continue
                    }

                    // Start tag:
                    var startTagMatch = parseStartTag();
                    if (startTagMatch) {
                        handleStartTag(startTagMatch);
                        continue
                    }
                }

                var text = (void 0), rest$1 = (void 0), next = (void 0);
                if (textEnd > 0) {
                    rest$1 = html.slice(textEnd);
                    while (
                        !endTag.test(rest$1) &&
                        !startTagOpen.test(rest$1) &&
                        !comment.test(rest$1) &&
                        !conditionalComment.test(rest$1)
                    ) {
                        // < in plain text, be forgiving and treat it as text
                        next = rest$1.indexOf('<', 1);
                        if (next < 0) { break }
                        textEnd += next;
                        rest$1 = html.slice(textEnd);
                    }
                    text = html.substring(0, textEnd);
                    advance(textEnd);
                }

                if (textEnd < 0) {
                    text = html;
                    html = '';
                }

                if (options.chars && text) {
                    options.chars(text);
                }
            } else {
                var stackedTag = lastTag.toLowerCase();
                var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
                var endTagLength = 0;
                var rest = html.replace(reStackedTag, function (all, text, endTag) {
                    endTagLength = endTag.length;
                    if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
                        text = text
                            .replace(/<!--([\s\S]*?)-->/g, '$1')
                            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                    }
                    if (options.chars) {
                        options.chars(text);
                    }
                    return ''
                });
                index += html.length - rest.length;
                html = rest;
                parseEndTag(stackedTag, index - endTagLength, index);
            }

            if (html === last && options.chars) {
                options.chars(html);
                break
            }
        }

        // Clean up any remaining tags
        parseEndTag();

        function advance(n) {
            index += n;
            html = html.substring(n);
        }

        function parseStartTag() {
            var start = html.match(startTagOpen);
            if (start) {
                var match = {
                    tagName: start[1],
                    attrs: [],
                    start: index
                };
                advance(start[0].length);
                var end, attr;
                while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
                    advance(attr[0].length);
                    match.attrs.push(attr);
                }
                if (end) {
                    match.unarySlash = end[1];
                    advance(end[0].length);
                    match.end = index;
                    return match
                }
            }
        }

        function handleStartTag(match) {
            var tagName = match.tagName;
            var unarySlash = match.unarySlash;

            if (expectHTML) {
                if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                    parseEndTag(lastTag);
                }
                if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
                    parseEndTag(tagName);
                }
            }

            var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

            var l = match.attrs.length;
            var attrs = new Array(l);
            for (var i = 0; i < l; i++) {
                var args = match.attrs[i];
                // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
                if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
                    if (args[3] === '') { delete args[3]; }
                    if (args[4] === '') { delete args[4]; }
                    if (args[5] === '') { delete args[5]; }
                }
                var value = args[3] || args[4] || args[5] || '';
                attrs[i] = {
                    name: args[1],
                    value: decodeAttr(
                        value,
                        options.shouldDecodeNewlines
                    )
                };
            }

            if (!unary) {
                stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
                lastTag = tagName;
                unarySlash = '';
            }

            if (options.start) {
                options.start(tagName, attrs, unary, match.start, match.end);
            }
        }

        function parseEndTag(tagName, start, end) {
            var pos, lowerCasedTagName;
            if (start == null) { start = index; }
            if (end == null) { end = index; }

            if (tagName) {
                lowerCasedTagName = tagName.toLowerCase();
            }

            // Find the closest opened tag of the same type
            if (tagName) {
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                        break
                    }
                }
            } else {
                // If no tag name is provided, clean shop
                pos = 0;
            }

            if (pos >= 0) {
                // Close all the open elements, up the stack
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (options.end) {
                        options.end(stack[i].tag, start, end);
                    }
                }

                // Remove the open elements from the stack
                stack.length = pos;
                lastTag = pos && stack[pos - 1].tag;
            } else if (lowerCasedTagName === 'br') {
                if (options.start) {
                    options.start(tagName, [], true, start, end);
                }
            } else if (lowerCasedTagName === 'p') {
                if (options.start) {
                    options.start(tagName, [], false, start, end);
                }
                if (options.end) {
                    options.end(tagName, start, end);
                }
            }
        }
    }

    /*  */

    function parseFilters(exp) {
        var inSingle = false;
        var inDouble = false;
        var inTemplateString = false;
        var inRegex = false;
        var curly = 0;
        var square = 0;
        var paren = 0;
        var lastFilterIndex = 0;
        var c, prev, i, expression, filters;

        for (i = 0; i < exp.length; i++) {
            prev = c;
            c = exp.charCodeAt(i);
            if (inSingle) {
                if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
            } else if (inDouble) {
                if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
            } else if (inTemplateString) {
                if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
            } else if (inRegex) {
                if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
            } else if (
                c === 0x7C && // pipe
                exp.charCodeAt(i + 1) !== 0x7C &&
                exp.charCodeAt(i - 1) !== 0x7C &&
                !curly && !square && !paren
            ) {
                if (expression === undefined) {
                    // first filter, end of expression
                    lastFilterIndex = i + 1;
                    expression = exp.slice(0, i).trim();
                } else {
                    pushFilter();
                }
            } else {
                switch (c) {
                    case 0x22: inDouble = true; break         // "
                    case 0x27: inSingle = true; break         // '
                    case 0x60: inTemplateString = true; break // `
                    case 0x28: paren++; break                 // (
                    case 0x29: paren--; break                 // )
                    case 0x5B: square++; break                // [
                    case 0x5D: square--; break                // ]
                    case 0x7B: curly++; break                 // {
                    case 0x7D: curly--; break                 // }
                }
                if (c === 0x2f) { // /
                    var j = i - 1;
                    var p = (void 0);
                    // find first non-whitespace prev char
                    for (; j >= 0; j--) {
                        p = exp.charAt(j);
                        if (p !== ' ') { break }
                    }
                    if (!p || !/[\w$]/.test(p)) {
                        inRegex = true;
                    }
                }
            }
        }

        if (expression === undefined) {
            expression = exp.slice(0, i).trim();
        } else if (lastFilterIndex !== 0) {
            pushFilter();
        }

        function pushFilter() {
            (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
            lastFilterIndex = i + 1;
        }

        if (filters) {
            for (i = 0; i < filters.length; i++) {
                expression = wrapFilter(expression, filters[i]);
            }
        }

        return expression
    }

    function wrapFilter(exp, filter) {
        var i = filter.indexOf('(');
        if (i < 0) {
            // _f: resolveFilter
            return ("_f(\"" + filter + "\")(" + exp + ")")
        } else {
            var name = filter.slice(0, i);
            var args = filter.slice(i + 1);
            return ("_f(\"" + name + "\")(" + exp + "," + args)
        }
    }

    /*  */

    var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
    var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

    var buildRegex = cached(function (delimiters) {
        var open = delimiters[0].replace(regexEscapeRE, '\\$&');
        var close = delimiters[1].replace(regexEscapeRE, '\\$&');
        return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
    });

    function parseText(
        text,
        delimiters
    ) {
        var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
        if (!tagRE.test(text)) {
            return
        }
        var tokens = [];
        var lastIndex = tagRE.lastIndex = 0;
        var match, index;
        while ((match = tagRE.exec(text))) {
            index = match.index;
            // push text token
            if (index > lastIndex) {
                tokens.push(JSON.stringify(text.slice(lastIndex, index)));
            }
            // tag token
            var exp = parseFilters(match[1].trim());
            tokens.push(("_s(" + exp + ")"));
            lastIndex = index + match[0].length;
        }
        if (lastIndex < text.length) {
            tokens.push(JSON.stringify(text.slice(lastIndex)));
        }
        return tokens.join('+')
    }

    /*  */

    function baseWarn(msg) {
        console.error(("[Vue parser]: " + msg));
    }

    function pluckModuleFunction(
        modules,
        key
    ) {
        return modules
            ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
            : []
    }

    function addProp(el, name, value) {
        (el.props || (el.props = [])).push({ name: name, value: value });
    }

    function addAttr(el, name, value) {
        (el.attrs || (el.attrs = [])).push({ name: name, value: value });
    }

    function addDirective(
        el,
        name,
        rawName,
        value,
        arg,
        modifiers
    ) {
        (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
    }

    function addHandler(
        el,
        name,
        value,
        modifiers,
        important
    ) {
        // check capture modifier
        if (modifiers && modifiers.capture) {
            delete modifiers.capture;
            name = '!' + name; // mark the event as captured
        }
        if (modifiers && modifiers.once) {
            delete modifiers.once;
            name = '~' + name; // mark the event as once
        }
        var events;
        if (modifiers && modifiers.native) {
            delete modifiers.native;
            events = el.nativeEvents || (el.nativeEvents = {});
        } else {
            events = el.events || (el.events = {});
        }
        var newHandler = { value: value, modifiers: modifiers };
        var handlers = events[name];
        /* istanbul ignore if */
        if (Array.isArray(handlers)) {
            important ? handlers.unshift(newHandler) : handlers.push(newHandler);
        } else if (handlers) {
            events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
        } else {
            events[name] = newHandler;
        }
    }

    function getBindingAttr(
        el,
        name,
        getStatic
    ) {
        var dynamicValue =
            getAndRemoveAttr(el, ':' + name) ||
            getAndRemoveAttr(el, 'v-bind:' + name);
        if (dynamicValue != null) {
            return parseFilters(dynamicValue)
        } else if (getStatic !== false) {
            var staticValue = getAndRemoveAttr(el, name);
            if (staticValue != null) {
                return JSON.stringify(staticValue)
            }
        }
    }

    function getAndRemoveAttr(el, name) {
        var val;
        if ((val = el.attrsMap[name]) != null) {
            var list = el.attrsList;
            for (var i = 0, l = list.length; i < l; i++) {
                if (list[i].name === name) {
                    list.splice(i, 1);
                    break
                }
            }
        }
        return val
    }

    var len;
    var str;
    var chr;
    var index$1;
    var expressionPos;
    var expressionEndPos;

    /**
     * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
     *
     * for loop possible cases:
     *
     * - test
     * - test[idx]
     * - test[test1[idx]]
     * - test["a"][idx]
     * - xxx.test[a[a].test1[idx]]
     * - test.xxx.a["asa"][test1[idx]]
     *
     */

    function parseModel(val) {
        str = val;
        len = str.length;
        index$1 = expressionPos = expressionEndPos = 0;

        if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
            return {
                exp: val,
                idx: null
            }
        }

        while (!eof()) {
            chr = next();
            /* istanbul ignore if */
            if (isStringStart(chr)) {
                parseString(chr);
            } else if (chr === 0x5B) {
                parseBracket(chr);
            }
        }

        return {
            exp: val.substring(0, expressionPos),
            idx: val.substring(expressionPos + 1, expressionEndPos)
        }
    }

    function next() {
        return str.charCodeAt(++index$1)
    }

    function eof() {
        return index$1 >= len
    }

    function isStringStart(chr) {
        return chr === 0x22 || chr === 0x27
    }

    function parseBracket(chr) {
        var inBracket = 1;
        expressionPos = index$1;
        while (!eof()) {
            chr = next();
            if (isStringStart(chr)) {
                parseString(chr);
                continue
            }
            if (chr === 0x5B) { inBracket++; }
            if (chr === 0x5D) { inBracket--; }
            if (inBracket === 0) {
                expressionEndPos = index$1;
                break
            }
        }
    }

    function parseString(chr) {
        var stringQuote = chr;
        while (!eof()) {
            chr = next();
            if (chr === stringQuote) {
                break
            }
        }
    }

    /*  */

    var dirRE = /^v-|^@|^:/;
    var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
    var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
    var bindRE = /^:|^v-bind:/;
    var onRE = /^@|^v-on:/;
    var argRE = /:(.*)$/;
    var modifierRE = /\.[^.]+/g;

    var decodeHTMLCached = cached(decode);

    // configurable state
    var warn$1;
    var platformGetTagNamespace;
    var platformMustUseProp;
    var platformIsPreTag;
    var preTransforms;
    var transforms;
    var postTransforms;
    var delimiters;

    /**
     * Convert HTML string to AST.
     */
    function parse(
        template,
        options
    ) {
        warn$1 = options.warn || baseWarn;
        platformGetTagNamespace = options.getTagNamespace || no;
        platformMustUseProp = options.mustUseProp || no;
        platformIsPreTag = options.isPreTag || no;
        preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
        transforms = pluckModuleFunction(options.modules, 'transformNode');
        postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
        delimiters = options.delimiters;
        var stack = [];
        var preserveWhitespace = options.preserveWhitespace !== false;
        var root;
        var currentParent;
        var inVPre = false;
        var inPre = false;
        var warned = false;
        parseHTML(template, {
            expectHTML: options.expectHTML,
            isUnaryTag: options.isUnaryTag,
            shouldDecodeNewlines: options.shouldDecodeNewlines,
            start: function start(tag, attrs, unary) {
                // check namespace.
                // inherit parent ns if there is one
                var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

                // handle IE svg bug
                /* istanbul ignore if */
                if (isIE && ns === 'svg') {
                    attrs = guardIESVGBug(attrs);
                }

                var element = {
                    type: 1,
                    tag: tag,
                    attrsList: attrs,
                    attrsMap: makeAttrsMap(attrs),
                    parent: currentParent,
                    children: []
                };
                if (ns) {
                    element.ns = ns;
                }

                if (isForbiddenTag(element) && !isServerRendering()) {
                    element.forbidden = true;
                    "development" !== 'production' && warn$1(
                        'Templates should only be responsible for mapping the state to the ' +
                        'UI. Avoid placing tags with side-effects in your templates, such as ' +
                        "<" + tag + ">" + ', as they will not be parsed.'
                    );
                }

                // apply pre-transforms
                for (var i = 0; i < preTransforms.length; i++) {
                    preTransforms[i](element, options);
                }

                if (!inVPre) {
                    processPre(element);
                    if (element.pre) {
                        inVPre = true;
                    }
                }
                if (platformIsPreTag(element.tag)) {
                    inPre = true;
                }
                if (inVPre) {
                    processRawAttrs(element);
                } else {
                    processFor(element);
                    processIf(element);
                    processOnce(element);
                    processKey(element);

                    // determine whether this is a plain element after
                    // removing structural attributes
                    element.plain = !element.key && !attrs.length;

                    processRef(element);
                    processSlot(element);
                    processComponent(element);
                    for (var i$1 = 0; i$1 < transforms.length; i$1++) {
                        transforms[i$1](element, options);
                    }
                    processAttrs(element);
                }

                function checkRootConstraints(el) {
                    if ("development" !== 'production' && !warned) {
                        if (el.tag === 'slot' || el.tag === 'template') {
                            warned = true;
                            warn$1(
                                "Cannot use <" + (el.tag) + "> as component root element because it may " +
                                'contain multiple nodes:\n' + template
                            );
                        }
                        if (el.attrsMap.hasOwnProperty('v-for')) {
                            warned = true;
                            warn$1(
                                'Cannot use v-for on stateful component root element because ' +
                                'it renders multiple elements:\n' + template
                            );
                        }
                    }
                }

                // tree management
                if (!root) {
                    root = element;
                    checkRootConstraints(root);
                } else if (!stack.length) {
                    // allow root elements with v-if, v-else-if and v-else
                    if (root.if && (element.elseif || element.else)) {
                        checkRootConstraints(element);
                        addIfCondition(root, {
                            exp: element.elseif,
                            block: element
                        });
                    } else if ("development" !== 'production' && !warned) {
                        warned = true;
                        warn$1(
                            "Component template should contain exactly one root element:" +
                            "\n\n" + template + "\n\n" +
                            "If you are using v-if on multiple elements, " +
                            "use v-else-if to chain them instead."
                        );
                    }
                }
                if (currentParent && !element.forbidden) {
                    if (element.elseif || element.else) {
                        processIfConditions(element, currentParent);
                    } else if (element.slotScope) { // scoped slot
                        currentParent.plain = false;
                        var name = element.slotTarget || 'default'; (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                    } else {
                        currentParent.children.push(element);
                        element.parent = currentParent;
                    }
                }
                if (!unary) {
                    currentParent = element;
                    stack.push(element);
                }
                // apply post-transforms
                for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
                    postTransforms[i$2](element, options);
                }
            },

            end: function end() {
                // remove trailing whitespace
                var element = stack[stack.length - 1];
                var lastNode = element.children[element.children.length - 1];
                if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
                    element.children.pop();
                }
                // pop stack
                stack.length -= 1;
                currentParent = stack[stack.length - 1];
                // check pre state
                if (element.pre) {
                    inVPre = false;
                }
                if (platformIsPreTag(element.tag)) {
                    inPre = false;
                }
            },

            chars: function chars(text) {
                if (!currentParent) {
                    if ("development" !== 'production' && !warned && text === template) {
                        warned = true;
                        warn$1(
                            'Component template requires a root element, rather than just text:\n\n' + template
                        );
                    }
                    return
                }
                // IE textarea placeholder bug
                /* istanbul ignore if */
                if (isIE &&
                    currentParent.tag === 'textarea' &&
                    currentParent.attrsMap.placeholder === text) {
                    return
                }
                var children = currentParent.children;
                text = inPre || text.trim()
                    ? decodeHTMLCached(text)
                    // only preserve whitespace if its not right after a starting tag
                    : preserveWhitespace && children.length ? ' ' : '';
                if (text) {
                    var expression;
                    if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
                        children.push({
                            type: 2,
                            expression: expression,
                            text: text
                        });
                    } else if (text !== ' ' || children[children.length - 1].text !== ' ') {
                        currentParent.children.push({
                            type: 3,
                            text: text
                        });
                    }
                }
            }
        });
        return root
    }

    function processPre(el) {
        if (getAndRemoveAttr(el, 'v-pre') != null) {
            el.pre = true;
        }
    }

    function processRawAttrs(el) {
        var l = el.attrsList.length;
        if (l) {
            var attrs = el.attrs = new Array(l);
            for (var i = 0; i < l; i++) {
                attrs[i] = {
                    name: el.attrsList[i].name,
                    value: JSON.stringify(el.attrsList[i].value)
                };
            }
        } else if (!el.pre) {
            // non root node in pre blocks with no attributes
            el.plain = true;
        }
    }

    function processKey(el) {
        var exp = getBindingAttr(el, 'key');
        if (exp) {
            if ("development" !== 'production' && el.tag === 'template') {
                warn$1("<template> cannot be keyed. Place the key on real elements instead.");
            }
            el.key = exp;
        }
    }

    function processRef(el) {
        var ref = getBindingAttr(el, 'ref');
        if (ref) {
            el.ref = ref;
            el.refInFor = checkInFor(el);
        }
    }

    function processFor(el) {
        var exp;
        if ((exp = getAndRemoveAttr(el, 'v-for'))) {
            var inMatch = exp.match(forAliasRE);
            if (!inMatch) {
                "development" !== 'production' && warn$1(
                    ("Invalid v-for expression: " + exp)
                );
                return
            }
            el.for = inMatch[2].trim();
            var alias = inMatch[1].trim();
            var iteratorMatch = alias.match(forIteratorRE);
            if (iteratorMatch) {
                el.alias = iteratorMatch[1].trim();
                el.iterator1 = iteratorMatch[2].trim();
                if (iteratorMatch[3]) {
                    el.iterator2 = iteratorMatch[3].trim();
                }
            } else {
                el.alias = alias;
            }
        }
    }

    function processIf(el) {
        var exp = getAndRemoveAttr(el, 'v-if');
        if (exp) {
            el.if = exp;
            addIfCondition(el, {
                exp: exp,
                block: el
            });
        } else {
            if (getAndRemoveAttr(el, 'v-else') != null) {
                el.else = true;
            }
            var elseif = getAndRemoveAttr(el, 'v-else-if');
            if (elseif) {
                el.elseif = elseif;
            }
        }
    }

    function processIfConditions(el, parent) {
        var prev = findPrevElement(parent.children);
        if (prev && prev.if) {
            addIfCondition(prev, {
                exp: el.elseif,
                block: el
            });
        } else {
            warn$1(
                "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
                "used on element <" + (el.tag) + "> without corresponding v-if."
            );
        }
    }

    function findPrevElement(children) {
        var i = children.length;
        while (i--) {
            if (children[i].type === 1) {
                return children[i]
            } else {
                if ("development" !== 'production' && children[i].text !== ' ') {
                    warn$1(
                        "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
                        "will be ignored."
                    );
                }
                children.pop();
            }
        }
    }

    function addIfCondition(el, condition) {
        if (!el.ifConditions) {
            el.ifConditions = [];
        }
        el.ifConditions.push(condition);
    }

    function processOnce(el) {
        var once = getAndRemoveAttr(el, 'v-once');
        if (once != null) {
            el.once = true;
        }
    }

    function processSlot(el) {
        if (el.tag === 'slot') {
            el.slotName = getBindingAttr(el, 'name');
            if ("development" !== 'production' && el.key) {
                warn$1(
                    "`key` does not work on <slot> because slots are abstract outlets " +
                    "and can possibly expand into multiple elements. " +
                    "Use the key on a wrapping element instead."
                );
            }
        } else {
            var slotTarget = getBindingAttr(el, 'slot');
            if (slotTarget) {
                el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
            }
            if (el.tag === 'template') {
                el.slotScope = getAndRemoveAttr(el, 'scope');
            }
        }
    }

    function processComponent(el) {
        var binding;
        if ((binding = getBindingAttr(el, 'is'))) {
            el.component = binding;
        }
        if (getAndRemoveAttr(el, 'inline-template') != null) {
            el.inlineTemplate = true;
        }
    }

    function processAttrs(el) {
        var list = el.attrsList;
        var i, l, name, rawName, value, arg, modifiers, isProp;
        for (i = 0, l = list.length; i < l; i++) {
            name = rawName = list[i].name;
            value = list[i].value;
            if (dirRE.test(name)) {
                // mark element as dynamic
                el.hasBindings = true;
                // modifiers
                modifiers = parseModifiers(name);
                if (modifiers) {
                    name = name.replace(modifierRE, '');
                }
                if (bindRE.test(name)) { // v-bind
                    name = name.replace(bindRE, '');
                    value = parseFilters(value);
                    isProp = false;
                    if (modifiers) {
                        if (modifiers.prop) {
                            isProp = true;
                            name = camelize(name);
                            if (name === 'innerHtml') { name = 'innerHTML'; }
                        }
                        if (modifiers.camel) {
                            name = camelize(name);
                        }
                    }
                    if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                        addProp(el, name, value);
                    } else {
                        addAttr(el, name, value);
                    }
                } else if (onRE.test(name)) { // v-on
                    name = name.replace(onRE, '');
                    addHandler(el, name, value, modifiers);
                } else { // normal directives
                    name = name.replace(dirRE, '');
                    // parse arg
                    var argMatch = name.match(argRE);
                    if (argMatch && (arg = argMatch[1])) {
                        name = name.slice(0, -(arg.length + 1));
                    }
                    addDirective(el, name, rawName, value, arg, modifiers);
                    if ("development" !== 'production' && name === 'model') {
                        checkForAliasModel(el, value);
                    }
                }
            } else {
                // literal attribute
                {
                    var expression = parseText(value, delimiters);
                    if (expression) {
                        warn$1(
                            name + "=\"" + value + "\": " +
                            'Interpolation inside attributes has been removed. ' +
                            'Use v-bind or the colon shorthand instead. For example, ' +
                            'instead of <div id="{{ val }}">, use <div :id="val">.'
                        );
                    }
                }
                addAttr(el, name, JSON.stringify(value));
            }
        }
    }

    function checkInFor(el) {
        var parent = el;
        while (parent) {
            if (parent.for !== undefined) {
                return true
            }
            parent = parent.parent;
        }
        return false
    }

    function parseModifiers(name) {
        var match = name.match(modifierRE);
        if (match) {
            var ret = {};
            match.forEach(function (m) { ret[m.slice(1)] = true; });
            return ret
        }
    }

    function makeAttrsMap(attrs) {
        var map = {};
        for (var i = 0, l = attrs.length; i < l; i++) {
            if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
                warn$1('duplicate attribute: ' + attrs[i].name);
            }
            map[attrs[i].name] = attrs[i].value;
        }
        return map
    }

    function isForbiddenTag(el) {
        return (
            el.tag === 'style' ||
            (el.tag === 'script' && (
                !el.attrsMap.type ||
                el.attrsMap.type === 'text/javascript'
            ))
        )
    }

    var ieNSBug = /^xmlns:NS\d+/;
    var ieNSPrefix = /^NS\d+:/;

    /* istanbul ignore next */
    function guardIESVGBug(attrs) {
        var res = [];
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            if (!ieNSBug.test(attr.name)) {
                attr.name = attr.name.replace(ieNSPrefix, '');
                res.push(attr);
            }
        }
        return res
    }

    function checkForAliasModel(el, value) {
        var _el = el;
        while (_el) {
            if (_el.for && _el.alias === value) {
                warn$1(
                    "<" + (el.tag) + " v-model=\"" + value + "\">: " +
                    "You are binding v-model directly to a v-for iteration alias. " +
                    "This will not be able to modify the v-for source array because " +
                    "writing to the alias is like modifying a function local variable. " +
                    "Consider using an array of objects and use v-model on an object property instead."
                );
            }
            _el = _el.parent;
        }
    }

    /*  */

    var isStaticKey;
    var isPlatformReservedTag;

    var genStaticKeysCached = cached(genStaticKeys$1);

    /**
     * Goal of the optimizer: walk the generated template AST tree
     * and detect sub-trees that are purely static, i.e. parts of
     * the DOM that never needs to change.
     *
     * Once we detect these sub-trees, we can:
     *
     * 1. Hoist them into constants, so that we no longer need to
     *    create fresh nodes for them on each re-render;
     * 2. Completely skip them in the patching process.
     */
    function optimize(root, options) {
        if (!root) { return }
        isStaticKey = genStaticKeysCached(options.staticKeys || '');
        isPlatformReservedTag = options.isReservedTag || no;
        // first pass: mark all non-static nodes.
        markStatic(root);
        // second pass: mark static roots.
        markStaticRoots(root, false);
    }

    function genStaticKeys$1(keys) {
        return makeMap(
            'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
            (keys ? ',' + keys : '')
        )
    }

    function markStatic(node) {
        node.static = isStatic(node);
        if (node.type === 1) {
            // do not make component slot content static. this avoids
            // 1. components not able to mutate slot nodes
            // 2. static slot content fails for hot-reloading
            if (
                !isPlatformReservedTag(node.tag) &&
                node.tag !== 'slot' &&
                node.attrsMap['inline-template'] == null
            ) {
                return
            }
            for (var i = 0, l = node.children.length; i < l; i++) {
                var child = node.children[i];
                markStatic(child);
                if (!child.static) {
                    node.static = false;
                }
            }
        }
    }

    function markStaticRoots(node, isInFor) {
        if (node.type === 1) {
            if (node.static || node.once) {
                node.staticInFor = isInFor;
            }
            // For a node to qualify as a static root, it should have children that
            // are not just static text. Otherwise the cost of hoisting out will
            // outweigh the benefits and it's better off to just always render it fresh.
            if (node.static && node.children.length && !(
                node.children.length === 1 &&
                node.children[0].type === 3
            )) {
                node.staticRoot = true;
                return
            } else {
                node.staticRoot = false;
            }
            if (node.children) {
                for (var i = 0, l = node.children.length; i < l; i++) {
                    markStaticRoots(node.children[i], isInFor || !!node.for);
                }
            }
            if (node.ifConditions) {
                walkThroughConditionsBlocks(node.ifConditions, isInFor);
            }
        }
    }

    function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
        for (var i = 1, len = conditionBlocks.length; i < len; i++) {
            markStaticRoots(conditionBlocks[i].block, isInFor);
        }
    }

    function isStatic(node) {
        if (node.type === 2) { // expression
            return false
        }
        if (node.type === 3) { // text
            return true
        }
        return !!(node.pre || (
            !node.hasBindings && // no dynamic bindings
            !node.if && !node.for && // not v-if or v-for or v-else
            !isBuiltInTag(node.tag) && // not a built-in
            isPlatformReservedTag(node.tag) && // not a component
            !isDirectChildOfTemplateFor(node) &&
            Object.keys(node).every(isStaticKey)
        ))
    }

    function isDirectChildOfTemplateFor(node) {
        while (node.parent) {
            node = node.parent;
            if (node.tag !== 'template') {
                return false
            }
            if (node.for) {
                return true
            }
        }
        return false
    }

    /*  */

    var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
    var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

    // keyCode aliases
    var keyCodes = {
        esc: 27,
        tab: 9,
        enter: 13,
        space: 32,
        up: 38,
        left: 37,
        right: 39,
        down: 40,
        'delete': [8, 46]
    };

    var modifierCode = {
        stop: '$event.stopPropagation();',
        prevent: '$event.preventDefault();',
        self: 'if($event.target !== $event.currentTarget)return;',
        ctrl: 'if(!$event.ctrlKey)return;',
        shift: 'if(!$event.shiftKey)return;',
        alt: 'if(!$event.altKey)return;',
        meta: 'if(!$event.metaKey)return;'
    };

    function genHandlers(events, native) {
        var res = native ? 'nativeOn:{' : 'on:{';
        for (var name in events) {
            res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
        }
        return res.slice(0, -1) + '}'
    }

    function genHandler(
        name,
        handler
    ) {
        if (!handler) {
            return 'function(){}'
        } else if (Array.isArray(handler)) {
            return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
        } else if (!handler.modifiers) {
            return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)
                ? handler.value
                : ("function($event){" + (handler.value) + "}")
        } else {
            var code = '';
            var keys = [];
            for (var key in handler.modifiers) {
                if (modifierCode[key]) {
                    code += modifierCode[key];
                } else {
                    keys.push(key);
                }
            }
            if (keys.length) {
                code = genKeyFilter(keys) + code;
            }
            var handlerCode = simplePathRE.test(handler.value)
                ? handler.value + '($event)'
                : handler.value;
            return 'function($event){' + code + handlerCode + '}'
        }
    }

    function genKeyFilter(keys) {
        return ("if(" + (keys.map(genFilterCode).join('&&')) + ")return;")
    }

    function genFilterCode(key) {
        var keyVal = parseInt(key, 10);
        if (keyVal) {
            return ("$event.keyCode!==" + keyVal)
        }
        var alias = keyCodes[key];
        return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
    }

    /*  */

    function bind$2(el, dir) {
        el.wrapData = function (code) {
            return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
        };
    }

    /*  */

    var baseDirectives = {
        bind: bind$2,
        cloak: noop
    };

    /*  */

    // configurable state
    var warn$2;
    var transforms$1;
    var dataGenFns;
    var platformDirectives$1;
    var isPlatformReservedTag$1;
    var staticRenderFns;
    var onceCount;
    var currentOptions;

    function generate(
        ast,
        options
    ) {
        // save previous staticRenderFns so generate calls can be nested
        var prevStaticRenderFns = staticRenderFns;
        var currentStaticRenderFns = staticRenderFns = [];
        var prevOnceCount = onceCount;
        onceCount = 0;
        currentOptions = options;
        warn$2 = options.warn || baseWarn;
        transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
        dataGenFns = pluckModuleFunction(options.modules, 'genData');
        platformDirectives$1 = options.directives || {};
        isPlatformReservedTag$1 = options.isReservedTag || no;
        var code = ast ? genElement(ast) : '_c("div")';
        staticRenderFns = prevStaticRenderFns;
        onceCount = prevOnceCount;
        return {
            render: ("with(this){return " + code + "}"),
            staticRenderFns: currentStaticRenderFns
        }
    }

    function genElement(el) {
        if (el.staticRoot && !el.staticProcessed) {
            return genStatic(el)
        } else if (el.once && !el.onceProcessed) {
            return genOnce(el)
        } else if (el.for && !el.forProcessed) {
            return genFor(el)
        } else if (el.if && !el.ifProcessed) {
            return genIf(el)
        } else if (el.tag === 'template' && !el.slotTarget) {
            return genChildren(el) || 'void 0'
        } else if (el.tag === 'slot') {
            return genSlot(el)
        } else {
            // component or element
            var code;
            if (el.component) {
                code = genComponent(el.component, el);
            } else {
                var data = el.plain ? undefined : genData(el);

                var children = el.inlineTemplate ? null : genChildren(el, true);
                code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
            }
            // module transforms
            for (var i = 0; i < transforms$1.length; i++) {
                code = transforms$1[i](el, code);
            }
            return code
        }
    }

    // hoist static sub-trees out
    function genStatic(el) {
        el.staticProcessed = true;
        staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
        return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
    }

    // v-once
    function genOnce(el) {
        el.onceProcessed = true;
        if (el.if && !el.ifProcessed) {
            return genIf(el)
        } else if (el.staticInFor) {
            var key = '';
            var parent = el.parent;
            while (parent) {
                if (parent.for) {
                    key = parent.key;
                    break
                }
                parent = parent.parent;
            }
            if (!key) {
                "development" !== 'production' && warn$2(
                    "v-once can only be used inside v-for that is keyed. "
                );
                return genElement(el)
            }
            return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
        } else {
            return genStatic(el)
        }
    }

    function genIf(el) {
        el.ifProcessed = true; // avoid recursion
        return genIfConditions(el.ifConditions.slice())
    }

    function genIfConditions(conditions) {
        if (!conditions.length) {
            return '_e()'
        }

        var condition = conditions.shift();
        if (condition.exp) {
            return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions)))
        } else {
            return ("" + (genTernaryExp(condition.block)))
        }

        // v-if with v-once should generate code like (a)?_m(0):_m(1)
        function genTernaryExp(el) {
            return el.once ? genOnce(el) : genElement(el)
        }
    }

    function genFor(el) {
        var exp = el.for;
        var alias = el.alias;
        var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
        var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
        el.forProcessed = true; // avoid recursion
        return "_l((" + exp + ")," +
            "function(" + alias + iterator1 + iterator2 + "){" +
            "return " + (genElement(el)) +
            '})'
    }

    function genData(el) {
        var data = '{';

        // directives first.
        // directives may mutate the el's other properties before they are generated.
        var dirs = genDirectives(el);
        if (dirs) { data += dirs + ','; }

        // key
        if (el.key) {
            data += "key:" + (el.key) + ",";
        }
        // ref
        if (el.ref) {
            data += "ref:" + (el.ref) + ",";
        }
        if (el.refInFor) {
            data += "refInFor:true,";
        }
        // pre
        if (el.pre) {
            data += "pre:true,";
        }
        // record original tag name for components using "is" attribute
        if (el.component) {
            data += "tag:\"" + (el.tag) + "\",";
        }
        // module data generation functions
        for (var i = 0; i < dataGenFns.length; i++) {
            data += dataGenFns[i](el);
        }
        // attributes
        if (el.attrs) {
            data += "attrs:{" + (genProps(el.attrs)) + "},";
        }
        // DOM props
        if (el.props) {
            data += "domProps:{" + (genProps(el.props)) + "},";
        }
        // event handlers
        if (el.events) {
            data += (genHandlers(el.events)) + ",";
        }
        if (el.nativeEvents) {
            data += (genHandlers(el.nativeEvents, true)) + ",";
        }
        // slot target
        if (el.slotTarget) {
            data += "slot:" + (el.slotTarget) + ",";
        }
        // scoped slots
        if (el.scopedSlots) {
            data += (genScopedSlots(el.scopedSlots)) + ",";
        }
        // inline-template
        if (el.inlineTemplate) {
            var inlineTemplate = genInlineTemplate(el);
            if (inlineTemplate) {
                data += inlineTemplate + ",";
            }
        }
        data = data.replace(/,$/, '') + '}';
        // v-bind data wrap
        if (el.wrapData) {
            data = el.wrapData(data);
        }
        return data
    }

    function genDirectives(el) {
        var dirs = el.directives;
        if (!dirs) { return }
        var res = 'directives:[';
        var hasRuntime = false;
        var i, l, dir, needRuntime;
        for (i = 0, l = dirs.length; i < l; i++) {
            dir = dirs[i];
            needRuntime = true;
            var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
            if (gen) {
                // compile-time directive that manipulates AST.
                // returns true if it also needs a runtime counterpart.
                needRuntime = !!gen(el, dir, warn$2);
            }
            if (needRuntime) {
                hasRuntime = true;
                res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
            }
        }
        if (hasRuntime) {
            return res.slice(0, -1) + ']'
        }
    }

    function genInlineTemplate(el) {
        var ast = el.children[0];
        if ("development" !== 'production' && (
            el.children.length > 1 || ast.type !== 1
        )) {
            warn$2('Inline-template components must have exactly one child element.');
        }
        if (ast.type === 1) {
            var inlineRenderFns = generate(ast, currentOptions);
            return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
        }
    }

    function genScopedSlots(slots) {
        return ("scopedSlots:{" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + "}")
    }

    function genScopedSlot(key, el) {
        return key + ":function(" + (String(el.attrsMap.scope)) + "){" +
            "return " + (el.tag === 'template'
                ? genChildren(el) || 'void 0'
                : genElement(el)) + "}"
    }

    function genChildren(el, checkSkip) {
        var children = el.children;
        if (children.length) {
            var el$1 = children[0];
            // optimize single v-for
            if (children.length === 1 &&
                el$1.for &&
                el$1.tag !== 'template' &&
                el$1.tag !== 'slot') {
                return genElement(el$1)
            }
            var normalizationType = getNormalizationType(children);
            return ("[" + (children.map(genNode).join(',')) + "]" + (checkSkip
                ? normalizationType ? ("," + normalizationType) : ''
                : ''))
        }
    }

    // determine the normalization needed for the children array.
    // 0: no normalization needed
    // 1: simple normalization needed (possible 1-level deep nested array)
    // 2: full normalization needed
    function getNormalizationType(children) {
        var res = 0;
        for (var i = 0; i < children.length; i++) {
            var el = children[i];
            if (el.type !== 1) {
                continue
            }
            if (needsNormalization(el) ||
                (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
                res = 2;
                break
            }
            if (maybeComponent(el) ||
                (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
                res = 1;
            }
        }
        return res
    }

    function needsNormalization(el) {
        return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
    }

    function maybeComponent(el) {
        return !isPlatformReservedTag$1(el.tag)
    }

    function genNode(node) {
        if (node.type === 1) {
            return genElement(node)
        } else {
            return genText(node)
        }
    }

    function genText(text) {
        return ("_v(" + (text.type === 2
            ? text.expression // no need for () because already wrapped in _s()
            : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
    }

    function genSlot(el) {
        var slotName = el.slotName || '"default"';
        var children = genChildren(el);
        var res = "_t(" + slotName + (children ? ("," + children) : '');
        var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
        var bind$$1 = el.attrsMap['v-bind'];
        if ((attrs || bind$$1) && !children) {
            res += ",null";
        }
        if (attrs) {
            res += "," + attrs;
        }
        if (bind$$1) {
            res += (attrs ? '' : ',null') + "," + bind$$1;
        }
        return res + ')'
    }

    // componentName is el.component, take it as argument to shun flow's pessimistic refinement
    function genComponent(componentName, el) {
        var children = el.inlineTemplate ? null : genChildren(el, true);
        return ("_c(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
    }

    function genProps(props) {
        var res = '';
        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
        }
        return res.slice(0, -1)
    }

    // #3895, #4268
    function transformSpecialNewlines(text) {
        return text
            .replace(/\u2028/g, '\\u2028')
            .replace(/\u2029/g, '\\u2029')
    }

    /*  */

    /**
     * Compile a template.
     */
    function compile$1(
        template,
        options
    ) {
        var ast = parse(template.trim(), options);
        optimize(ast, options);
        var code = generate(ast, options);
        return {
            ast: ast,
            render: code.render,
            staticRenderFns: code.staticRenderFns
        }
    }

    /*  */

    // operators like typeof, instanceof and in are allowed
    var prohibitedKeywordRE = new RegExp('\\b' + (
        'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments'
    ).split(',').join('\\b|\\b') + '\\b');
    // check valid identifier for v-for
    var identRE = /[A-Za-z_$][\w$]*/;
    // strip strings in expressions
    var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

    // detect problematic expressions in a template
    function detectErrors(ast) {
        var errors = [];
        if (ast) {
            checkNode(ast, errors);
        }
        return errors
    }

    function checkNode(node, errors) {
        if (node.type === 1) {
            for (var name in node.attrsMap) {
                if (dirRE.test(name)) {
                    var value = node.attrsMap[name];
                    if (value) {
                        if (name === 'v-for') {
                            checkFor(node, ("v-for=\"" + value + "\""), errors);
                        } else {
                            checkExpression(value, (name + "=\"" + value + "\""), errors);
                        }
                    }
                }
            }
            if (node.children) {
                for (var i = 0; i < node.children.length; i++) {
                    checkNode(node.children[i], errors);
                }
            }
        } else if (node.type === 2) {
            checkExpression(node.expression, node.text, errors);
        }
    }

    function checkFor(node, text, errors) {
        checkExpression(node.for || '', text, errors);
        checkIdentifier(node.alias, 'v-for alias', text, errors);
        checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
        checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
    }

    function checkIdentifier(ident, type, text, errors) {
        if (typeof ident === 'string' && !identRE.test(ident)) {
            errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
        }
    }

    function checkExpression(exp, text, errors) {
        try {
            new Function(("return " + exp));
        } catch (e) {
            var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
            if (keywordMatch) {
                errors.push(
                    "- avoid using JavaScript keyword as property name: " +
                    "\"" + (keywordMatch[0]) + "\" in expression " + text
                );
            } else {
                errors.push(("- invalid expression: " + text));
            }
        }
    }

    /*  */

    function transformNode(el, options) {
        var warn = options.warn || baseWarn;
        var staticClass = getAndRemoveAttr(el, 'class');
        if ("development" !== 'production' && staticClass) {
            var expression = parseText(staticClass, options.delimiters);
            if (expression) {
                warn(
                    "class=\"" + staticClass + "\": " +
                    'Interpolation inside attributes has been removed. ' +
                    'Use v-bind or the colon shorthand instead. For example, ' +
                    'instead of <div class="{{ val }}">, use <div :class="val">.'
                );
            }
        }
        if (staticClass) {
            el.staticClass = JSON.stringify(staticClass);
        }
        var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
        if (classBinding) {
            el.classBinding = classBinding;
        }
    }

    function genData$1(el) {
        var data = '';
        if (el.staticClass) {
            data += "staticClass:" + (el.staticClass) + ",";
        }
        if (el.classBinding) {
            data += "class:" + (el.classBinding) + ",";
        }
        return data
    }

    var klass$1 = {
        staticKeys: ['staticClass'],
        transformNode: transformNode,
        genData: genData$1
    };

    /*  */

    function transformNode$1(el, options) {
        var warn = options.warn || baseWarn;
        var staticStyle = getAndRemoveAttr(el, 'style');
        if (staticStyle) {
            /* istanbul ignore if */
            {
                var expression = parseText(staticStyle, options.delimiters);
                if (expression) {
                    warn(
                        "style=\"" + staticStyle + "\": " +
                        'Interpolation inside attributes has been removed. ' +
                        'Use v-bind or the colon shorthand instead. For example, ' +
                        'instead of <div style="{{ val }}">, use <div :style="val">.'
                    );
                }
            }
            el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
        }

        var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
        if (styleBinding) {
            el.styleBinding = styleBinding;
        }
    }

    function genData$2(el) {
        var data = '';
        if (el.staticStyle) {
            data += "staticStyle:" + (el.staticStyle) + ",";
        }
        if (el.styleBinding) {
            data += "style:(" + (el.styleBinding) + "),";
        }
        return data
    }

    var style$1 = {
        staticKeys: ['staticStyle'],
        transformNode: transformNode$1,
        genData: genData$2
    };

    var modules$1 = [
        klass$1,
        style$1
    ];

    /*  */

    var warn$3;

    function model$1(
        el,
        dir,
        _warn
    ) {
        warn$3 = _warn;
        var value = dir.value;
        var modifiers = dir.modifiers;
        var tag = el.tag;
        var type = el.attrsMap.type;
        {
            var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
            if (tag === 'input' && dynamicType) {
                warn$3(
                    "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
                    "v-model does not support dynamic input types. Use v-if branches instead."
                );
            }
        }
        if (tag === 'select') {
            genSelect(el, value, modifiers);
        } else if (tag === 'input' && type === 'checkbox') {
            genCheckboxModel(el, value, modifiers);
        } else if (tag === 'input' && type === 'radio') {
            genRadioModel(el, value, modifiers);
        } else {
            genDefaultModel(el, value, modifiers);
        }
        // ensure runtime directive metadata
        return true
    }

    function genCheckboxModel(
        el,
        value,
        modifiers
    ) {
        if ("development" !== 'production' &&
            el.attrsMap.checked != null) {
            warn$3(
                "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
                "inline checked attributes will be ignored when using v-model. " +
                'Declare initial values in the component\'s data option instead.'
            );
        }
        var number = modifiers && modifiers.number;
        var valueBinding = getBindingAttr(el, 'value') || 'null';
        var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
        var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
        addProp(el, 'checked',
            "Array.isArray(" + value + ")" +
            "?_i(" + value + "," + valueBinding + ")>-1" + (
                trueValueBinding === 'true'
                    ? (":(" + value + ")")
                    : (":_q(" + value + "," + trueValueBinding + ")")
            )
        );
        addHandler(el, 'click',
            "var $$a=" + value + "," +
            '$$el=$event.target,' +
            "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
            'if(Array.isArray($$a)){' +
            "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
            '$$i=_i($$a,$$v);' +
            "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
            "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
            "}else{" + value + "=$$c}",
            null, true
        );
    }

    function genRadioModel(
        el,
        value,
        modifiers
    ) {
        if ("development" !== 'production' &&
            el.attrsMap.checked != null) {
            warn$3(
                "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
                "inline checked attributes will be ignored when using v-model. " +
                'Declare initial values in the component\'s data option instead.'
            );
        }
        var number = modifiers && modifiers.number;
        var valueBinding = getBindingAttr(el, 'value') || 'null';
        valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
        addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
        addHandler(el, 'click', genAssignmentCode(value, valueBinding), null, true);
    }

    function genDefaultModel(
        el,
        value,
        modifiers
    ) {
        {
            if (el.tag === 'input' && el.attrsMap.value) {
                warn$3(
                    "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
                    'inline value attributes will be ignored when using v-model. ' +
                    'Declare initial values in the component\'s data option instead.'
                );
            }
            if (el.tag === 'textarea' && el.children.length) {
                warn$3(
                    "<textarea v-model=\"" + value + "\">:\n" +
                    'inline content inside <textarea> will be ignored when using v-model. ' +
                    'Declare initial values in the component\'s data option instead.'
                );
            }
        }

        var type = el.attrsMap.type;
        var ref = modifiers || {};
        var lazy = ref.lazy;
        var number = ref.number;
        var trim = ref.trim;
        var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
        var needCompositionGuard = !lazy && type !== 'range';
        var isNative = el.tag === 'input' || el.tag === 'textarea';

        var valueExpression = isNative
            ? ("$event.target.value" + (trim ? '.trim()' : ''))
            : trim ? "(typeof $event === 'string' ? $event.trim() : $event)" : "$event";
        valueExpression = number || type === 'number'
            ? ("_n(" + valueExpression + ")")
            : valueExpression;

        var code = genAssignmentCode(value, valueExpression);
        if (isNative && needCompositionGuard) {
            code = "if($event.target.composing)return;" + code;
        }

        // inputs with type="file" are read only and setting the input's
        // value will throw an error.
        if ("development" !== 'production' &&
            type === 'file') {
            warn$3(
                "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
                "File inputs are read only. Use a v-on:change listener instead."
            );
        }

        addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
        addHandler(el, event, code, null, true);
        if (trim || number || type === 'number') {
            addHandler(el, 'blur', '$forceUpdate()');
        }
    }

    function genSelect(
        el,
        value,
        modifiers
    ) {
        {
            el.children.some(checkOptionWarning);
        }

        var number = modifiers && modifiers.number;
        var assignment = "Array.prototype.filter" +
            ".call($event.target.options,function(o){return o.selected})" +
            ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
            "return " + (number ? '_n(val)' : 'val') + "})" +
            (el.attrsMap.multiple == null ? '[0]' : '');

        var code = genAssignmentCode(value, assignment);
        addHandler(el, 'change', code, null, true);
    }

    function checkOptionWarning(option) {
        if (option.type === 1 &&
            option.tag === 'option' &&
            option.attrsMap.selected != null) {
            warn$3(
                "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
                'inline selected attributes on <option> will be ignored when using v-model. ' +
                'Declare initial values in the component\'s data option instead.'
            );
            return true
        }
        return false
    }

    function genAssignmentCode(value, assignment) {
        var modelRs = parseModel(value);
        if (modelRs.idx === null) {
            return (value + "=" + assignment)
        } else {
            return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
                "if (!Array.isArray($$exp)){" +
                value + "=" + assignment + "}" +
                "else{$$exp.splice($$idx, 1, " + assignment + ")}"
        }
    }

    /*  */

    function text(el, dir) {
        if (dir.value) {
            addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
        }
    }

    /*  */

    function html(el, dir) {
        if (dir.value) {
            addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
        }
    }

    var directives$1 = {
        model: model$1,
        text: text,
        html: html
    };

    /*  */

    var cache = Object.create(null);

    var baseOptions = {
        expectHTML: true,
        modules: modules$1,
        staticKeys: genStaticKeys(modules$1),
        directives: directives$1,
        isReservedTag: isReservedTag,
        isUnaryTag: isUnaryTag,
        mustUseProp: mustUseProp,
        getTagNamespace: getTagNamespace,
        isPreTag: isPreTag
    };

    function compile$$1(
        template,
        options
    ) {
        options = options
            ? extend(extend({}, baseOptions), options)
            : baseOptions;
        return compile$1(template, options)
    }

    function compileToFunctions(
        template,
        options,
        vm
    ) {
        var _warn = (options && options.warn) || warn;
        // detect possible CSP restriction
        /* istanbul ignore if */
        {
            try {
                new Function('return 1');
            } catch (e) {
                if (e.toString().match(/unsafe-eval|CSP/)) {
                    _warn(
                        'It seems you are using the standalone build of Vue.js in an ' +
                        'environment with Content Security Policy that prohibits unsafe-eval. ' +
                        'The template compiler cannot work in this environment. Consider ' +
                        'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
                        'templates into render functions.'
                    );
                }
            }
        }
        var key = options && options.delimiters
            ? String(options.delimiters) + template
            : template;
        if (cache[key]) {
            return cache[key]
        }
        var res = {};
        var compiled = compile$$1(template, options);
        res.render = makeFunction(compiled.render);
        var l = compiled.staticRenderFns.length;
        res.staticRenderFns = new Array(l);
        for (var i = 0; i < l; i++) {
            res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
        }
        {
            if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
                _warn(
                    "failed to compile template:\n\n" + template + "\n\n" +
                    detectErrors(compiled.ast).join('\n') +
                    '\n\n',
                    vm
                );
            }
        }
        return (cache[key] = res)
    }

    function makeFunction(code) {
        try {
            return new Function(code)
        } catch (e) {
            return noop
        }
    }

    /*  */

    var idToTemplate = cached(function (id) {
        var el = query(id);
        return el && el.innerHTML
    });

    var mount = Vue$3.prototype.$mount;
    Vue$3.prototype.$mount = function (
        el,
        hydrating
    ) {
        el = el && query(el);

        /* istanbul ignore if */
        if (el === document.body || el === document.documentElement) {
            "development" !== 'production' && warn(
                "Do not mount Vue to <html> or <body> - mount to normal elements instead."
            );
            return this
        }

        var options = this.$options;
        // resolve template/el and convert to render function
        if (!options.render) {
            var template = options.template;
            if (template) {
                if (typeof template === 'string') {
                    if (template.charAt(0) === '#') {
                        template = idToTemplate(template);
                        /* istanbul ignore if */
                        if ("development" !== 'production' && !template) {
                            warn(
                                ("Template element not found or is empty: " + (options.template)),
                                this
                            );
                        }
                    }
                } else if (template.nodeType) {
                    template = template.innerHTML;
                } else {
                    {
                        warn('invalid template option:' + template, this);
                    }
                    return this
                }
            } else if (el) {
                template = getOuterHTML(el);
            }
            if (template) {
                var ref = compileToFunctions(template, {
                    warn: warn,
                    shouldDecodeNewlines: shouldDecodeNewlines,
                    delimiters: options.delimiters
                }, this);
                var render = ref.render;
                var staticRenderFns = ref.staticRenderFns;
                options.render = render;
                options.staticRenderFns = staticRenderFns;
            }
        }
        return mount.call(this, el, hydrating)
    };

    /**
     * Get outerHTML of elements, taking care
     * of SVG elements in IE as well.
     */
    function getOuterHTML(el) {
        if (el.outerHTML) {
            return el.outerHTML
        } else {
            var container = document.createElement('div');
            container.appendChild(el.cloneNode(true));
            return container.innerHTML
        }
    }

    Vue$3.compile = compileToFunctions;

    return Vue$3;

})));



//refid, ver_num, type, dsobj, cur_status, tabNum, ssurl
var EbDataTable = function (Option) {
    this.propGrid = Option.PGobj;
    this.Api = null;
    this.order_info = new Object();
    this.order_info.col = '';
    this.order_info.dir = 0;
    this.MainData = (Option.data === undefined) ? null : Option.data;
    this.isPipped = false;
    this.isContextual = false;
    this.chartJs = null;
    this.url = Option.url;
    this.EbObject = Option.dsobj;
    this.tabNum = Option.tabNum;
    this.Refid = Option.refid;
    this.tableId = null;
    this.ebSettings = null;
    this.ssurl = Option.ssurl;
    this.login = Option.login;
    this.counter = Option.counter;
    this.datePattern = Option.datePattern;
    this.TenantId = Option.TenantId;
    this.UserId = Option.UserId;
    this.relatedObjects = null;
    this.FD = false;
    //Controls & Buttons
    this.table_jQO = null;
    //this.btnGo = $('#btnGo');
    this.filterBox = null;
    this.filterbtn = null;
    this.clearfilterbtn = null;
    this.totalpagebtn = null;
    this.copybtn = null;
    this.printbtn = null;
    this.settingsbtn = null;
    this.OuterModalDiv = null;
    this.settings_tbl = null;

    //temp
    this.eb_filter_controls_4fc = [];
    this.eb_filter_controls_4sb = [];
    this.zindex = 0;
    this.rowId = -1;
    //this.isSettingsSaved = false;
    this.dropdown_colname = null;
    this.deleted_colname = null;
    this.tempcolext = [];
    this.linkDV = null;
    this.filterFlag = false;
    //if (index !== 1)
    this.rowData = (Option.rowData !== undefined && Option.rowData !== null && Option.rowData !== "") ? JSON.parse(decodeURIComponent(escape(window.atob(Option.rowData)))) : null;
    this.filterValues = (Option.filterValues !== "" && Option.filterValues !== undefined && Option.filterValues !== null) ? JSON.parse(decodeURIComponent(escape(window.atob(Option.filterValues)))) : [];
    this.FlagPresentId = false;
    this.flagAppendColumns = false;
    this.drake = null;
    this.draggedPos = null;
    this.droppedPos = null;
    this.dragNdrop = false;
    this.flagColumnVisible = false;
    this.pg = null;
    this.ppgridChildren = null;
    this.columnDefDuplicate = null;
    this.extraCol = [];
    this.PcFlag = false;
    this.modifyDVFlag = false;
    this.initCompleteflag = false;
    this.isTagged = false;
    //this.filterChanged = false;
    this.isRun = false;
    this.cellData = Option.cellData;
    this.columnSearch = [];
    this.isSecondTime = false;
    this.tempColumns = [];
    this.filterHtml = "";
    this.orderColl = [];
    this.RGIndex = [];
    this.NumericIndex = [];
    this.inline = false;
    this.rowgroupCols = [];
    this.treeCols = [];
    this.rowgroupFilter = [];
    this.CurrentRowGroup = null;
    this.permission = [];
    this.isCustomColumnExist = false;
    this.dvformMode = -1;
    this.IsTree = false;
    this.GroupFormLink = null;
    this.ItemFormLink = null;
    this.treeColumn = null;
    this.treeData = [];
    this.tableName = null;
    this.moveToPid = null;
    this.movefromId = null;
    this.columnCount = null;

    var split = new splitWindow("parent-div0", "contBox");

    this.init = function () {
        this.tableId = "dv" + this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter;
        this.ContextId = "filterWindow_" + this.tableId;
        this.FDCont = $(`<div id='${this.ContextId}' class='filterCont fd'></div>`);
        $("#parent-div0").before(this.FDCont);
        this.FDCont.hide();

        if (this.login === "dc") {
            this.stickBtn = new EbStickButton({
                $wraper: this.FDCont,
                $extCont: this.FDCont,
                //$scope: $(subDivId),
                icon: "fa-filter",
                dir: "left",
                label: "Parameters",
                //btnTop: 42,
                style: { top: "78px" }
            });
        }
    };

    split.windowOnFocus = function (ev) {
        $("#Relateddiv").hide();
        if ($(ev.target).attr("class") !== undefined) {
            if ($(ev.target).attr("class").indexOf("sub-windows") !== -1) {
                var id = $(ev.target).attr("id");
                focusedId = id;
            }
        }
    }.bind(this);

    this.call2FD = function (value) {
        this.submitId = "btnGo" + this.tableId;
        var isCustom = (typeof (value) !== "undefined") ? ((value === "Yes") ? true : false) : true;
        this.relatedObjects = this.EbObject.DataSourceRefId;
        $("#eb_common_loader").EbLoader("show", { maskItem: { Id: "#parent", Style: { "top": "39px", "margin-left": "unset", "margin-right": "unset" } }, maskLoader: false });
        $.ajax({
            type: "POST",
            url: "../DV/dvCommon",
            data: { dvobj: JSON.stringify(this.EbObject), dvRefId: this.Refid, _flag: this.PcFlag, login: this.login, contextId: this.ContextId, customcolumn: isCustom, _curloc: store.get("Eb_Loc-" + this.TenantId + this.UserId), submitId: this.submitId },
            success: this.ajaxSucc
        });
    };

    this.ajaxSucc = function (text) {
        var flag = false;
        if (this.MainData !== null) {
            this.isPipped = true;
            $("#Pipped").show();
            $("#Pipped").text("Pipped From: " + this.EbObject.Pippedfrom);
            this.filterValues = dvcontainerObj.dvcol[prevfocusedId].filterValues;
        }
        else if (this.filterValues !== null && this.filterValues.length > 0) {
            this.isContextual = true;
        }
        else
            this.isTagged = true;
        var subDivId = "#sub_window_dv" + this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter;
        $("#content_dv" + this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter).empty();
        this.filterHtml = text;
        if (this.login === "uc") {
            this.stickBtn = new EbStickButton({
                $wraper: this.FDCont,
                $extCont: this.FDCont,
                $scope: $("#" + focusedId),
                icon: "fa-filter",
                dir: "left",
                label: "Parameters",
                //btnTop: 42,
                style: { top: "42px" }
            });
        }
        $("#obj_icons").empty();
        this.$submit = $("<button id='" + this.submitId + "' class='btn commonControl'><i class='fa fa-play' aria-hidden='true'></i></button>");
        $("#obj_icons").append(this.$submit);
        this.$submit.click(this.getColumnsSuccess.bind(this));

        this.FDCont = $("#filterWindow_" + this.tableId);
        $("#filterWindow_" + this.tableId).empty();
        $("#filterWindow_" + this.tableId).append("<div class='pgHead'> Param window <div class='icon-cont  pull-right' id='close_paramdiv_" + this.tableId + "'><i class='fa fa-thumb-tack' style='transform: rotate(90deg);'></i></div></div>");//
        $("#filterWindow_" + this.tableId).children().find('#close_paramdiv').off('click').on('click', this.CloseParamDiv.bind(this));
        $("#filterWindow_" + this.tableId).children().find("#close_paramdiv_" + this.tableId).off('click').on('click', this.CloseParamDiv.bind(this));

        $("#filterWindow_" + this.tableId).append(text);
        $("#filterWindow_" + this.tableId).children().find("#btnGo").click(this.getColumnsSuccess.bind(this));

        this.FilterDialog = (typeof (FilterDialog) !== "undefined") ? FilterDialog : {};

        if (text !== "") {
            if (typeof commonO !== "undefined")
                this.EbObject = commonO.Current_obj;
            else
                this.EbObject = dvcontainerObj.currentObj;
        }
        //this.InitializeColumns();
        this.SetColumnRef();
        this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
        if (this.PcFlag === true)
            this.compareAndModifyRowGroup();

        if ($("#" + this.ContextId).children("#filterBox").length === 0) {
            this.FD = false;
            this.FDCont.hide();
            if (this.login === "dc") {
                this.stickBtn.hide();
            }
            else {
                dvcontainerObj.dvcol[focusedId].stickBtn.hide();
            }
            $("#eb_common_loader").EbLoader("hide");
            this.$submit.trigger("click");
        }
        else {
            this.FD = true;
            if (this.isPipped || this.isContextual) {
                this.placefiltervalues();
                this.$submit.trigger("click");
            }
            else {
                this.FDCont.show();
                this.FDCont.css("visibility", "visible");
            }
            $("#eb_common_loader").EbLoader("hide");
        }
        $(subDivId).focus();

        this.PcFlag = false;
    }.bind(this);

    this.SetColumnRef = function () {
        $.each(this.EbObject.Columns.$values, function (i, obj) {
            obj.ColumnsRef = this.EbObject.Columns;
        }.bind(this));
    };

    this.RemoveColumnRef = function () {
        $.each(this.EbObject.Columns.$values, function (i, obj) {
            obj.ColumnsRef = null;
        }.bind(this));
    };

    this.CloseParamDiv = function () {
        this.stickBtn.minimise();
    };

    this.tmpPropertyChanged = function (obj, Pname, newval, oldval) {
        //this.isSecondTime = true;
        if (Pname === "DataSourceRefId") {
            if (obj[Pname] !== null) {
                this.PcFlag = true;
                this.stickBtn.hide();
                this.filterValues = [];
                this.isContextual = false;
                this.isPipped = false;
                this.rowData = null;

                this.orderColl = [];
                this.check4Customcolumn();
                this.EbObject.OrderBy.$values = [];
                this.MainData = null;
                if (this.isCustomColumnExist) {
                    EbDialog("show", {
                        Message: "Retain Custom Columns?",
                        Buttons: {
                            "Yes": {
                                Background: "green",
                                Align: "right",
                                FontColor: "white;"
                            },
                            "No": {
                                Background: "red",
                                Align: "left",
                                FontColor: "white;"
                            }
                        },
                        CallBack: this.dialogboxAction.bind(this)
                    });
                }
                else
                    this.call2FD();
            }
        }
        else if (Pname === "Name") {
            $("#objname").text(obj.DisplayName);
            console.log(obj);
        }
        else if (Pname === "Columns") {
            console.log(obj);
        }
        else if (Pname === "Formula") {
            this.ValidateCalcExpression(obj);
        }
        else if (Pname === "RowGroupCollection") {
            this.CurrentRowGroup = null;
            this.rowgroupCols = [];
        }
    }.bind(this);

    this.dialogboxAction = function (value) {
        this.call2FD(value);
    };

    this.compareAndModifyRowGroup = function () {
        var temparr = [];
        $.each(this.EbObject.RowGroupCollection.$values, function (i, obj) {
            $.each(obj.RowGrouping.$values, function (j, col) {
                var tempcol = $.grep(this.EbObject.Columns.$values, function (column) { return column.name === col.name && column.Type === col.Type });
                if (tempcol.length !== 1) {
                    temparr.push(i);
                    return false;
                }
            }.bind(this));
        }.bind(this));
        $.each(temparr, function (i, index) {
            this.EbObject.RowGroupCollection.$values.splice(index, 1);
        }.bind(this));
        this.CurrentRowGroup = null;
    };

    //Initialisation
    this.start = function () {
        if (this.EbObject === null) {
            this.EbObject = new EbObjects["EbTableVisualization"]("Container_" + Date.now());
            split.createContentWindow(this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter, "EbTableVisualization");
            if (this.login === "dc") {
                //this.propGrid = new Eb_PropertyGrid("pp_inner", "dc");
                this.propGrid = new Eb_PropertyGrid({
                    id: "pp_inner",
                    wc: "dc",
                    cid: this.cid,
                    $extCont: $(".ppcont")
                }, this.PGobj);

                this.propGrid.PropertyChanged = this.tmpPropertyChanged;
            }
            this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
            $("#" + this.ContextId).css("visibility", "hidden");
            this.init();
        }
        else {
            if (this.MainData !== null)
                split.createContentWindow(this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter, "EbTableVisualization", prevfocusedId);
            else
                split.createContentWindow(this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter, "EbTableVisualization");
            if (this.login === "dc") {
                //this.propGrid = new Eb_PropertyGrid("pp_inner", "dc");

                this.propGrid = new Eb_PropertyGrid({
                    id: "pp_inner",
                    wc: "dc",
                    cid: this.cid,
                    $extCont: $(".ppcont"),
                    style: { top: "76px" }
                }, this.PGobj);

                this.propGrid.PropertyChanged = this.tmpPropertyChanged;
            }
            else
                this.propGrid.ClosePG();
            $("#objname").text(this.EbObject.DisplayName);
            this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
            this.init();
            this.call2FD();
        }

        this.propGrid.CXVE.onAddToCE = function (prop, val, addedObj) {
            if (addedObj.ObjType === "NumericColumn")
                addedObj.className = "tdheight dt-body-right";
        };
    };

    this.getColumnsSuccess = function (e) {
        this.propGrid.ClosePG();
        if (this.FD)
            this.stickBtn.minimise();
        else
            this.stickBtn.hide();
        $("#objname").text(this.EbObject.DisplayName);
        this.validateFD = this.FilterDialog.IsFDValidationOK;
        if (this.isContextual) {
            if (this.isSecondTime) {
                if (this.validateFD && !this.validateFD())
                    return;
                this.filterValues = this.getFilterValues("filter");
            }
        }
        else {
            if (this.validateFD && !this.validateFD())
                return;
            this.filterValues = this.getFilterValues("filter");
        }
        this.isSecondTime = false;
        if (this.login === "uc")
            $(".dv-body1").show();
        $("#eb_common_loader").EbLoader("show");
        this.extraCol = [];
        this.ebSettings = this.EbObject;
        $.extend(this.tempColumns, this.EbObject.Columns.$values);
        //this.tempColumns.sort(this.ColumnsComparer);
        this.dsid = this.ebSettings.DataSourceRefId;//not sure..
        this.dvName = this.ebSettings.Name;
        this.initCompleteflag = false;

        this.check4Customcolumn();
        this.CheckforTree();
        this.addSerialAndCheckboxColumns();
        this.ModifyColumnObject();
        this.treeCols = [];
        this.getColumnCount();
        //hard coding
        this.orderColl = [];
        let rowG_coll = this.EbObject.RowGroupCollection.$values;
        let CurR_RowG = this.CurrentRowGroup;
        if (rowG_coll.length > 0 && !this.EbObject.DisableRowGrouping) {
            if (CurR_RowG === null) {
                CurR_RowG = rowG_coll.find(obj => obj.RowGrouping.$values.length > 0);
                this.CurrentRowGroup = CurR_RowG;
            }
            this.visibilityCheck();
        }
        else {
            if (this.CurrentRowGroup !== null) {
                $.each(this.EbObject.Columns.$values, function (i, colobj) {
                    $.each(CurR_RowG.RowGrouping.$values, function (i, rgobj) {
                        if (colobj.name === rgobj.name) {
                            colobj.bVisible = true;
                        }
                    }.bind(this));
                }.bind(this));
            }
            this.CurrentRowGroup = null;
            this.RGIndex = [];
            this.rowgroupCols = [];

        }


        //----------
        if (this.ebSettings.$type.indexOf("EbTableVisualization") !== -1) {
            $("#content_" + this.tableId).empty();
            $("#content_" + this.tableId).append("<div id='" + this.tableId + "divcont' class='wrapper-cont_inner'><table id='" + this.tableId + "' class='table display table-bordered compact'></table></div>");
            this.Init();
        }
    };

    this.check4Customcolumn = function () {
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.IsCustomColumn; });
        if (temp.length === 0)
            this.isCustomColumnExist = false;
        else {
            this.isCustomColumnExist = true;
            temp.map(function (x) {
                x.orderable = false;
                return x;
            });
        }
    };

    this.CheckforTree = function () {
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.IsTree; });
        if (temp.length === 0) {
            //this.EbObject.DisableRowGrouping = false;
            this.IsTree = false;
        }
        else {
            this.EbObject.DisableRowGrouping = true;
            this.IsTree = true;
            this.GroupFormLink = temp[0].GroupFormLink;
            this.ItemFormLink = temp[0].ItemFormLink;
            this.treeColumn = temp[0];
            this.treeColumnIndex = this.EbObject.Columns.$values.findIndex(x => x.data === this.treeColumn.data);
        }
        if (this.IsTree)
            this.EbObject.IsPaging = false;
    };

    this.ModifyColumnObject = function () {
        if (this.IsTree) {
            this.EbObject.Columns.$values.map(function (x) {
                x.orderable = false;
                return x;
            });
        }
    };

    this.getColumnCount = function () {
        this.columnCount = this.rowgroupCols.length + this.extraCol.length;
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.bVisible; });
        this.columnCount += temp.length;
    };

    this.InitializeColumns = function () {
        $.each(this.EbObject.Columns.$values, function (i, col) {
            if (col.HideDataIfRowMoreThan === null)
                col.HideDataIfRowMoreThan = { "$type": "ExpressBase.Objects.Objects.DVRelated.HideColumnData, ExpressBase.Objects", "Enable": false, "UnRestrictedRowCount": 0, "ReplaceByCharacter": "", "ReplaceByText": "" };
        }.bind(this));
    };

    this.validateFD = function () { }

    this.Init = function () {
        //this.MainData = null;
        $.event.props.push('dataTransfer');
        this.updateRenderFunc();
        this.table_jQO = $('#' + this.tableId);
        this.copybtn = $("#btnCopy" + this.tableId);
        this.printbtn = $("#btnPrint" + this.tableId);
        this.printSelectedbtn = $("#btnprintSelected" + this.tableId);
        this.excelbtn = $("#btnExcel" + this.tableId);
        this.csvbtn = $("#btnCsv" + this.tableId);
        this.pdfbtn = $("#btnPdf" + this.tableId);

        this.eb_agginfo = this.getAgginfo();

        this.table_jQO.append($(this.getFooterFromSettingsTbl()));

        //this.table_jQO.children("tfoot").hide();
        this.table_jQO.children().find("tr").addClass("addedbyeb");

        //this.table_jQO.on('pre-row-reorder.dt', function (e, node, index) {
        //    console.log('Row reorder started: ', node, index);
        //});

        this.table_jQO.on('processing.dt', function (e, settings, processing) {
            if (processing == true) {
                $("#obj_icons .btn").prop("disabled", true);
                $("#eb_common_loader").EbLoader("show");
            }
            else {
                $("#obj_icons .btn").prop("disabled", false);
                $("#eb_common_loader").EbLoader("hide");
                $("[data-coltyp=date]").datepicker("hide");
            }
        }.bind(this));

        jQuery.fn.dataTable.ext.errMode = 'alert';

        this.table_jQO.on('error.dt', function (settings, techNote, message) {
            console.log('An error has been reported by DataTables: ', message);
        });

        this.Api = this.table_jQO.DataTable(this.createTblObject());

        this.Api.off('select').on('select', this.selectCallbackFunc.bind(this));

        jQuery.fn.dataTable.Api.register('sum()', function () {
            return this.flatten().reduce(function (a, b) {
                if (typeof a === 'string') {
                    a = a.replace(/[^\d.-]/g, '') * 1;
                }
                if (typeof b === 'string') {
                    b = b.replace(/[^\d.-]/g, '') * 1;
                }

                return a + b;
            }, 0);
        });

        jQuery.fn.dataTable.Api.register('average()', function () {
            var data = this.flatten();
            var sum = data.reduce(function (a, b) {
                if (typeof a === 'string') {
                    a = a.replace(/[^\d.-]/g, '') * 1;
                }
                if (typeof b === 'string') {
                    b = b.replace(/[^\d.-]/g, '') * 1;
                }

                return (a * 1) + (b * 1); // cast values in-case they are strings
            }, 0);

            return sum / data.length;
        });

        jQuery.extend(jQuery.fn.dataTableExt.oSort, {
            "date-uk-pre": function (a) {
                if (a == null || a == "") {
                    return 0;
                }
                var ukDatea = a.split('/');
                return (ukDatea[2] + ukDatea[1] + ukDatea[0]) * 1;
            },

            "date-uk-asc": function (a, b) {
                return ((a < b) ? -1 : ((a > b) ? 1 : 0));
            },

            "date-uk-desc": function (a, b) {
                return ((a < b) ? 1 : ((a > b) ? -1 : 0));
            }
        });

        //this.table_jQO.off('draw.dt').on('draw.dt', this.doSerial.bind(this));

        //this.table_jQO.on('length.dt', function (e, settings, len) {
        //    console.log('New page length: ' + len);
        //});

        $.fn.dataTable.ext.errMode = function (settings, helpPage, message) {
            alert("ajax erpttt......");
        };


        //this.Api.on('row-reorder', function (e, diff, edit) {
        //});
    };

    this.addSerialAndCheckboxColumns = function () {
        this.CheckforColumnID();//, 
        var serialObj = (JSON.parse('{ "data":' + this.EbObject.Columns.$values.length + ', "searchable": false, "orderable": false, "bVisible":true, "name":"serial", "title":"#", "Type":11}'));
        if (this.IsTree) {
            serialObj.bVisible = false;
        }
        this.extraCol.push(serialObj);
        this.addcheckbox();
    }

    this.CheckforColumnID = function () {
        this.FlagPresentId = false;
        $.each(this.ebSettings.Columns.$values, function (i, col) {
            if (col.name === "id") {
                this.FlagPresentId = true;
                col.bVisible = false;
                return false;
            }
        }.bind(this));
    };

    this.addcheckbox = function () {
        var chkObj = new Object();
        chkObj.data = null;
        chkObj.title = "<input id='{0}_select-all' class='eb_selall" + this.tableId + "' type='checkbox' data-table='{0}'/>".replace("{0}", this.tableId);
        chkObj.sWidth = "10px";
        chkObj.orderable = false;
        chkObj.bVisible = false;
        chkObj.name = "checkbox";
        chkObj.Type = 3;
        chkObj.render = this.renderCheckBoxCol.bind(this);
        chkObj.pos = "-1";

        this.extraCol.push(chkObj);
    }

    this.createTblObject = function () {
        var o = new Object();
        //o.scrollY = "inherit";
        o.scrollX = "100%";
        //o.scrollXInner = "110%";
        o.scrollCollapse = true;
        if (this.ebSettings.PageLength !== 0) {
            o.lengthMenu = this.generateLengthMenu();
        }
        if (this.ebSettings.LeftFixedColumn > 0 || this.ebSettings.RightFixedColumn > 0)
            o.fixedColumns = { leftColumns: this.fixedColumnCount(), rightColumns: this.ebSettings.RightFixedColumn };
        o.pagingType = "full";
        o.buttons = ['copy', 'csv', 'excel', 'pdf', 'print', { extend: 'print', exportOptions: { modifier: { selected: true } } }];
        o.bAutoWidth = false;
        o.autowidth = false;
        o.serverSide = true;
        o.processing = true;
        o.pageResize = true;
        //o.deferRender = true;
        //o.scroller = true;
        o.language = {
            //processing: "<div class='fa fa-spinner fa-pulse fa-3x fa-fw'></div>",
            info: "_START_ - _END_ / _TOTAL_",
            paginate: {
                "previous": "Prev"
            },
            lengthMenu: "_MENU_ / Page",
        };
        o.columns = this.rowgroupCols.concat(this.extraCol, this.ebSettings.Columns.$values);
        o.order = [];
        o.deferRender = true;
        //o.filter = true;
        //o.select = true;
        //o.retrieve = true;
        o.keys = true;
        //this.filterValues = this.getFilterValues();
        //filterChanged = false;
        //if (!this.isTagged)
        //    this.compareFilterValues();
        //else
        //    filterChanged = true;
        //o.rowReorder = this.IsTree;
        if (this.MainData !== null && this.login == "uc" && !filterChanged && this.isPipped) {
            //o.serverSide = false;
            o.dom = "<'col-md-10 noPadding'B><'col-md-2 noPadding'f>rt";
            dvcontainerObj.currentObj.data = this.MainData;
            o.ajax = function (data, callback, settings) {
                setTimeout(function () {
                    callback({
                        draw: dvcontainerObj.currentObj.data.draw,
                        data: dvcontainerObj.currentObj.data.data,
                        recordsTotal: dvcontainerObj.currentObj.data.recordsTotal,
                        recordsFiltered: dvcontainerObj.currentObj.data.recordsFiltered,
                    });
                }, 50);
            }
            o.data = this.receiveAjaxData(this.MainData);
        }
        else {
            o.dom = "<'pagination-wrapper'liBp>rt";
            o.paging = true;
            o.lengthChange = true;
            if (!this.ebSettings.IsPaging) {
                if (this.IsTree) {
                    o.dom = "<'col-md-12 noPadding display-none'B><'col-md-12'i>rt";
                    o.language.info = "_START_ - _END_ / _TOTAL_ Entries";
                }
                else {
                    o.dom = "<'col-md-12 noPadding display-none'B>rt";
                }
                o.paging = false;
                o.lengthChange = false;
            }
            if (this.login === "uc") {
                dvcontainerObj.currentObj.Pippedfrom = "";
                $("#Pipped").text("");
                this.isPipped = false;
            }
            try {
                o.ajax = {
                    //url: this.ssurl + '/ds/data/' + this.dsid,
                    url: "../dv/getData",
                    type: 'POST',
                    timeout: 0,
                    data: this.ajaxData.bind(this),
                    dataSrc: this.receiveAjaxData.bind(this),
                    beforeSend: function () {
                    },
                    error: function (req, status, xhr) {
                    }
                };
            }
            catch (Error) {
                alert(Error);
            }
        }
        o.fnRowCallback = this.rowCallBackFunc.bind(this);
        o.drawCallback = this.drawCallBackFunc.bind(this);
        o.initComplete = this.initCompleteFunc.bind(this);
        //o.fnDblclickCallbackFunc = this.dblclickCallbackFunc.bind(this);
        return o;
    };

    this.generateLengthMenu = function () {
        var ia = [];
        for (var i = 0; i < 5; i++)
            ia[i] = (this.ebSettings.PageLength * (i + 1));
        return JSON.parse("[ [{0},-1], [{0},\"All\"] ]".replace(/\{0\}/g, ia.join(',')));
    }

    this.ajaxData = function (dq) {
        if (!this.isSecondTime) {
            $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").hide();
            $("#" + this.tableId + "_wrapper .DTFC_LeftFootWrapper").hide();
            $("#" + this.tableId + "_wrapper .DTFC_RightFootWrapper").hide();
        }

        this.matchColumnSearchAndVisible();
        delete dq.columns; delete dq.order; delete dq.search;
        dq.RefId = this.EbObject.DataSourceRefId;
        dq.TFilters = this.columnSearch;
        if (this.filterValues.length === 0)
            this.filterValues = this.getFilterValues();
        dq.Params = this.filterValues;

        dq.OrderBy = this.getOrderByInfo();
        if (this.columnSearch.length > 0) {
            this.filterFlag = true;
        }
        dq.Ispaging = this.EbObject.IsPaging;
        if (dq.length === -1)
            dq.length = this.RowCount;
        this.RemoveColumnRef();
        dq.DataVizObjString = JSON.stringify(this.EbObject);
        if (this.CurrentRowGroup !== null)
            dq.CurrentRowGroup = JSON.stringify(this.CurrentRowGroup);
        dq.dvRefId = this.Refid;
        return dq;
    };

    this.getOrderByInfo = function () {
        var tempArray = [];
        if (this.CurrentRowGroup !== null) {
            if (this.CurrentRowGroup.RowGrouping.$values.length > 0) {
                for (let i = 0; i < this.CurrentRowGroup.RowGrouping.$values.length; i++)
                    tempArray.push(new order_obj(this.CurrentRowGroup.RowGrouping.$values[i].name, this.CurrentRowGroup.RowGrouping.$values[i].Direction));
            }
            if (this.orderColl.length > 0) {
                $.each(this.orderColl, function (i, obj) {
                    tempArray.push(obj);
                });
            }
            else {
                if (this.CurrentRowGroup.OrderBy.$values.length > 0) {
                    for (let i = 0; i < this.CurrentRowGroup.OrderBy.$values.length; i++)
                        tempArray.push(new order_obj(this.CurrentRowGroup.OrderBy.$values[i].name, this.CurrentRowGroup.OrderBy.$values[i].Direction));
                }
            }
        }

        if (tempArray.length === 0) {
            $.each(this.orderColl, function (i, obj) {
                tempArray.push(obj);
            });
            if (tempArray.length === 0) {
                $.each(this.EbObject.OrderBy.$values, function (i, obj) {
                    if (tempArray.filter(e => e.Column === obj.name).length === 0)
                        tempArray.push(new order_obj(obj.name, obj.Direction));
                });
            }
        }

        return tempArray;
    };

    this.getFilterValues = function (from) {
        //this.filterChanged = false;
        var fltr_collection = [];

        if (this.FD)
            fltr_collection = getValsForViz(this.FilterDialog.FormObj);


        //if (this.isContextual && from !== "compare") {
        //    if (from === "filter" && prevfocusedId !== undefined) {
        //        $.each(dvcontainerObj.dvcol[prevfocusedId].filterValues, function (i, obj) {
        //            var f = false;
        //            $.each(fltr_collection, function (j, fObj) {
        //                if (fObj.Name === obj.Name)
        //                    f = true;
        //            });
        //            if (!f)
        //                fltr_collection.push(obj);
        //        });
        //    }
        //    else {
        //        if (this.rowData !== null && this.rowData !== "") {
        //            if (this.Api !== null) {
        //                if (prevfocusedId === undefined)
        //                    from = "link";
        //                $.each(this.rowData, this.rowObj2filter.bind(this, fltr_collection, from));
        //            }
        //        }
        //    }
        //}

        return fltr_collection;
    };

    this.rowObj2filter = function (fltr_collection, from, i, data) {
        if (i < this.EbObject.Columns.$values.length) {
            if (from === "link") {
                var type = this.EbObject.Columns.$values[i].Type;
                //if (type === 5 || type === 6)
                //    data = this.renderDateformat(data, "-");
                if (data !== "")
                    fltr_collection.push(new fltr_obj(type, this.EbObject.Columns.$values[i].name, data));
            }
            else {
                if (dvcontainerObj.dvcol[prevfocusedId].Api !== null) {
                    var type = dvcontainerObj.dvcol[prevfocusedId].EbObject.Columns.$values[i].Type;
                    fltr_collection.push(new fltr_obj(type, dvcontainerObj.dvcol[prevfocusedId].EbObject.Columns.$values[i].name, data));
                }
            }
        }
    };

    this.getfilterFromRowdata = function () {
        var filters = [];
        if (parseInt(this.linkDV.split("-")[2]) !== EbObjectTypes.WebForm) {
            $.each(this.EbObject.Columns.$values, function (i, col) {
                if (this.rowData[col.data] !== "")
                    filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
            }.bind(this));
        }
        else {
            var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.LinkRefId === this.linkDV; }.bind(this));
            this.dvformMode = temp[0].FormMode;
            if (temp[0].FormMode === 1) {
                var col = temp[0].FormId.$values;
                $.each(col, function (i, col) {
                    filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
                }.bind(this));
            }
            else if (temp[0].FormMode === 2) {
                var cols = temp[0].FormParameters.$values;
                $.each(cols, function (i, col) {
                    if (this.rowData[col.data] !== "")
                        filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
                }.bind(this));
            }
        }
        return filters;
    };

    this.placefiltervalues = function () {
        //if (this.filterValues.length > 0) {
        //    $.each(this.filterValues, function (i, param) {
        //        $("#" + this.ContextId + ' #' + param.Name).val(param.Value);
        //    });
        //}
        $.each(getFlatControls(this.FilterDialog.FormObj), function (i, obj) {
            var mapobj = getObjByval(this.filterValues, "Name", obj.Name);
            if (typeof mapobj !== "undefined") {
                let val = mapobj.Value;
                obj.setValue(val);
            }
        }.bind(this));
    }

    this.filterDisplay = function () {
        var $controls = $("#" + this.ContextId + " #filterBox").children().not("[type=hidden],button");
        var filter = "";
        var filterdialog = [], columnFilter = [];
        if ($controls.length > 0) {
            $.each($controls, function (i, ctrl) {
                var o = new displayFilter();
                var ctype = $(ctrl).attr("ctype");
                o.name = $($(ctrl).children()[0]).text();
                o.operator = "=";
                if (ctype === "PowerSelect")
                    o.value = $(ctrl).find("input").attr("display-members");
                else if (ctype === "Date")
                    o.value = $(ctrl).find("input").val();
                else if (ctype === "RadioGroup")
                    o.value = $(ctrl).children().find("[type=radio]:checked").val();
                else if (ctype === "SimpleSelect")
                    o.value = $(ctrl).children().find("option:selected").text();
                else if (ctype === "UserLocation") {
                    let $sel = $(ctrl).find('select');
                    let allsld = $sel.next('div').find('[value=multiselect-all').prop('checked');
                    if (allsld && $sel.attr('isglobal') === 'y')
                        o.value = "Global";
                    else if (allsld)
                        o.value = "Selected all";
                    else
                        o.value = $(ctrl).find('ul').find(".active:not(.multiselect-all)").text().trim().split(" ").join(",");
                }
                else
                    o.value = $($(ctrl).children()[1]).val();

                if (typeof $controls[i + 1] !== "undefined")
                    o.logicOp = "AND";
                else
                    o.logicOp = "";
                if (o.value !== undefined && o.value !== null && o.value !== "")
                    filterdialog.push(o);
            });
        }

        if (this.columnSearch.length > 0) {
            for (i = 0; i < this.columnSearch.length; i++) {
                //$.each(this.columnSearch, function (i, search) {
                search = this.columnSearch[i];
                var o = new displayFilter();
                o.name = search.Column;
                o.operator = search.Operator;
                var searchobj = $.grep(this.columnSearch, function (ob) { return ob.Column === search.Column });
                if (searchobj.length === 1) {
                    if (search.Value.toString().includes("|")) {
                        $.each(search.Value.split("|"), function (j, val) {
                            if (val.trim() !== "") {
                                var o = new displayFilter();
                                o.name = search.Column;
                                o.operator = search.Operator;
                                o.value = val;
                                if (typeof search.Value.split("|")[j + 1] !== "undefined" && search.Value.split("|")[j + 1].trim() !== "")
                                    o.logicOp = "OR";
                                else if (typeof this.columnSearch[i + 1] !== "undefined")
                                    o.logicOp = "AND";
                                else
                                    o.logicOp = "";
                                columnFilter.push(o);
                            }
                        }.bind(this));
                    }
                    else {
                        o.value = search.Value;
                        if (typeof this.columnSearch[i + 1] !== "undefined")
                            o.logicOp = "AND";
                        else
                            o.logicOp = "";
                        columnFilter.push(o);
                    }
                }
                else {
                    i++;
                    o.value = searchobj[0].Value + " AND " + searchobj[1].Value;
                    o.operator = "BETWEEN";
                    if (typeof this.columnSearch[i + 1] !== "undefined")
                        o.logicOp = "AND";
                    else
                        o.logicOp = "";
                    columnFilter.push(o);
                }
            }
        }
        this.Tags = new EbTags({ "displayFilterDialogArr": filterdialog, "displayColumnSearchArr": columnFilter, "id": "#filterdisplayrowtd_" + this.tableId + "", "remove": this.closeTag });
        //this.Tags = new EbTags({ "displayFilterDialogArr": $controls, "displayColumnSearchArr": this.columnSearch, "id": "#filter_Display", "remove": this.closeTag });
    };

    this.closeTag = function (e, obj) {
        var searchObj = $.grep(this.columnSearch, function (ob) { return ob.Column === obj.name; });
        var index = this.columnSearch.findIndex(x => x.Column == obj.name);
        if (searchObj.length === 1) {
            if (searchObj[0].Value.includes("|")) {
                if (this.columnSearch[index].Value.includes(obj.value + "|"))
                    var val = this.columnSearch[index].Value.replace(obj.value + "|", "");
                else
                    var val = this.columnSearch[index].Value.replace("|" + obj.value, "");
                if (val.trim() != "")
                    this.columnSearch[index].Value = val;
                else
                    this.columnSearch.splice(index, 1);
            }
            else
                this.columnSearch.splice(index, 1);
        }
        else
            this.columnSearch.splice(index, 2);
        this.Api.ajax.reload();
    }.bind(this);

    this.matchColumnSearchAndVisible = function () {

    }

    this.getfilter = function (fltr_collection, i, data) {
        fltr_collection.push(new fltr_obj(data.Type, data.name, this.rowData[i]));
    };

    this.receiveAjaxData = function (dd) {
        if (dd.responseStatus.message !== null) {
            EbPopBox("show", { Message: dd.responseStatus.message, Title: "Error" });
        }
        this.isRun = true;
        if (this.login === "uc") {
            dvcontainerObj.currentObj.data = dd;
        }
        this.MainData = dd;
        this.RowCount = dd.recordsFiltered;
        //return dd.data;
        this.unformatedData = dd.data;
        this.Levels = dd.levels;
        this.permission = dd.permission;
        this.summary = dd.summary;
        this.tableName = dd.tableName;
        this.treeData = dd.tree;
        this.SetColumnRef();
        this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
        return dd.formattedData;
    };

    this.fixedColumnCount = function () {
        var count = this.ebSettings.LeftFixedColumn;
        var visCount = 0;
        if (count > 1) {
            $.each(this.EbObject.Columns.$values, function (i, col) {
                if (!col.bVisible) {
                    if (this.ebSettings.LeftFixedColumn > visCount)
                        count++;
                    else
                        return false;
                }
                else
                    visCount++;
            }.bind(this));
        }
        return count;
    }

    this.ColumnsComparer = function (a, b) {
        if (a.data < b.data) return -1;
        if (a.data > b.data) return 1;
        if (a.data === b.data) return 0;
    };

    this.getAgginfo = function () {
        var _ls = [];
        $.each(this.ebSettings.Columns.$values, this.getAgginfo_inner.bind(this, _ls));
        return _ls;
    };

    this.getAgginfo_inner = function (_ls, i, col) {
        if (col.bVisible && (col.RenderType == parseInt(gettypefromString("Int32")) || col.RenderType == parseInt(gettypefromString("Decimal")) || col.RenderType == parseInt(gettypefromString("Int64")) || col.RenderType == parseInt(gettypefromString("Double")) || col.RenderType == parseInt(gettypefromString("Numeric"))) && col.name !== "serial") {
            _ls.push(new Agginfo(col.name, this.ebSettings.Columns.$values[i].DecimalPlaces, col.data));
            this.NumericIndex.push(col.data);
        }
    };

    this.getFooterFromSettingsTbl = function () {
        var ftr_part = "";
        $.each(this.rowgroupCols, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        $.each(this.extraCol, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        $.each(this.ebSettings.Columns.$values, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        return "<tfoot>" + ftr_part + "</tfoot>";
    };

    this.repopulate_filter_arr = function () {
        var table = this.tableId;
        var filter_obj_arr = [];
        var api = this.Api;
        if (api !== null) {
            this.Api.columns().every(function (i) {
                var colum = api.settings().init().aoColumns[i].name;
                if (colum !== 'checkbox' && colum !== 'serial') {
                    var oper;
                    var val1, val2;
                    var textid = '#' + table + '_' + colum + '_hdr_txt1';
                    //var type = $(textid).attr('data-coltyp');
                    var type = api.settings().init().aoColumns[i].Type;
                    var Rtype = api.settings().init().aoColumns[i].RenderType;
                    if (Rtype === 3) {
                        var obj = this.EbObject.Columns.$values.find(x => x.name === colum);
                        val1 = ($(textid).is(':checked')) ? obj.TrueValue : obj.FalseValue;
                        if (!($(textid).is(':indeterminate')))
                            filter_obj_arr.push(new filter_obj(colum, "=", val1, type));
                    }
                    else {
                        oper = $('#' + table + '_' + colum + '_hdr_sel').text().trim();
                        if (api.columns(i).visible()[0]) {
                            if (oper !== '' && $(textid).val() !== '') {
                                if (oper === 'B') {
                                    val1 = $(textid).val();
                                    val2 = $(textid).siblings('input').val();
                                    if (oper === 'B' && val1 !== '' && val2 !== '') {
                                        if (Rtype === 8 || Rtype === 7 || Rtype === 11 || Rtype === 12) {
                                            filter_obj_arr.push(new filter_obj(colum, ">=", Math.min(val1, val2)));
                                            filter_obj_arr.push(new filter_obj(colum, "<=", Math.max(val1, val2), type));
                                        }
                                        else if (Rtype === 5 || Rtype === 6) {
                                            //val1 = this.changeDateOrder(val1);
                                            //val2 = this.changeDateOrder(val2);
                                            if (val2 > val1) {
                                                filter_obj_arr.push(new filter_obj(colum, ">=", val1, type));
                                                filter_obj_arr.push(new filter_obj(colum, "<=", val2, type));
                                            }
                                            else {
                                                filter_obj_arr.push(new filter_obj(colum, ">=", val2, type));
                                                filter_obj_arr.push(new filter_obj(colum, "<=", val1, type));
                                            }
                                        }
                                    }
                                }
                                else {
                                    var data = $(textid).val();
                                    filter_obj_arr.push(new filter_obj(colum, oper, data, type));
                                }
                            }
                        }
                    }
                }
            }.bind(this));
        }
        return filter_obj_arr;
    };

    this.rowCallBackFunc = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        //this.colorRow(nRow, aData, iDisplayIndex, iDisplayIndexFull);
        if (this.treeColumn) {
            let elem = aData[this.treeColumn.data].split("&nbsp;").join("").split("&emsp;").join("");
            let treeElem = $(elem);
            $(nRow).attr("data-lvl", treeElem.attr("data-level"));
            if (treeElem.hasClass("groupform")) {
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).addClass("groupform");
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).children().removeClass("groupform");
            }
            else {
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).addClass("itemform");
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).children().removeClass("itemform");
            }
        }
    };

    this.initCompleteFunc = function (settings, json) {
        this.Run = false;
        this.GenerateButtons();
        if (this.login == "uc") {
            this.initCompleteflag = true;
            //if (this.isSecondTime) { }
            //this.ModifyingDVs(dvcontainerObj.currentObj.Name, "initComplete");            
        }

        if (!this.IsTree)
            this.createFilterRowHeader();
        else
            this.createFilterforTree();
        this.filterDisplay();
        this.createFooter();
        this.arrangeWindowHeight();
        $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").show();
        $("#" + this.tableId + "_wrapper .DTFC_LeftFootWrapper").show();
        $("#" + this.tableId + "_wrapper .DTFC_RightFootWrapper").show();
        $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").style("padding-top", "100px", "important");
        $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").style("margin-top", "-100px", "important");

        this.addFilterEventListeners();
        this.arrangeFooterWidth();
        //this.arrangefixedHedaerWidth();
        this.placeFilterInText();
        //this.check4Scroll();
        this.Api.columns.adjust();

        $("#eb_common_loader").EbLoader("hide");
        //this.contextMenu4Cell();
        //this.contextMenu();
        if (this.login === "uc") {
            if (!this.EbObject.DisableCopy)
                $("#" + focusedId + " .wrapper-cont").removeClass("userselect").addClass("userselect");
            else
                $("#" + focusedId + " .wrapper-cont").removeClass("userselect");
        }
        else {
            if (!this.EbObject.DisableCopy)
                $(".wrapper-cont").removeClass("userselect").addClass("userselect");
            else
                $(" .wrapper-cont").removeClass("userselect");
        }
        this.isSecondTime = true;
    }

    this.contextMenu = function () {
        $.contextMenu({
            selector: ".tablelink",
            items: {
                "OpenNewTab": { name: "Open in New Tab", icon: "fa-external-link-square", callback: this.OpeninNewTab.bind(this) }
            }
        });
    }

    this.contextMenu4Label = function () {
        $.contextMenu({
            selector: ".labeldata",
            items: {
                "Copy": { name: "Copy", icon: "fa-external-link-square", callback: this.copyLabelData.bind(this) }
            }
        });
    }

    this.contextMenu4Cell = function () {
        var isDisable = this.EbObject.DisableCopy;
        $.contextMenu('destroy', ".tdheight");
        $.contextMenu({
            selector: ".tdheight",
            items: {
                "Copy": {
                    name: "Copy", icon: "fa-external-link-square", callback: this.copyCellData.bind(this),
                    disabled: function (key, opt) {
                        return isDisable;
                    }
                }
            }
        });

        $('.tdheight').on('contextmenu', function (e) {
            alert(1);
            e.preventDefault();
            return false;
        });
    };

    this.copyCellData = function (key, opt, event) {

    };

    this.OpeninNewTab = function (key, opt, event) {
        var cData = opt;
        this.isContextual = true;
        var idx;
        if (event !== undefined) {
            idx = this.Api.row(opt.$trigger.parent().parent()).index();
            cData = opt.$trigger.text();
        }
        else
            idx = key;

        var splitarray = this.linkDV.split("-");
        if (splitarray[2] === "3") {
            var url = "../ReportRender/BeforeRender?refid=" + this.linkDV;
            var copycelldata = cData.replace(/[^a-zA-Z ]/g, "").replace(/ /g, "_");
            if ($(`#RptModal${copycelldata}`).length !== 0)
                $(`#RptModal${copycelldata}`).remove();
            $("#parent-div0").append(`<div class="modal fade RptModal" id="RptModal${copycelldata}" role="dialog">
                <div class="modal-dialog modal-sm">
                    <div class="modal-content">
                        <div class="modal-header">
                            <button type="button" class="close" data-dismiss="modal">&times;</button>                              
                        </div>
                        <div class="modal-body"> <iframe id="reportIframe${copycelldata}" class="reportIframe" src='../ReportRender/Renderlink?refid=${this.linkDV}&_params=${btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))))}'></iframe>
            </div>
                    </div>
                </div>
            </div>
            `);
            $(`#RptModal${copycelldata}`).modal();
            $(`#reportIframe${copycelldata}`).css("height", "80vh");
            //else {
            //    $(`#RptModal${copycelldata}`).modal();
            //    $.LoadingOverlay("hide");
            //}
        }
        else if (splitarray[2] === "0") {
            let _filter = btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm))));
            let _locale = ebcontext.languages.getCurrentLocale();
            let url = `../WebForm/Index?_r=${this.linkDV}&_p=${_filter}&_m=${this.dvformMode}&_l=${ebcontext.locations.getCurrent()}&_lo=${_locale}`;
            window.open(url, '_blank');
        }
        else {
            this.tabNum++;
            let url = "../DV/dv?refid=" + this.linkDV;

            let _form = document.createElement("form");
            _form.setAttribute("method", "post");
            _form.setAttribute("action", url);
            _form.setAttribute("target", "_blank");

            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = "rowData";

            input.value = btoa(unescape(encodeURIComponent(JSON.stringify(this.rowData))));
            _form.appendChild(input);

            let input1 = document.createElement('input');
            input1.type = 'hidden';
            input1.name = "filterValues";
            input1.value = btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))));
            _form.appendChild(input1);

            let input2 = document.createElement('input');
            input2.type = 'hidden';
            input2.name = "tabNum";
            input2.value = this.tabNum;
            _form.appendChild(input2);

            document.body.appendChild(_form);

            //note I am using a post.htm page since I did not want to make double request to the page 
            //it might have some Page_Load call which might screw things up.
            //window.open("post.htm", name, windowoption);       
            _form.submit();
            document.body.removeChild(_form);
        }
    };

    this.arrangeFooterWidth = function () {
        var lfoot = $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper table');
        var rfoot = $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper table');
        var scrollfoot = $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner table');

        if (this.ebSettings.LeftFixedColumn > 0 || this.ebSettings.RightFixedColumn > 0) {
            if (this.ebSettings.LeftFixedColumn > 0) {
                for (var j = 0; j < this.ebSettings.LeftFixedColumn; j++) {
                    $(lfoot).children().find("tr").eq(0).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(0).children("th").eq(j).css("width"));
                }
            }

            if (this.ebSettings.RightFixedColumn > 0) {
                var start = scrollfoot.find("tr").eq(0).children().length - this.ebSettings.RightFixedColumn;
                for (var j = 0; (j + start) < scrollfoot.find("tr").eq(0).children().length; j++) {
                    $(rfoot).children().find("tr").eq(0).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(0).children("th").eq(j + start).css("width"));
                }
            }
        }

        $("#" + this.tableId + " thead tr:eq(1) .eb_finput").parent().remove();
    };

    this.arrangefixedHedaerWidth = function () {
        var lhead = $('#' + this.tableId + '_wrapper .DTFC_LeftHeadWrapper table');
        var rhead = $('#' + this.tableId + '_wrapper .DTFC_RightHeadWrapper table');
        var lbody = $('#' + this.tableId + '_wrapper .DTFC_LeftBodyLiner table');

        if (this.ebSettings.LeftFixedColumn > 0 || this.ebSettings.RightFixedColumn.length > 0) {
            if (this.ebSettings.LeftFixedColumn > 0) {
                for (var j = 0; j < this.ebSettings.LeftFixedColumn; j++) {
                    $(lhead).children().find("tr").eq(0).children("th").eq(j).css("width", lbody.find("tbody").children("tr").eq(0).children("td").eq(j).css("width"));
                }
            }

            if (this.ebSettings.RightFixedColumn > 0) {
                var start = lbody.find("tr").eq(0).children().length - this.ebSettings.RightFixedColumn;
                for (var j = 0; (j + start) < lbody.find("tr").eq(0).children().length; j++) {
                    $(rhead).children().find("tr").eq(0).children("th").eq(j).css("width", lbody.find("tbody").children("tr").eq(0).children("td").eq(j + start).css("width"));
                }
            }
        }


        $("#" + this.tableId + " thead tr:eq(1) .eb_finput").parent().remove();
    };

    this.placeFilterInText = function () {
        if (this.columnSearch.length > 0) {
            if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-filter"))
                $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-filter").addClass("fa-times");
        }
        else {
            if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-times"))
                $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-times").addClass("fa-filter");
        }

        this.Api.columns().every(function (i) {
            var colum = this.Api.settings().init().aoColumns[i].name;
            var colObj = $.grep(this.columnSearch, function (obj) { return obj.Column === colum; });

            var textid = '#' + this.tableId + '_' + colum + '_hdr_txt1';
            if (colum !== 'checkbox' && colum !== 'serial' && colObj.length > 0) {
                var oper;
                var val1, val2;
                var type = $(textid).attr('data-coltyp');
                if (type === 'boolean') {
                    if (colObj.Value === "true")
                        $(textid).attr("checked", true);
                    else if (colObj.Value === "false")
                        $(textid).attr("checked", false);
                    else
                        $(textid).attr("indeterminate", true);
                }
                else {
                    if (this.Api.columns(i).visible()[0]) {
                        if (colObj[0].Operator !== '' && colObj[0].Value !== '') {
                            if (colObj.length === 2) {
                                //$('#' + this.tableId + '_' + colum + '_hdr_sel').text("B");
                                //if (type === "date")
                                //    $(textid).val(this.retainDateOrder(colObj[0].Value));
                                //else
                                $(textid).val(colObj[0].Value);
                                $(".eb_fsel" + this.tableId + "[data-colum=" + colum + "]").trigger("click");
                                //if (type === "date")
                                //    $(textid).siblings('input').val(this.retainDateOrder(colObj[1].Value));
                                //else
                                $(textid).siblings('input').val(colObj[1].Value);
                            }
                            else {
                                //if (type === "date")
                                //    $(textid).val(this.retainDateOrder(colObj[0].Value));
                                //else
                                $(textid).val(colObj[0].Value);
                                $('#' + this.tableId + '_' + colum + '_hdr_sel').text(colObj[0].Operator);
                            }
                        }
                    }
                }
            }
            else {
                if ($(textid).attr("type") === "checkbox")
                    $(textid).prop('indeterminate', true);
                else {
                    $(textid).val("");
                    if ($(textid).next().length === 1)
                        $(textid).next().val("");
                }
            }
        }.bind(this));
        //}
    }

    this.check4Scroll = function () {
        var scrollBody = $('#' + this.tableId + '_wrapper .dataTables_scrollBody');
        if (scrollBody[0].scrollHeight > scrollBody.height()) {
            scrollBody.children().css("width", "110%");
            scrollBody.siblings(".dataTables_scrollFoot").style("width", "98.65%", "important");
        }
        else {
            scrollBody.children().css("width", "100%");
            scrollBody.siblings(".dataTables_scrollFoot").style("width", "100%", "important");
        }

    };

    this.arrangeWindowHeight = function () {
        var filterId = "#filterdisplayrowtd_" + this.tableId;
        if (this.login === "uc") {
            if (this.IsTree) {
                $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 52px)", "important");
            }
            else if ($(filterId).children().length === 0 && !this.ebSettings.IsPaging && !this.EbObject.AllowMultilineHeader)
                $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 62px)", "important");
            else {
                if ($(filterId).children().length === 0 && !this.ebSettings.IsPaging && this.EbObject.AllowMultilineHeader) {//multilineonly
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 79px)", "important");
                }
                else if ($(filterId).children().length === 0 && this.ebSettings.IsPaging && !this.EbObject.AllowMultilineHeader) {//pagingonly
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 88px)", "important");
                }
                else if ($(filterId).children().length !== 0 && !this.ebSettings.IsPaging && !this.EbObject.AllowMultilineHeader) {//filteronly
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 86px)", "important");
                }
                else if ($(filterId).children().length === 0 && this.ebSettings.IsPaging && this.EbObject.AllowMultilineHeader) {//paging & multiline
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 104px)", "important");
                }
                else if ($(filterId).children().length !== 0 && !this.ebSettings.IsPaging && this.EbObject.AllowMultilineHeader) {//filter & multiline
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 102px)", "important");
                }
                else if ($(filterId).children().length !== 0 && this.ebSettings.IsPaging && !this.EbObject.AllowMultilineHeader) {//filetr & paging
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 112px)", "important");
                }
                else {
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 127px)", "important");//filter && paging & multiline
                }
            }
            //this.stickBtn.$stickBtn.css("top", "46px");
        }
        else {
            $(".dv-body2").style("height", "calc( 100vh - 38px )", "important");
            if (this.tabNum !== 0) {
                $("#sub_window_" + this.tableId).style("height", "calc(100vh - 40px)", "important");
                if ($(filterId).children().length === 0 && !this.ebSettings.IsPaging)
                    $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 40px)", "important");
                else {
                    if ($(filterId).children().length === 0)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 55px)", "important");
                    else if (!this.ebSettings.IsPaging)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 58px)", "important");
                    else
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 90px)", "important");
                }
            }
            else {
                if (this.IsTree)
                    $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 32px)", "important");
                else if ($(filterId).children().length === 0 && !this.ebSettings.IsPaging)
                    $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 42px)", "important");
                else {
                    if ($(filterId).children().length === 0)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 68px)", "important");
                    else if (!this.ebSettings.IsPaging)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 65px)", "important");
                    else
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 93px)", "important");
                }
            }
        }
    }

    this.copyLabelData = function (key, opt, event) {

    }

    this.ModifyingDVs = function (parentName, source) {
        $.each(dvcontainerObj.dvcol, function (key, obj) {
            if (parentName === obj.EbObject.Pippedfrom) {
                if (obj.EbObject.$type.indexOf("EbChartVisualization") !== -1 || obj.EbObject.$type.indexOf("EbGoogleMap") !== -1) {
                    dvcontainerObj.dvcol[key].EbObject.data = dvcontainerObj.currentObj.data;
                    dvcontainerObj.dvcol[key].drawGraphHelper(this.Api.data());
                    this.ModifyingDVs(dvcontainerObj.dvcol[key].EbObject.Name, "draw");
                }
                else {
                    if (source === "draw") {
                        dvcontainerObj.dvcol[key].modifyDVFlag = true;
                        dvcontainerObj.dvcol[key].Api.clear().rows.add(this.Api.data());
                        dvcontainerObj.dvcol[key].EbObject.data = dvcontainerObj.currentObj.data;
                        dvcontainerObj.dvcol[key].Api.columns.adjust().draw();
                        this.ModifyingDVs(dvcontainerObj.dvcol[key].EbObject.Name, "draw");
                    }
                }
            }
        }.bind(this));
    }

    this.drawCallBackFunc = function (settings) {
        $('tbody [data-toggle=toggle]').bootstrapToggle();
        if (this.EbObject.RowGroupCollection.$values.length > 0)
            this.doRowgrouping();
        if (this.login === "uc" && !this.modifyDVFlag && this.initCompleteflag) {
            //this.ModifyingDVs(dvcontainerObj.currentObj.Name, "draw");
        }
        if (this.isSecondTime) {
            //if (this.columnSearch.length > 0)
            this.filterDisplay();
            this.addFilterEventListeners();
            this.placeFilterInText();
            //this.arrangefixedHedaerWidth();
            this.summarize2();
            this.arrangeWindowHeight();
        }
        this.Api.columns.adjust();
    };

    this.selectCallbackFunc = function (e, dt, type, indexes) {
    };

    this.clickCallbackFunc = function (e) {
    };

    this.dblclickCallbackFunc = function (e) {
    };

    this.rowGroupHandler = function (e) {
        this.orderColl = [];
        let name = $(e.target).val().trim();
        if (!(name === "None")) {
            this.EbObject.DisableRowGrouping = false;
            $.each(this.EbObject.RowGroupCollection.$values, function (i, obj) {
                if (obj.Name === name) {
                    this.CurrentRowGroup = jQuery.extend({}, obj);
                    this.getColumnsSuccess(e);
                }
            }.bind(this));
        }
        else {
            this.EbObject.DisableRowGrouping = true;
            this.getColumnsSuccess();
        }
    };

    this.visibilityCheck = function () {
        this.RGIndex = [];
        this.ebSettings.LeftFixedColumn = 0;
        this.ebSettings.RightFixedColumn = 0;
        this.rowgroupCols = [];
        let visibleChanges = false;
        $.each(this.CurrentRowGroup.RowGrouping.$values, function (i, rgobj) {
            this.RGIndex.push(rgobj.data);
            this.rowgroupCols.unshift(JSON.parse('{ "searchable": false, "orderable": false, "bVisible":true, "data":null, "defaultContent": ""}'));
        }.bind(this));

        if (this.rowgroupCols.length > 0 && this.CurrentRowGroup.$type.indexOf("MultipleLevelRowGroup") !== -1)
            this.rowgroupCols.unshift(JSON.parse('{ "searchable": false, "orderable": false, "bVisible":true, "name":"AllGroup", "data":null, "defaultContent": ""}'));

        $.each(this.EbObject.Columns.$values, function (i, colobj) {
            visibleChanges = false;
            $.each(this.CurrentRowGroup.RowGrouping.$values, function (i, rgobj) {
                if (colobj.name === rgobj.name) {
                    colobj.bVisible = false;
                    visibleChanges = true;
                }
            }.bind(this));

            $.each(this.EbObject.NotVisibleColumns.$values, function (i, nonvis) {
                if (colobj.name === nonvis.name) {
                    colobj.bVisible = false;
                    visibleChanges = true;
                }
            }.bind(this));

            if (!visibleChanges)
                colobj.bVisible = true;
            if (colobj.name === "id")
                colobj.bVisible = false;
        }.bind(this));

    }

    this.doRowgrouping = function () {
        var rows = this.Api.rows().nodes();
        var count = this.Api.columns()[0].length;
        $(rows).eq(0).before(`<tr class='group-All' id='group-All_${this.tableId}'></tr>`);
        $(`#group-All_${this.tableId}`).append(`<td  colspan="${count}"><select id="rowgroupDD_${this.tableId}" class="rowgroupselect"></select></td>`);
        $.each(this.EbObject.RowGroupCollection.$values, function (i, obj) {
            if (obj.RowGrouping.$values.length > 0) {
                $(`#rowgroupDD_${this.tableId}`).append(`<option value="${obj.Name.trim()}">${obj.DisplayName}</option>`);
            }
        }.bind(this));
        $(`#rowgroupDD_${this.tableId}`).append(`<option value="None">None</option>`);
        $(`#rowgroupDD_${this.tableId}`).off("change").on("change", this.rowGroupHandler.bind(this));
        if (this.CurrentRowGroup !== null) {
            $(`#group-All_${this.tableId}`).prepend(`<td><i class='fa fa-minus-square-o' style='cursor:pointer;'></i></td>`);
            $(`#rowgroupDD_${this.tableId} [value=${this.CurrentRowGroup.Name.trim()}]`).attr("selected", "selected");

            rows = this.Api.rows().nodes();
            $.each(this.Levels, function (i, obj) {
                if (obj.insertionType !== "After")
                    $(rows).eq(obj.rowIndex).before(obj.html);
                else
                    $(rows).eq(obj.rowIndex).after(obj.html);
            });
            var ct = $("#" + this.tableId + " .group[group=1]").length;
            $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` Groups (${ct}) - `);

            $("#" + this.tableId + " tbody").off("click", "tr.group").on("click", "tr.group", this.collapseGroup);
            $("#" + this.tableId + " tbody").off("click", "tr.group-All").on("click", "tr.group-All", this.collapseAllGroup);
        }
        else {
            $(`#rowgroupDD_${this.tableId} [value=None`).attr("selected", "selected");
            $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` Groups `);
        }
    };

    this.singlelevelRowgrouping = function () {
        var rows = this.Api.rows().nodes();
        var rowsdata = this.Api.rows().data();
        var index = this.RGIndex;
        var count = this.Api.columns()[0].length;
        var lastrow = -1;
        var last = null;
        var colobj = {};
        var groupString = "";
        var groupArray = [];
        this.rowgroupFilter = [];
        $.each(this.NumericIndex, function (k, num) {
            if (!(num in colobj)) {
                colobj[num] = new Array();
            }
        });

        $.each(this.unformatedData, function (i, _dataArray) {
            groupString = "";
            groupArray = []
            $.each(index, function (j, dt) {
                groupArray.push((_dataArray[dt].trim() === "") ? "(Blank)" : _dataArray[dt].trim());
                groupString += (_dataArray[dt].trim() === "") ? "(Blank)" : _dataArray[dt].trim();
                if (typeof index[j + 1] !== "undefined")
                    groupString += ",";
            }.bind(this));

            if (last !== groupString) {
                if (last === null || Object.keys(colobj).length === 0)
                    $(rows).eq(i).before(this.getGroupRowSingle(count, groupArray));
                else {
                    var rowstring = this.getSubRow(colobj, groupString, count);
                    $(rows).eq(i).before(rowstring);
                    $(rows).eq(i).before(this.getGroupRowSingle(count, groupArray));
                }
                last = groupString;
                $.each(colobj, function (key, val) {
                    colobj[key] = [];
                    colobj[key].push(_dataArray[key]);
                });
            }
            else {
                $.each(colobj, function (key, val) {
                    colobj[key].push(_dataArray[key]);
                });
            }
            lastrow = i;
        }.bind(this));

        if (Object.keys(colobj).length !== 0 && ($(rows).eq(lastrow).hasClass("odd") || $(rows).eq(lastrow).hasClass("even"))) {
            var rowstring = this.getSubRow(colobj, groupString, count);
            $(rows).eq(lastrow).after(rowstring);
        }

        var ct = $(".group[group=0]").length;
        $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` All Groups (${ct}) - `);
        this.getRowsCount(count, "single");
    }

    this.getGroupRowSingle = function (count, groupArray) {
        var str = "<tr class='group' group='0'><td> &nbsp;</td>";
        var tempstr = "";
        $.each(this.RGIndex, function (j, dt) {
            var tempobj = $.grep(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (obj) { return dt === obj.data });
            var type = tempobj[0].Type;
            //if (type === 5 || type === 6) {
            //    groupArray[j] = this.renderDateformat(groupArray[j], "/");
            //}
            if (tempobj[0].LinkRefId !== null)
                tempstr += tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupArray[j]}'><a href="#" oncontextmenu="return false" class="tablelink" data-colindex="${tempobj[0].data}" data-link="${tempobj[0].LinkRefId}" tabindex="0">${groupArray[j]}</a></b>`;
            else
                tempstr += tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupArray[j]}'>${groupArray[j]}</b>`;

            if (typeof this.RGIndex[j + 1] !== "undefined")
                tempstr += ",";
        }.bind(this));

        //$.each(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (k, obj) {
        str += "<td><i class='fa fa-minus-square-o' style='cursor:pointer;'></i></td><td colspan=" + count + ">" + tempstr + "</td></tr>";
        //});
        return str;
    }.bind(this);

    this.getGroupRow = function (count, groupString, rowgroup, dt) {
        var str = "<tr class='group' group='" + rowgroup + "'>";
        for (var i = 0; i <= rowgroup; i++)
            str += "<td> &nbsp;</td>";

        var tempobj = $.grep(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (obj) { return dt === obj.data });
        var type = tempobj[0].Type;
        //if (type === 5 || type === 6) {
        //    groupArray[j] = this.renderDateformat(groupArray[j], "/");
        //}
        if (tempobj[0].LinkRefId !== null)
            var tempstr = tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupString}'><a href="#" oncontextmenu="return false" class="tablelink" data-colindex="${tempobj[0].data}" data-link="${tempobj[0].LinkRefId}" tabindex="0">${groupString}</a></b>`;
        else
            var tempstr = tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupString}'>${groupString}</b>`;
        str += "<td><i class='fa fa-minus-square-o' style='cursor:pointer;'></i></td><td colspan=" + count + ">" + tempstr + "</td></tr>";
        return str;
    }.bind(this);

    this.getSubRow = function (colobj, groupString, count, rowgroup) {
        var i = 0;
        rowgroup = (typeof rowgroup === "undefined") ? 0 : rowgroup;
        var str = "<tr class='group-sum' group='" + rowgroup + "'>";
        $.each(this.rowgroupCols, function (k, obj) {
            str += "<td>&nbsp;</td>";
        });
        $.each(this.extraCol, function (k, obj) {
            if (obj.bVisible)
                str += "<td>&nbsp;</td>";
        });
        $.each(this.EbObject.Columns.$values, function (k, obj) {
            if (obj.bVisible) {
                if (Object.keys(colobj).contains(k.toString()) && obj.Aggregate) {
                    var val = colobj[k];
                    if (val.length === 1)
                        val.push("0");
                    str += "<td class='dt-body-right'>" + getSum(val).toFixed(obj.DecimalPlaces) + "</td>";// + "," + getAverage(val).toFixed(2)+
                }
                else
                    str += "<td>&nbsp;</td>";
            }
        });
        return str + "</tr>";
    };

    this.collapseAllGroup = function (e) {
        if (!$(e.target).is("select")) {
            var $elems = $(e.target).parents().closest(".group-All").nextAll("[role=row]");
            var $Groups = $(e.target).parents().closest(".group-All").nextAll(".group")
            var $target = $(e.target);
            if ($target.is("td")) {
                if ($target.children().is("I"))
                    $target = $target.children("I");
                else if ($target.siblings().children().is("I"))
                    $target = $target.siblings().children("I");
            }
            if ($target.hasClass("fa-plus-square-o")) {
                $elems.show();
                $(".group").show();
                $(".group-sum").show();
                this.collapseRelated($target, "show");
                $Groups.children().find("I").removeAttr("class").attr("class", "fa fa-minus-square-o");
            }
            else {
                $elems.hide();
                this.collapseRelated($target, "hide");
                $Groups.children().find("I").removeAttr("class").attr("class", "fa fa-plus-square-o");
            }
            this.Api.columns.adjust();
        }

        $(".containerrow").hide();
        $(".containerrow").prev().children().find("I").removeClass("fa-caret-up").addClass("fa-caret-down");
    }.bind(this);

    this.collapseGroup = function (e) {
        var $group = $(e.target).parents().closest(".group");
        var groupnum = $group.attr("group");
        var $elems = $group.nextUntil("[group=" + groupnum + "]");

        if ($elems.css("display") === "none") {
            $elems.show();
            this.collapseRelated($(e.target), "show");
            $elems.filter(".group").children().find("I").removeAttr("class").attr("class", "fa fa-minus-square-o");
        }
        else {
            $elems.hide();
            this.collapseRelated($(e.target), "hide");
            $elems.filter(".group").children().find("I").removeAttr("class").attr("class", "fa fa-plus-square-o");
        }
        this.checkHeaderCollapse($group, groupnum);

        $(".containerrow").hide();
        $(".containerrow").prev().children().find("I").removeClass("fa-caret-up").addClass("fa-caret-down");
        this.Api.columns.adjust();
    }.bind(this);

    this.collapseRelated = function ($elem, type) {
        if ($elem.is("td")) {
            if ($elem.children().is("I"))
                $elem = $elem.children("I");
            else if ($elem.siblings().children().is("I"))
                $elem = $elem.siblings().children("I");
        }
        else if ($elem.is("b")) {
            $elem = $elem.closest("td").prev().children("I");
        }

        if (type === "show") {
            $elem.removeClass("fa-plus-square-o");
            $elem.addClass("fa-minus-square-o");
        }
        else {
            $elem.removeClass("fa-minus-square-o");
            $elem.addClass("fa-plus-square-o");
        }

    }

    this.checkHeaderCollapse = function ($group, groupnum) {
        var headergroup = parseInt(groupnum) - 1;
        var nextSiblings = $group.nextUntil("[group=" + headergroup + "]").filter(".group[group=" + groupnum + "]").next();
        var prevSiblings = $group.prevUntil("[group=" + headergroup + "]").filter(".group[group=" + groupnum + "]").next();
        var $ElemtoChange = $group.prevAll(".group[group=" + headergroup + "]").first().children().find("I");
        var nextproperty = nextSiblings.map(function () { return $(this).css("display"); }).get();
        var prevproperty = prevSiblings.map(function () { return $(this).css("display"); }).get();
        var property = nextproperty.concat(prevproperty);
        if (property.contains("none")) {
            var flag = property.every(function (value) {
                return value === property[0];
            });
            if (flag)
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-plus-square-o");
            else
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-minus-square-o");
        }
        else if (property.length === 0) {
            if ($group.nextUntil("[group=" + headergroup + "]").css("display") === "none")
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-plus-square-o");
            else
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-minus-square-o");
        }
        else
            $ElemtoChange.removeAttr("class").attr("class", "fa fa-minus-square-o");
    };

    this.multiplelevelRowgrouping = function () {
        var rows = this.Api.rows().nodes();
        var rowsdata = this.Api.rows().data();
        var index = this.RGIndex;
        var count = this.Api.columns()[0].length;
        var lastrow = -1;
        var last = null;
        var colobj = {};
        var groupString = "";
        var groupcount = 0;
        this.rowgroupFilter = [];
        $.each(this.NumericIndex, function (k, num) {
            if (!(num in colobj)) {
                colobj[num] = new Array();
            }
        });

        $.each(index, function (j, dt) {
            var last = null;
            var $parent = null;
            var $count = 0;
            //var tempobj = $.grep(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (obj) { return dt === obj.data });//tempobj[0].sTitle + " : " +
            $.each(this.unformatedData, function (i, _dataArray) {

                var te = (_dataArray[dt] === null || _dataArray[dt].trim() === "") ? "(Blank)" : _dataArray[dt].trim();
                groupString = te;

                if (last !== groupString) {
                    if (last === null || Object.keys(colobj).length === 0) {
                        var groupstr = this.getGroupRow(count, groupString, j, dt);
                        $(rows).eq(i).before(groupstr);
                        $count++;
                        $parent = $(groupstr);
                    }
                    else {
                        $parent
                        var rowstring = this.getSubRow(colobj, groupString, count, j);
                        $(rows).eq(i - 1).after(rowstring);
                        $(rows).eq(i).before(this.getGroupRow(count, groupString, j, dt));
                    }
                    last = groupString;
                    $.each(colobj, function (key, val) {
                        colobj[key] = [];
                        colobj[key].push(_dataArray[key]);
                    });
                }
                else {
                    $.each(colobj, function (key, val) {
                        colobj[key].push(_dataArray[key]);
                    });
                    $count++;
                }
                lastrow = i;
            }.bind(this));

            if (Object.keys(colobj).length !== 0 && ($(rows).eq(lastrow).hasClass("odd") || $(rows).eq(lastrow).hasClass("even"))) {
                var rowstring = this.getSubRow(colobj, groupString, count, j);
                $(rows).eq(lastrow).after(rowstring);
            }

        }.bind(this));

        var ct = $(".group[group=0]").length;
        $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(`All Groups (${ct}) - `);
        this.getRowsCount(count, "multiple");
    }

    this.getRowsCount = function (count, type) {
        let rows = $("#" + this.tableId + " tbody tr.group[group=0]");
        var j = 0;
        this.recursiveRowCount(rows, j, count, type);
    }

    this.recursiveRowCount = function (rows, j, count, type) {
        $.each(rows, function (i, elem) {
            if (typeof (this.RGIndex[j + 1]) === "undefined")
                $(elem).children("td[colspan=" + count + "]").children("b").last().append(" (" + $(elem).nextUntil("[group=" + j + "]").length + ")");
            else {
                if (type === "single")
                    $(elem).children("td[colspan=" + count + "]").children("b").last().append(" (" + $(elem).nextUntil("[group=" + j + "]").length + ")");
                else
                    $(elem).children("td[colspan=" + count + "]").children("b").last().append(" (" + $(elem).nextUntil(".group[group=" + (j) + "]").filter(".group").length + ")");

            }
        }.bind(this));
        if (typeof (this.RGIndex[j + 1]) !== "undefined" && type !== "single") {
            var rowsarray = $("#" + this.tableId + " tbody tr.group[group=" + (j + 1) + "]");
            this.recursiveRowCount(rowsarray, (j + 1), count, type);
        }
    }

    this.doSerial = function () {
        var tempobj = $.grep(this.extraCol, function (obj) { return obj.name === "serial" });
        var index = this.Api.columns(tempobj[0].name + ':name').indexes()[0]
        this.Api.column(index).nodes().each(function (cell, i) { cell.innerHTML = i + 1; });
        this.Api.columns.adjust();
    };

    this.createFooter = function () {
        var ps = 0;
        var tid = this.tableId;
        var aggFlag = false;
        var lfoot = $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper table');
        var rfoot = $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper table');
        var scrollfoot = $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner table');

        if (scrollfoot.length !== 0)
            var eb_footer_controls_scrollfoot = this.GetAggregateControls(ps, 1);

        if (this.ebSettings.LeftFixedColumn + this.ebSettings.RightFixedColumn > 0) {
            for (var j = 0; j < eb_footer_controls_scrollfoot.length; j++) {
                if (j < this.ebSettings.LeftFixedColumn) {
                    scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_scrollfoot[j]);
                    scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).children().remove();
                }
                else {
                    if (j < eb_footer_controls_scrollfoot.length - this.ebSettings.RightFixedColumn)
                        scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_scrollfoot[j]);
                    else {
                        scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_scrollfoot[j]);
                        scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).children().remove();
                    }
                }
            }
        }
        else {
            for (var j = 0; j < eb_footer_controls_scrollfoot.length; j++)
                scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).append(eb_footer_controls_scrollfoot[j]);
        }


        if (lfoot.length !== 0 || rfoot.length !== 0) {
            var eb_footer_controls_lfoot = this.GetAggregateControls(ps, 50);
            if (lfoot.length !== 0) {
                for (var j = 0; j < this.ebSettings.LeftFixedColumn; j++) {
                    $(lfoot).children().find("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_lfoot[j]);
                    if (j === 0)
                        $(lfoot).children().find("tr").eq(ps).children("th").eq(j).html("");
                    $(lfoot).children().find("tr").eq(ps).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).css("width"));
                }
            }

            if (rfoot.length !== 0) {
                var start = eb_footer_controls_lfoot.length - this.ebSettings.RightFixedColumn;
                for (var j = 0; (j + start) < eb_footer_controls_lfoot.length; j++) {
                    $(rfoot).children().find("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_lfoot[j + start]);
                    $(rfoot).children().find("tr").eq(ps).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j + start).css("width"));
                }
            }
        }
        this.summarize2();
    };

    this.GetAggregateControls = function (footer_id, zidx) {
        var ScrollY = this.ebSettings.scrollY;
        var ResArray = [];
        var tableId = this.tableId;
        //$.each(this.ebSettings.Columns.$values, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        $.each(this.Api.settings().init().aoColumns, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        return ResArray;
    };

    this.GetAggregateControls_inner = function (ResArray, footer_id, zidx, i, col) {
        var _ls;
        if (col.bVisible) {
            var temp = $.grep(this.eb_agginfo, function (agg) { return agg.colname === col.name });
            //(col.Type ==parseInt( gettypefromString("Int32")) || col.Type ==parseInt( gettypefromString("Decimal")) || col.Type ==parseInt( gettypefromString("Int64")) || col.Type ==parseInt( gettypefromString("Double"))) && col.name !== "serial"
            if (col.Aggregate) {
                var footer_select_id = this.tableId + "_" + col.name + "_ftr_sel" + footer_id;
                var fselect_class = this.tableId + "_fselect";
                var data_colum = "data-column=" + col.name;
                var data_table = "data-table=" + this.tableId;
                var footer_txt = this.tableId + "_" + col.name + "_ftr_txt" + footer_id;
                var data_decip = "data-decip=" + this.Api.settings().init().aoColumns[i].DecimalPlaces;
                var style = "";
                if (col.Align.toString() === EbEnums.Align.Left)
                    style = "text-align: left;";
                else if (col.Align.toString() === EbEnums.Align.Right || col.Align.toString() === EbEnums.Align.Auto)
                    style = "text-align: right;";
                else
                    style = "text-align: center;";

                _ls = "<div class='input-group input-group-sm'>" +
                    "<div class='input-group-btn dropup'>" +
                    "<button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + footer_select_id + "'>&sum;</button>" +
                    " <ul class='dropdown-menu'>" +
                    "  <li class='footerli'><a href ='#' class='eb_ftsel" + this.tableId + "' data-sum='Sum' " + data_table + " " + data_colum + " " + data_decip + "> &sum; </a><span class='footertext eb_ftsel" + this.tableId + "'>Sum</span></li>" +
                    "  <li class='footerli'><a href ='#' class='eb_ftsel" + this.tableId + "' " + data_table + " " + data_colum + " " + data_decip + " {4}> x&#772; </a><span class='footertext eb_ftsel" + this.tableId + "'>Average</span></li>" +
                    " </ul>" +
                    " </div>" +
                    " <input type='text' class='form-control' id='" + footer_txt + "' disabled style='z-index:" + zidx.toString() + ";" + style + "'>" +
                    " </div>";
            }
            else
                _ls = "&nbsp;";

            ResArray.push(_ls);
        }
    };

    this.summarize2 = function () {
        var api = this.Api;
        var tableId = this.tableId;
        var scrollY = this.ebSettings.scrollY;
        var opScroll;
        var ftrtxtScroll;
        $.each(this.eb_agginfo, function (index, agginfo) {
            if (agginfo.colname) {
                opScroll = $('.dataTables_scrollFootInner #' + tableId + '_' + agginfo.colname + '_ftr_sel0').text().trim();
                ftrtxtScroll = '.dataTables_scrollFootInner #' + tableId + '_' + agginfo.colname + '_ftr_txt0';

                opLF = $('.DTFC_LeftFootWrapper #' + tableId + '_' + agginfo.colname + '_ftr_sel0').text().trim();
                ftrtxtLF = '.DTFC_LeftFootWrapper #' + tableId + '_' + agginfo.colname + '_ftr_txt0';

                opRF = $('.DTFC_RightFootWrapper #' + tableId + '_' + agginfo.colname + '_ftr_sel0').text().trim();
                ftrtxtRF = '.DTFC_RightFootWrapper #' + tableId + '_' + agginfo.colname + '_ftr_txt0';

                var col = api.column(agginfo.colname + ':name');
                var summary_val = 0;

                if (opScroll === '' || opLF === '' || opRF === '')
                    summary_val = (typeof this.summary[agginfo.data] !== "undefined") ? this.summary[agginfo.data][0] : 0;
                if (opScroll === 'x' || opLF === 'x' || opRF === 'x') {
                    summary_val = (typeof this.summary[agginfo.data] !== "undefined") ? this.summary[agginfo.data][1] : 0;
                }
                if (opScroll !== "")
                    $(ftrtxtScroll).val(summary_val);
                if (opLF !== "")
                    $(ftrtxtLF).val(summary_val);
                if (opRF !== "")
                    $(ftrtxtRF).val(summary_val);
            }
        }.bind(this));
    };

    this.createFilterRowHeader = function () {
        var tableid = this.tableId;
        var order_info_ref = this.order_info;

        var fc_lh_tbl = $('#' + tableid + '_wrapper .DTFC_LeftHeadWrapper table');
        var fc_rh_tbl = $('#' + tableid + '_wrapper .DTFC_RightHeadWrapper table');

        if (fc_lh_tbl.length !== 0 || fc_rh_tbl.length !== 0) {
            this.GetFiltersFromSettingsTbl(50);
            if (fc_lh_tbl.length !== 0) {
                fc_lh_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
                for (var j = 0; j < this.ebSettings.LeftFixedColumn; j++)
                    $(fc_lh_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4fc[j]));
            }
            if (fc_rh_tbl.length !== 0) {
                fc_rh_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
                for (var j = this.eb_filter_controls_4fc.length - this.ebSettings.RightFixedColumn; j < this.eb_filter_controls_4fc.length; j++)
                    $(fc_rh_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4fc[j]));
            }
        }

        var sc_h_tbl = $('#' + tableid + '_wrapper .dataTables_scrollHeadInner table');
        if (sc_h_tbl !== null) {
            this.GetFiltersFromSettingsTbl(1);
            sc_h_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
            if (this.ebSettings.LeftFixedColumn + this.ebSettings.RightFixedColumn > 0) {
                for (var j = 0; j < this.eb_filter_controls_4sb.length; j++) {
                    if (j < this.ebSettings.LeftFixedColumn) {
                        $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                        $(sc_h_tbl.find("tr[class=addedbyeb] th:eq(" + j + ")")).children().not("span").remove();
                    }
                    else {
                        if (j < this.eb_filter_controls_4sb.length - this.ebSettings.RightFixedColumn)
                            $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                        else {
                            $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                            $(sc_h_tbl.find("tr[class=addedbyeb] th:eq(" + j + ")")).children().not("span").remove();
                        }
                    }
                }
            }
            else {
                for (var j = 0; j < this.eb_filter_controls_4sb.length; j++)
                    $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
            }
            sc_h_tbl.find("thead .addedbyeb").before($("<tr role='row' id='filterdisplayrow_" + this.tableId + "' class='filterdisplayrow'><td id='filterdisplayrowtd_" + this.tableId + "' colspan=" + this.columnCount + " style='padding: 2px!important;'></td></tr>"));
        }

        // $('#' + tableid + '_wrapper table thead tr[class=addedbyeb]').hide();

        //$('thead:eq(0) tr:eq(1) [type=checkbox]').prop('indeterminate', true);
        $(".addedbyeb [type=checkbox]").prop('indeterminate', true);
        $(".DTFC_Blocker").remove();
    };

    this.createColspanHeader = function () {

    };

    this.createFilterforTree = function () {
        $(".dataTables_info").after(`<div id="${this.tableId}_filter" class="dataTables_filters">
        <label>Search:<input type="search" class="form-control input-sm" placeholder="" aria-controls="${this.tableId}"></label></div>`);
        $(`#${this.tableId}_filter input`).off("keyup").on("keyup", this.LocalSearch.bind(this));
    };

    this.LocalSearch = function (e) {
        var text = $(e.target).val();
        if (e.keyCode === 13 && text.length > 3) {
            //window.find(text, false, false, true);
            if (window.find && window.getSelection) {
                document.designMode = "on";
                var sel = window.getSelection();
                sel.collapse(document.body, 0);

                while (window.find(text)) {
                    document.execCommand("HiliteColor", false, "yellow");
                    sel.collapseToEnd();
                }
                document.designMode = "off";
            }
        }
    };

    this.addFilterEventListeners = function () {
        $('#' + this.tableId + '_wrapper thead tr:eq(0)').off('click').on('click', 'th', this.orderingEvent.bind(this));
        $(".eb_fsel" + this.tableId).off("click").on("click", this.setLiValue.bind(this));
        $(".eb_ftsel" + this.tableId).off("click").on("click", this.fselect_func.bind(this));
        $.each($(this.Api.columns().header()).parent().siblings().children().toArray(), this.setFilterboxValue.bind(this));
        $("." + this.tableId + "_htext").off("keyup").on("keyup", this.call_filter);
        $(".eb_fbool" + this.tableId).off("change").on("change", this.toggleInFilter.bind(this));
        $(".eb_selall" + this.tableId).off("click").on("click", this.clickAlSlct.bind(this));
        $("." + this.tableId + "_select").off("change").on("change", this.updateAlSlct.bind(this));
        $(".eb_canvas" + this.tableId).off("click").on("click", this.renderMainGraph);
        $(".tablelink").off("click").on("click", this.link2NewTable.bind(this));
        //$(`tablelinkInline_${this.tableId}`).off("click").on("click", this.link2NewTableInline.bind(this));
        //$(".tablelink_" + this.tableId).off("mousedown").on("mousedown", this.link2NewTableInNewTab.bind(this));
        $(".closeTab").off("click").on("click", this.deleteTab.bind(this));


        this.Api.on('key-focus', function (e, datatable, cell) {
            datatable.rows().deselect();
            datatable.row(cell.index().row).select();
        });

        //this.filterbtn.off("click").on("click", this.showOrHideFilter.bind(this));
        $("#clearfilterbtn_" + this.tableId).off("click").on("click", this.clearFilter.bind(this));
        //$("#" + this.tableId + "_btntotalpage").off("click").on("click", this.showOrHideAggrControl.bind(this));
        this.copybtn.off("click").on("click", this.CopyToClipboard.bind(this));
        this.printbtn.off("click").on("click", this.ExportToPrint.bind(this));
        //this.printAllbtn.off("click").on("click", this.printAll.bind(this));
        this.printSelectedbtn.off("click").on("click", this.printSelected.bind(this));
        $("#btnExcel" + this.tableId).off("click").on("click", this.ExportToExcel.bind(this));
        this.csvbtn.off("click").on("click", this.ExportToCsv.bind(this));
        this.pdfbtn.off("click").on("click", this.ExportToPdf.bind(this));
        $("#btnToggleFD" + this.tableId).off("click").on("click", this.toggleFilterdialog.bind(this));
        $(".columnMarker_" + this.tableId).off("click").on("click", this.link2NewTable.bind(this));
        $(".columnimage").off("click").on("click", this.ViewImage.bind(this));
        $('[data-toggle="tooltip"],[data-toggle-second="tooltip"]').tooltip({
            placement: 'bottom'
        });
        $('.columntooltip').popover({
            container: 'body',
            trigger: 'hover',
            placement: this.PopoverPlacement,
            html: true,
            content: function (e, i) {
                return atob($(this).attr("data-contents"));
            },
        });
        //$('.columntooltip').on('shown.bs.popover', this.openColumnTooltip.bind(this));

        $("[data-coltyp=date]").datepicker({
            dateFormat: this.datePattern.replace(new RegExp("M", 'g'), "m").replace(new RegExp("yy", 'g'), "y"),
            beforeShow: function (elem, obj) {
                $(".ui-datepicker").addClass("datecolumn-picker");
            }
        });
        $("[data-coltyp=date]").on("click", function () {
            $(this).datepicker("show");
        });
        //$("#switch" + this.tableId).off("click").on("click", this.SwitchToChart.bind(this));
        this.Api.columns.adjust();
    };

    this.ViewImage = function (e) {
        let data = $(e.target).attr("src");
        let loader = "data:image/gif;base64,R0lGODlhAAEAAfT/AP////f39+/v7+bm5t7e3tbW1s7OzsXFxb29vbW1ta2traWlpZycnJSUlIyMjISEhHt7e3Nzc2tra2NjY1paWlJSUkpKSkJCQjo6OjExMSkpKSEhIRkZGQgICAAAABAQECH/C05FVFNDQVBFMi4wAwEAAAAh/hFDcmVhdGVkIHdpdGggR0lNUAAh+QQFBwAgACwAAAAAAAEAAQAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpvP6LR6zW673/C4fE6v2+/4vH7P7/v/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AXQQYMCBAQB0BDihQcMDgwRsFFjBgsKDAwxsIJk5EcFEFwQEpEmhkkCDFgZMBB/8UWEkAhUiNJU8ogADhwQGABQzoNCDgxMuJMUsUkEC0Js6dBiya+EnyBASiRB8AHIDUAMgSTIOOSEB0AlEFAANUNeBw60itAAREgCohQs+pVVuSyFpiQVeiaP3lRFoWAN0RA9hKgHBRQFWlIv6KcHBXAuKDBKq+9Xt2hAHBDvR97EtCbFWzMEc89Ur0qokCDhwsaKdyZ8ETkZFe/ctVAunVJgQ4uIDhggTc6mLvLGCaxFiDAq4O6KmWbQTOARZYyJABQ2/C64QjLTBZBFWdBDiXGMCANMcRARBQwECd+nV2AfaODU9iZXcVBR5IBSyBfXv3FjyWjgDyjWWaeCsMJIL/AA1c8F97GFBgADytjZXUfTAEoEAF/v2HgQULILjOQBYmZQMFD1J3gQMYwhOAdjqJ6MIADkIogVz4EOgaDgy4V8F5/HyXgwAXWMCAjPcE0OIMCRTX0ZMmKCnAlFRWOSUPC2Sp5ZZZJsCTORWWqJOAN2zQwZlopnmmBg8syU2YYpq4wwUe1GnnnR508EEGwIUDp5hk2kAnnnjqySc5OsY5Jg+DEmqnnhfk9Y0ABBRoYaA1bMDBppx2ysEGFkgK5aik1kCpDgQ4uU98MeLgGXf8vIgUjjVoRx8+30lmg2EG2pPoWAUguYKlw7mZjqwl3koDspcaW06uwJa1HAzJoQfj/6yslQgrejqpisJ3ff1albflXGuVCdqR6x2241lIKzowKsvtdt59RJAIlorHbFLvnkPpmCJa+patCx6GAqsFyDvglSjwuhOOBIsAo5sBVKzPcSNEDIBnSHUErQG0agxAvA9xvFMJIgOAcUATo8zuCA6DF5DJcpKQMgD5AgSjeDfT3K8+Bf5888j0/rPSTggOzfFKYa20Lbovl0DgSsLaU7GMQ4twdakkQKsu17nt9TTYLFBKgLNkp6322my37fbbcMct99x012333XjnrffefPft99+ABy744IQXbvjhiCeu+OKMN+7445BHLvnklFdu+eWYZ6755px37vnnoIcu+ijopJdu+umop6766qy37vrrsMcu++y012777bjnrvvuvPfu++/AixMCACH5BAUHACAALGIAYgA8ADwAAAb/QJBwSCwaj6BAAIBsOp9Q42AqiFqv0UFhSwhgv+DhwEAuVMPopECgRBLI5LNRMB1400cCiCAvvuF9QwIGCQkIenhEAYh7d35wBoFDCgwMCwWJiowgA3mQkgMJlZaYmUhmRn9xRQEGC6MLm5kCpUKye59FA5SjCY6me0SoRKqRigejlreZv8HEuUMEvJUIzcCdRNi20CACCMkK2sBDzbW4gEMFr6MGaQFrkoLmdtvonKK98VVl8ekFy0mKDCtWpdU6UkYWKXgA4UEsJFrS8WlGi5iQJRe97EqGQAoCBxEkSIjQwFw2k/+ciEOC76GgAw0giBRJ0qSgU+K8dLEyYMGB/zuDFsicSXPBSnJHowVEU1Dag5BER5a0pukUQCveQEYV+aAjVoBJrQRwsFUChHBgKgpjkqZA1AgM8AQQ1+8LTQcGqH5ZtAWYhK51wwT+4nWcYTR6DytCwLixYwQHDCDS2bfJ1TAWMmvenJkChATdeBrOQLq06QwYMFhwMGCwmNGnT6de3emy0nGpc+vWXaGBnYhPbGMRcKG48eMXLFSA8FOx8+cqEyOeAiwCWlPvCGBii2fBhwwRELh+QqdWWCwbPHT4gMFBAelNvNiE/+SBh/vqOVRgIFyRsyPcfWEABx10gF+BGkyQwHlEVGETCAUwCEUACVjwgYEHfhdBc0jI58DGGV7QV8QZAjCQwYX4qfeBBQyEpRZ5D3aoxyYERLBBgRlWcABEKC110RWLpJPTARQQiOEHFxSmS4wNmrNMQX4klMAFF65ngZJGcBFPkOlQ1U9SAjiQAQfgMcmJSvMgAaJAllGSF1NONiHHi404x+VNajYxzGF07pSnPBYdVg55uggjYVppOhHInf9dIwwUkvSxpymbHCrJL5Nmok1/+tQy3hUCzIgVREIcmtanmTb4KXTvQYeHdhGK6OoRd5iKRRAAIfkEBQcAIAAsYwBiADsAPAAABv9AkHBILBqPwgByyWw6iQIQgQACPK/YrHbLpQ6V3PAw6iyAjQGBWowGFbDmY4BQKBDI7OxbGDcOCgYGBXh5V3tuZ2OAgYOFQ15Mh31EBIGMiY5EA0aSmAKLgQRWmU+dRZWWk6RNpkMDloEDo6usQ6qgBgSYpIdJtrZgAa+whFkCA5tLr0WjrZ+wukh0drtgBm5braiMxUMIC+AIyURK10LmTrJVQwBWz5bqXyAHCgz2DAnj8uilArNyqFSBMFDvnr18heI5+aSwQIIFBu0tONCtDBsAZ75FlCjuH60m9DYyWJBAVJ6KWCBuVCCwS54BESei3LJrSwKOCvNAYgOzpMf/PDW5tPxIFEkUZEiTIls18widQEz0nYxAtapVqhAYHAhadIiEr2DDgoWQoGlXsWi/kjXrilSAtGgfIDhTp67dOqsIQNjLt+/eBwpMdh08+CdhLAMgIGB75Q8/NgwwUGhggKsTJTsTXsiA4cKEBZmvCAhdSEKG05wtRECIuBclMQgsYEB9GkOFBxSbCAP0UQkCCRdmo+482TUU0m4GWGYigOyQBRQwCK99YXVFqY8SYWeCYMOHCTsdyJ6OwQIE40H9hTmAwYOHDhoYnAFgAIJs6hHQFymwfdmYR0JEYwAGHbj3QQXGITBBcOWdd9kRn7zGBzAgBOAAB+51wMEDFTFApYEFn20nhABBzYFOIxPyAQYBFhT4HgYIIDEAAj5lMksrATCAoYERiLiKa62AMAAFLnaQgQLLbSFVTkGCkMAG7nnwHXJu7UfhFw98kOEG8pHi34icXGnLBUVaYFwYc0hopYpFBNDAjvAlkEkiKK6JiBEsdqBnBnI6op1hTT6nwQccXNAnLUkONYADwT1A5WFctWPYYQFSepGlWmwSgKScdurpp5IGAQAh+QQFBwAfACxiAGIAPAA8AAAF/+AnjmRpmsGprmzrjoQ4vHRdG4at73z/Cq7Cz9eKfQqzk7AFJDpdAULuSa3aklaj9Yk9dqtf3VKk3X7KvkLTLBr7wlv0q+x+r0uCum4AOAUGgHcqUycAcGcEBXowKSYDiQYFBI0vhzxqJgKQOAaTK4sflCSeLIZkjgWcnKQniSp3BIIsUWt/qao4SKIkALYufTrAmri5scArAAIDeoQ9UbeqkgK7s5p61DUA0Jy6xzV/ZZY0AtEDAd7Bvh/oPFLS7DzJBOLfsdhE51X5bPxX/SoHAgoceCBSEln/RgxgwLChQ4YLEoBKOOKhRYgG7lH8cNHigoxtNpJY2LFhRCHJlP8BWskykBUBBGNGiiWyZiibPDRZaXAA5w4JEBhQWdbMSQEJSCU8UOBMRFEnARwkRRrBwQ6drRDSGLAAwlSqDZ5085HsQIMIX4EuePF0LBmtJ2YgEGEogQO0U6vO9fOh6LsSOVi9YnDhAgQsURQ8+BqBgZwRzeZRm2iiQoYMGCowJRGgAAOvVB0HMQePxBgLhQsLIRABw2UMEkyUbQAhQtDHMgKVLsFHBIYOHjxsWJKggusMF8LKHnAgAQIDcAFI/zbid/DhMh5ceE2hZyHpu1186WJd+BIABygcv/CgpuDy2EUIaLAdc4UE/QhhIgHfzdHjGEDARh6jmNBfCQpY4BpvBhas9c8iB44CAYCx/dNbCRGSUNyCFXjHhmDVAWeeIw8oiEF3bCiyQoYkHAABBRRA8BQ+AtS4wgUd5KjBIp0hgMAB9OwA3goV5NgBBrj5VAIEG3DAwQRBKpmABBNMwIBGSo6QBw58gOfll2CGKV0IACH5BAUHACAALGIAYgA8ADwAAAb/QJBwSCwaj4LkcclsOp0DUKHwrFqvwoIBy+0eqd7wcRBlbp0BELks9p6dYHCbKJAXBMc3Uz7/FtNFemOCfUQET4RFfIVGeoeBTQR6eIxDj0IGbJhMAomVQ3yLngGXn0ueIJ4DqKZSRZSpS4uARwG0TI+3RI6AiatVeAQEmkWlBAK6IKVGZJeLe1tbsIrU0yC61kTJzFqvS5KBBcRDAwBPdUZp4FjdRoe0BdtLAJoCy3RO95bZXQPPQ/LcJRLXpt0uIeas0DPISN+cf2ICtnEYho3EVl0SVtKIsaPHPwIGCBtJcuS4iCVTDkOWhVUrAAZiypwpkyDFjzRzxiR48iMm/500CfpcEgDozALHEkZRSbKnF1JMTdoaSlVbpYtcAvi7iUVBpkIB7J3B+iQBgwUJ7rSxV2zOAAZwzyIQ4w9JmwVx4yo4cM1KL4wJ8OaFm8ClELFoIDIJe62AgsFw0T5RTOSAhgdXCjjge/iA4MFecTUyImBCBw8bFlSRIKEBEXoIPsdN0PNZNgUcPOj+AAHPLUCsWUdI4C5wXtpiCFw47aFDBuJCMki3sGXAg+ASMKczoGCBdwQ91fVN5+CDbg+8KVmQnoE6CAAIsEdQjcQAAgMEyObJwLzDBc4grDfdGQI4gN0DhoURQATm6cZBA7QI2N4bBkSAHQMdIbBBfxTwIaShe0IEsAB2EBzAUSECUNCfBgvc8qEeA0CAnWumLNAgehIQ8+JrCcinwCcDWNBfBnMVsSMR1mHnAFdYGLDhbr0ZceQQABxAYoJWGJDBBx18AKKR7H0JUAPCPUAZFwREkIEGFrR4xJREaAaBAwsweUUABzTAwFdvsleBJ4cccExVRGBgKAWEcmHBBRZAkOgVB1j4AHSPPoEnAkkBoOmmnHbqqadBAAAh+QQFBwAgACxiAGMAPAA7AAAG/0CQcEgsGo/EAHLJbDqJhGHhSa2CAkqqYInNWqmD7XEqNIiLgK9aSPASySDz0rBuukGD8VBujA7zdUZpUHplZ4FfgGWKUnuHiFUBcCAFj3B8f0WMkEOPV2+ORZOcS36doIakagKTbY2pQp6IXUgAm4qXsrF2TgSbQ5JIuWqmtUR0v3jHioBhgaNDAMVsn0vJQ8XXorUD0Ee6SAHTgQHdRgYFjNpInnR9TQAC40mqR+tJrPVO6Wrl3oibChAAB0/evzUADgaSV0/MvS/lVNnSR1HIoIoYM3JKWKCjR49snIGY904jk4cmm0QhmLLXlQEEPsr0SBLhzJnAQADowrMnlv96O3361NmyqJAABg6oYgmxgAMMGEhJGkhqwAILHDp4QMCJgAF0A+5YCZCAwgatHjxsYMpEwNe3/CAagKABbdoOHyAESvgWLtUn4hpc+JD27gcNEhKIpeKvr18nVitkLeyhwwYKCwC5U7Ozm+OvcY8EYJDBbuUPGBwUyGKgggSUeBYYyBIv5meBi0FU+IAWb4YIBw5BwJDhAoN1AxIwYKCgSAB5t3Vh7UBdw4QEmxJcyMD9wgM2WQRssbp8uVIinQv0rYTkwXYNFRiMGyCBeAYMFM5DkMAf+BUE5TGwwBHpdfRXHwkkuNoRDGzXXQND7NffeeSVxxWBz4n3DAX2YSDCARwSSuCfTgYEOGBunDzFHQYWDBghfyKeB4IACgSYQEYHWNAhBMWEOKJOBZhYjT4RdFjBhS9OmIRy5TVHkQIOFueAET7KyMYCASJJigD1rTiBlUJU6dwBATqpCgEVQMUiA0eIqUmNyy2g0BcETGDBBRZE4I2b6BmAJXP6CMAABBE8oCURfBIhwAEJHspJNwLp8gCMEIBpkQADZIpiRg7A+MCcRhWhwAMQQMBmqFUQgECCmKDqRIYBACDrrLTWauutQQAAIfkEBQcAHwAsYgBjADsAOwAABf/gJ45kaZrCSJxs677tUIwpbN9jEI/GgP/A0mrke9WCJoDP4BqKiqXAiglFkpQw56cqwoqY1lO1cFSRuB/B7IsOq19atJYcTrZJ8dL7W2cF1iJaH3k5gn0nXkR4ZyOJhy5SLYQff4uPJ3sfYIGMH459hiZjNYSZNwRlNCSAeqwEOqmcI6xBplQlny25biyoJJU3uyK0H3RhAEE6JcQ2ATImBgV3l8GDzKHB2EgChrE/3p5IzpZ12kjIz8p16tRp7e/w8fIvAwoQFRcY+vv8Fu3aBQAZmLChg8GDCA1eaMfMBAEDFDh08ECxokUPC6k1JMEEosSLIDNe2shjCwMKGDT/bFjJsqXIeX4GEAhIsyZNmDhzwiCpk4WSBBEqgPuBTAS7bQju6WNwCIovKwYaoMSQIcOFac0eEVggIV/VDBheIjF0C8bPCBaofsVQ4QGCY9w2HiUh4MCDCmqrYrAQQUGXV0TZYXuKy0AEr3ovUGBKg4EDnjQKaBkHzWcCvHrZOoiSVIIEGFIMRCtTFLKnBFP3QngrpIFnzw18CCgyQEdo0QZCxX0B4EAEChUkKEATAOhrCCMOMFjOgImSArh7SKJ3oLrPAg9eR1iQnHlzow9xF5h7ScCCCK8fkFDOfJOa6AOKtgNgILvnCAnWe9+kJLqxdgMw8JoEm+nX3i/Q4WaOeDideYZcCewtt4knA/g31FgODMiYgRJGEZ5oCxKFAHoOnhDhd1e8J9p/fQCgAInbmbifCbeJhhVRCUAQQQQFmnDihJGteCMO9DF3AAs/IiITAYS1yI05ES4AZA4BVNkTDwssx92VpySwwAL5cWmDiuOJaRYl5IURAgAh+QQFBwAgACxiAGIAPAA8AAAG/0CQcEgsGo0A0GAgCByf0KgU6hwKptis9jocaL9gIzdMPgYIBQLUO1Q/0e7ykWsojIlsYVweLggNBFV4RHt8W35ReSCFIIKGT2eEjkqERQCKj0+IIAaYioxFgZmhRJtCn1F2o0UCmwZFqE+dq1Kqp5W0QmcHs1iilG1ld0YFEhobFgvDIElPsZO/RwWmRggXHx0dHBMHk5FSXs1Ey0eYQwgYHx7rHRoRBpOb0VGvk85PBxbY6x4dHxkNUM2rNSZJgVdaBjCwwKEDv34fLCSoIoBcoiIIixQwRyTAAQgZ9vHTxs3eKousEhgT2a8dtUxqTK5ZUKHhwwd8JtUZIFNKgP8CDq453PCIIx8BByKEXPCoGQGUYQYkiDDqSk85UHNp3WoFgRALYMOKtdCIloGzaNOCSMNzgIMKGOLKnSuXFiiMeh5YiJuhr9+/GWgZFUNAL1/AgAVnqZgAAoUKYyPbxcLmysG0mM9e5cq585NLqzaHEYDggYRVGzP9bBBBwulHdPyIhkJgAQTXuF9+AWAKUFYkUk3jxu1g9j1iX5A6GI47AoMDv8Ps9FmAQWvmERwksHJUlmxn1plLeKCg44EFg4t8w2KL2PLhEBhkZFabAYPt4P6Y42gU6PUIDUDHCgL22ZeAVVWIo1F0RhHAwAMQaHcEbwsUuAA8SqTlxjB3lQKbhQBoAPKEAAkUeF8XGn7IWQAGmMgUimh1ONAqAyhg4gF4pChLenJ4ZGJ5OcZIyhC6GQJAffYtgGOQZxXSyhC9nFRigfgxKWIq0WmBJAMLvDSAjlBEmUkBFdrnlRFfCmlJLKOQaZ8CoKTZpBluzAcTAgkkYCeMc87RBS0BLDGYnFeOmCUtraDFo2eQoDHNoYwOEYAAgkZKhoKrBAEAIfkEBQcAIAAsYgBiADwAPAAABv9AkHBILBqPAcFxyWw6n6ABdEqtBgjVrHZZGGKXgPC2WXhYKAupUfkMqMdMBYbzwSiObCvcqNB0Oh8UX0R5TAJdQgQBe0V9HR4eHAyLhE+DIJeMIAYWjx4dFohDhVBvmiABDRueHw6UQqRFr6dLBBQfkB4ZCJVgprRGAQt+kB0Tb7GjopizwAMSuJAbC5TJiUQF1qUEBNYIGJ4dFV/Wh0MGv0QAzUUDDBQVEQl4Dxy5HA2L1plLbk8GES5gwHABggEjBSqEu4Doy6Bf6aoAFJghA4YKDS4FYLAKEoaDUDIBEMCPSQEIFCsOREOEwIQPG3iNcbNsSEQQAhIExFBR5QX/CQiUBFAAQVs/ITRrOSnQgEJKlRYedGFHxZoBLFSNHHhQYWDPlSCBGShws0kCCBZ49pQA7BSBBRMoXii7pVvWKQEMNL3AgNbBAXezCNhKt0rhtogTKw5GQIGDBxAiS54MoeSYAQUya95cJOcDCaBDiw4dOMthWAKIjl4NejEZnKpZj3ZtEtUBBg8i6N7NW7dR0waCCx9+sKaQA8iTKz/wu4qA59CjQ0dFuzqS09aPABiAII1bYCMPLGDAYB6j0lTWFVBAvj12JpazXEnQvv6CPc2fbO9ev72CsNkVMZIB4/XHgAIHUBcAAHCUhQWDeIhn4AIIDLJdNlNcqMkA9NmXkUBNARQQnCJNjGScF0cZwWF9//2y3XCIiCEEg9vNdAR3CyyAIHWdiSgcOXg9cRMlJyJFAIyjaPdeFHu8OBwyKWYX4nCX5Eebk8GR1UuASPg4YmdcanekcBhuGaYyTzZj5WKHkImHFuhV5aOWa2RBIi0kZXbTmpnxiOdzWZnzxJqIzRLfmUwsGSCD3CBKRZxaBAEAIfkEBQcAHwAsYgBiADwAOwAABf8gII5kaZoBYazD6b5w/AoNRUmJrO88QXGcjYRHLJoMmY4SY2ySBodEwhA4HTYeT0fz6Xq9gvB3TC6XDxJKBWKwYrUa16BQMNvvXkQFg7lAWiVXWVt4HwUCTid6GBkYFglkgnCFh4kmBROMjRIEgW9bJgIFKysEhadfCxaaFwxjkoRjKqSHqLYfEZoYFAUksFxjo6Smt6gJexmNDogivyQBwQLFtg8XyY4HI84jA6QsliN2FLoRgL92BVVNAlEKCATQZA3WyRcKXedlBYChA/52BBhAiBDBAQJEZCTomtDpQJ8L1kSI8tYJxZwv6koQaBBBgkcIDAwg9KJgVSMLCFD/VXo2x5sBAsw0cvRI84GCdF8g9GEQ00WKUmMEzHIJ0wwCBx1pSiiYYEA8BOV4iPICQKgwl7XuLICg1GOEBgcQ9dyhLkBLlwb22ZrZFWTFJmfRErt1NGnNeNPMvJSW94OCB0rr9CWTdsDgLwIlHCYjePGYBo67DIAJ7gS/ypgzZxZq4IDnz6A9j7UklIDp06j9IQpQIMECBrBjy4ZtOLJKeOxez97tyvatAbl57/b9m7Vr3cIZ1CZuJ23RL2hd4o3sr7r16nyZa78FIGNl7WbTYZ48OpHVl5hX7PO+Lq5IcN1oOW0SHm2vRAGiU+ZhdijR6XlFt095oRBwlTcrOfHFpoHysccSg+ot94FQDs4w14QA2cEZVk7J8k0MKdxigIb+7aWPb5MRVd55aZkBoGCs0UGHHQCYIUwBz5EhgGpmABAfKYCwRoteGmJn3oHidXdVY9vdUSI/QqrXJB4TDfPMklM6iWBPUbaYZRk/fjhCl0x+2cWLZJBZyIXMGXCZCGriUaZvaTkY5x1ZMbdfCWTKIWOOZn4w3ZyB3kJooXioxyaiqOxZWQgAIfkEBQcAIAAsYgBiADwAPAAABv9AkHBILBqNAAGBMAgcn9CoNKp4PBqIqXbLBUEslkqkSy4TKZh0xcwWKguFAdSSyWAsz8EBgSg420UFDA4ODE8IdHZ4RgINFhgXEQeARQYPERIRDgJGiHV3RwgXH6QahpRDBhASrBEIAEWeikYDER8dHh0cCqhDBA6srA9yRLKgRAEKGbi5GcS9AgqYwQuwQ8aLvhMfHrkfp71DwMEQBMWJx0IBDBvMHRac4derwQx/INhEBhbuHAnyRRgEy2TgGrpsAh5w6JZrwj2AIA7QExYvnxAEGNxpKMiGABwCAqwVWTCNVQJYFgdI4NbtA4SHQwJwEgBzyIAEC3ImIFATxIP/gRDk5AuwQIM7Z1DggDB35CaDpwwWIGhSJEFJCeqQgVDJUtcCRh6JFMiTACpUBQZC2mzASgu7XBXuWRsbCIoBBWbP+hHpgK6WBxuyqHtGSwrOvFF3/ukZxcA9pkZAajFwOO+CA/HMvHlCc4uTA3gtA8oslqoZBAvMEjYDOZyAAof/UXpMmtLdcGEZs9FdJgBviMCP+BYwoLjx48V/k0HOXEDnrR4NSJ9OXbpy4DQHFKjOXXpwLQG0d+f+XYo58eOpiyz/ROaAJfDjwwf4Xr78rc/Z6y+/3nVrVNeVsdp+U9QUIIFLRYagFJz4JY92T/CEimltKBGcZDb1F0UAfjnxoB94RxiAYSC1HQEAMa2Ft52CTzgIwlgHsuGii5VM8d9MTNQnxIBHWKiFHEyUGKEbHIHAUQAfCrefAEUWWRuNCDKZyoJR+DGElEIUKQSU+mkJApZGFjGAlkmi4uCNTUrhZS9lXpkmlVqAuSaS+ghZnpw9OshjG3TF0eObVBpnJ2lrElGcnXfCCYgBXCqKzDN7OlqEcyAEAMClmGaq6aabBgEAIfkEBQcAIAAsYwBiADsAPAAABv9AkHBILBqNAYHyyGw6n86DQoEgQK/YbAMCeSyy4LARIik/xGjiYC0AMCNlCYQpKBgMA3e6SEj4DwNvcXNICRAREQxWe0QFCwwMCwh6RXBlhEUGEhcXFhQJjI2PkAuLlYNGAg4XGK0WCKFECpCQCQFGlnJFAAgUGBkZGBSxRAi0kAa4qGoQv8AXX8RDs7QKAqeXRQkVzhgS0kQHo5AHlCC5mCAFEd2v4EQJxwuBQ+hDAQwW3engAQbjDCbVWwbCwIRuFdIkUdKGSTxaCwoMzAZC1QVgGS40MCfE3xQFpogIIFCgJIGGRgAquHVuGQJuwIQhKdDgwgYNFx5wrGjnjoH/AgMCcDxwjIHEJSACLGoW84KCIgMWUNjQoSoHDDvr+PQJlOW0WvSYBLroTWQCCRo+dPDgocOHCzuV9txq4CQlcWGfDJBg4UBHAxAyqGXLtkOGBk0GzN1agIDQNH6VNrDAYS3hDhwqWHtCku6drgqlUiXM9i2DvE5GLv68MwuEwZc1OCjgFYtiutf2CNhwecMEBLXBBLhdNxaCtpnnESMZPA0GjSFj5Y51gPa762DcLGTInWFr3d27Jy0i0cl3NNGNNA6aHjuj9u7RoI5vBD6RZBUH2B9yHvui/vS5B2CAV+QhzXyM0DNdLCddV8CAYNiFxoJDIMgIaFj0Vx52FhYxlxx9zRHRIDEUQhHSbeqNl8qGSNQXYmIcHoEfCI5lUVsS+5EnIhMsqiFEXjMywVKQTeQI4xAbstijGgTsF8CT8jVSIR/nQRkjkvdEVyKBIOTF4pZcQiVllmJeR2SZQvRYRyMvprEkmuoYMcCZB0LhJRTWETOnXmPCWVGdfGKJhJGxhLhnmnR0GIqVYV63ZqNuvgnpFWCmEQQAOw==";
        $("#Imagemodal").remove();

        let modal1 = `<div class="modal" id='Imagemodal' tabindex="-1" role="dialog">
  <div class="modal-dialog modal-sm" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5>Image</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <img src="${loader}" data-src=${data}/>
      </div>
    </div>
  </div>
</div>`;
        $("body").prepend(modal1);
        $("#Imagemodal img").Lazy();
        $("#Imagemodal").modal("show");
        //$img.attr('src', $img.attr('data-src')).removeAttr('data-src');
    };

    this.PopoverPlacement = function (context, source) {
        var position = $(source).position();

        if (position.left > 1150)
            return "left";
        else {
            return "right";
        }
    };

    this.GenerateButtons = function () {
        $("#objname").text(this.EbObject.DisplayName);
        $(".toolicons").show();
        $("#obj_icons").empty();
        this.submitId = "btnGo" + this.tableId;
        this.$submit = $("<button id='" + this.submitId + "' class='btn commonControl'><i class='fa fa-play' aria-hidden='true'></i></button>");
        $("#obj_icons").append(this.$submit);
        this.$submit.click(this.getColumnsSuccess.bind(this));

        if (this.EbObject.FormLinks.$values.length > 0) {
            this.CreateNewFormLinks();
        }

        if (window.location.href.indexOf("hairocraft") !== -1 && this.login === "uc" && this.dvName.indexOf("leaddetails") !== -1)
            $("#obj_icons").prepend(`<button class='btn' data-toggle='tooltip' title='New Customer' onclick='window.open("/leadmanagement","_blank");' ><i class="fa fa-user-plus"></i></button>`);

        if ($("#" + this.tableId).children().length > 0) {
            if (this.login === "dc") {
                $("#obj_icons").append(
                    "<div id='" + this.tableId + "_fileBtns' style='display: inline-block;'>" +
                    "<div class='btn-group'>" +
                    "<div class='btn-group'>" +
                    " <button id='btnPrint" + this.tableId + "' class='btn'  name='filebtn' data-toggle='tooltip' title='Print' ><i class='fa fa-print' aria-hidden='true'></i></button>" +
                    " <div class='btn btn-default dropdown-toggle' data-toggle='dropdown' name='filebtn' style='display: none;'>" +
                    "   <span class='caret'></span>  <!-- caret --></div>" +
                    "   <ul class='dropdown-menu' role='menu'>" +
                    "      <li><a href = '#' id='btnprintAll" + this.tableId + "'> Print All</a></li>" +
                    "     <li><a href = '#' id='btnprintSelected" + this.tableId + "'> Print Selected</a></li>" +
                    "</ul>" +
                    "</div>" +
                    "<button id='btnExcel" + this.tableId + "' class='btn'  name='filebtn' data-toggle='tooltip' title='Excel' ><i class='fa fa-file-excel-o' aria-hidden='true'></i></button>" +
                    "<button id='btnPdf" + this.tableId + "' class='btn'    name='filebtn'  data-toggle='tooltip' title='Pdf' ><i class='fa fa-file-pdf-o' aria-hidden='true'></i></button>" +
                    "<button id='btnCsv" + this.tableId + "' class='btn'    name='filebtn' data-toggle='tooltip' title='Csv' ><i class='fa fa-file-text-o' aria-hidden='true'></i></button>  " +
                    "<button id='btnCopy" + this.tableId + "' class='btn'  name='filebtn' data-toggle='tooltip' title='Copy to Clipboard' ><i class='fa fa-clipboard' aria-hidden='true'></i></button>" +
                    "</div>" +
                    "</div>" +
                    "</div>");
            }
            $("#" + this.tableId + "_fileBtns").find("[name=filebtn]").not("#btnExcel" + this.tableId).hide();

            if (this.login === "uc") {
                $("#obj_icons").append(`<div id='${this.tableId}_fileBtns' style='display: inline-block;'><div class='btn-group'></div></div>`);
                $.each(this.permission, function (i, obj) {
                    if (obj === "Excel")
                        $("#" + this.tableId + "_fileBtns .btn-group").append("<button id = 'btnExcel" + this.tableId + "' class='btn'  name = 'filebtn' data-toggle='tooltip' title = 'Excel' > <i class='fa fa-file-excel-o' aria-hidden='true'></i></button >");
                }.bind(this));
            }

            if (this.login === "uc") {
                dvcontainerObj.modifyNavigation();
            }
        }
        if (this.isSecondTime) {
            this.addFilterEventListeners();
        }

        if (this.IsTree) {
            $.contextMenu({
                selector: ".groupform",
                build: function ($trigger, e) {
                    $("body").find("td").removeClass("focus");
                    $("body").find("[role=row]").removeClass("selected");
                    $trigger.closest("[role=row]").addClass("selected");
                    if (this.GroupFormLink !== null) {
                        if ($(e.currentTarget).children().hasClass("levelzero")) {
                            return {
                                items: {
                                    "NewGroup": { name: "New Group", icon: "fa-external-link-square", callback: this.FormNewGroup.bind(this) },
                                    "NewItem": { name: "New Item", icon: "fa-external-link-square", callback: this.FormNewItem.bind(this) },
                                    "EditGroup": { name: "View Group", icon: "fa-external-link-square", callback: this.FormEditGroup.bind(this) }
                                }
                            };
                        }
                        else {
                            return {
                                items: {
                                    "NewGroup": { name: "New Group", icon: "fa-external-link-square", callback: this.FormNewGroup.bind(this) },
                                    "NewItem": { name: "New Item", icon: "fa-external-link-square", callback: this.FormNewItem.bind(this) },
                                    "EditGroup": { name: "View Group", icon: "fa-external-link-square", callback: this.FormEditGroup.bind(this) },
                                    "Move": { name: "Move Group", icon: "fa-external-link-square", callback: this.MoveGroupOrItem.bind(this) }
                                }
                            };
                        }
                    }
                    else {
                        if ($(e.currentTarget).hasClass("levelzero")) {
                            return {};
                        }
                        else {
                            return {
                                items: {
                                    "Move": { name: "Move Group", icon: "fa-external-link-square", callback: this.MoveGroupOrItem.bind(this) }
                                }
                            };
                        }
                    }
                }.bind(this)

            });

            $.contextMenu({
                selector: ".itemform",
                build: function ($trigger, e) {
                    $("body").find("td").removeClass("focus");
                    $("body").find("[role=row]").removeClass("selected");
                    $trigger.closest("[role=row]").addClass("selected");
                    if (this.ItemFormLink !== null) {
                        return {
                            items: {
                                "EditItem": { name: "View Item", icon: "fa-external-link-square", callback: this.FormEditItem.bind(this) },
                                "Move": { name: "Move Item", icon: "fa-external-link-square", callback: this.MoveGroupOrItem.bind(this) }
                            }
                        };
                    }
                    else {
                        return {
                            items: {
                                "Move": { name: "Move Item", icon: "fa-external-link-square", callback: this.MoveGroupOrItem.bind(this) }
                            }
                        };
                    }
                }.bind(this)

            });
        }
        $("#" + this.tableId + " tbody").off("click", ".groupform").on("click", ".groupform", this.collapseTreeGroup);
    };

    this.CreateNewFormLinks = function () {
        $("#obj_icons").append(`<div class="dropdown" style="display:inline-block;" id="NewFormdd${this.tableId}">
                    <button class="btn" type="button" id="NewFormButton${this.tableId}" data-toggle="dropdown" title='Newform'>
                        <i class="fa fa-plus" aria-hidden="true"></i>
                    </button>
                    <div class="dropdown-menu newform-menu">
                        <ul class="drp_ul"></ul>
                    </div>
                    </div>`);
        $.each(this.EbObject.FormLinks.$values, function (i, obj) {
            let _locale = ebcontext.languages.getCurrentLocale();
            let url = `../webform/index?_r=${obj.Refid}&_p=""&_m=2&_l=${store.get("Eb_Loc-" + this.TenantId + this.UserId)}&_lo=${_locale}`;
            $(`#NewFormdd${this.tableId} .drp_ul`).append(`<li class="drp_item"><a class="dropdown-item" href="${url}" target="_blank">${obj.DisplayName}</a></li>`);
        }.bind(this));
    };

    this.FormNewGroup = function (key, opt, event) {
        this.rowData = this.unformatedData[opt.$trigger.parent().parent().index()];
        let filterparams = btoa(JSON.stringify(this.formatToMutipleParameters(this.treeColumn.GroupFormParameters.$values)));

        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.GroupFormLink, _params: filterparams, _mode: 2, _locId: ebcontext.locations.getCurrent() });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../webform/index?_r=${this.GroupFormLink}&_params=${filterparams}&_mode=12&_locId=${store.get("Eb_Loc-" + this.TenantId + this.UserId)}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            var _form = document.createElement("form");
            let url = "../webform/index?_r=" + this.GroupFormLink;
            _form.setAttribute("method", "post");
            _form.setAttribute("action", url);
            _form.setAttribute("target", "_blank");

            var input = document.createElement('input');
            input.type = 'hidden';
            input.name = "_params";
            input.value = filterparams;
            _form.appendChild(input);

            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "_mode";
            input.value = "2";
            _form.appendChild(input);

            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "_locId";
            input.value = store.get("Eb_Loc-" + this.TenantId + this.UserId);
            _form.appendChild(input);

            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "_lo";
            input.value = ebcontext.languages.getCurrentLocale();
            _form.appendChild(input);

            document.body.appendChild(_form);
            _form.submit();
            document.body.removeChild(_form);
        }
    };

    this.FormNewItem = function (key, opt, event) {
        this.rowData = this.unformatedData[opt.$trigger.parent().parent().index()];
        let filterparams = btoa(JSON.stringify(this.formatToMutipleParameters(this.treeColumn.ItemFormParameters.$values)));
        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.ItemFormLink, _params: filterparams, _mode: 2, _locId: ebcontext.locations.getCurrent() });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../webform/index?_r=${this.ItemFormLink}&_p=${filterparams}&_m=12&_l=${store.get("Eb_Loc-" + this.TenantId + this.UserId)}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            let _locale = ebcontext.languages.getCurrentLocale();
            let url = `../WebForm/Index?_r=${this.ItemFormLink}&_p=${filterparams}&_m=2&_l=${ebcontext.locations.getCurrent()}&_lo=${_locale}`;
            window.open(url, '_blank');
        }
    };

    this.FormEditGroup = function (key, opt, event) {
        this.rowData = this.unformatedData[opt.$trigger.parent().parent().index()];
        let filterparams = btoa(JSON.stringify(this.formatToParameters(this.treeColumn.GroupFormId.$values)));
        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.GroupFormLink, _params: filterparams, _mode: 1, _locId: ebcontext.locations.getCurrent() });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../webform/index?_r=${this.GroupFormLink}&_p=${filterparams}&_m=11&_l=${store.get("Eb_Loc-" + this.TenantId + this.UserId)}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            let _locale = ebcontext.languages.getCurrentLocale();
            let url = `../WebForm/Index?_r=${this.GroupFormLink}&_p=${filterparams}&_m=1&_l=${ebcontext.locations.getCurrent()}&_lo=${_locale}`;
            window.open(url, '_blank');
        }
    };

    this.FormEditItem = function (key, opt, event) {
        this.rowData = this.unformatedData[opt.$trigger.parent().parent().index()];
        let filterparams = btoa(JSON.stringify(this.formatToParameters(this.treeColumn.ItemFormId.$values)));
        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.ItemFormLink, _params: filterparams, _mode: 1, _locId: ebcontext.locations.getCurrent() });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../webform/index?_r=${this.ItemFormLink}&_p=${filterparams}&_m=11&_l=${store.get("Eb_Loc-" + this.TenantId + this.UserId)}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            let url = `../WebForm/Index?_r=${this.ItemFormLink}&_p=${filterparams}&_m=1&_l=${ebcontext.locations.getCurrent()}&_lo=${_locale}`;
            window.open(url, '_blank');
        }
    };

    this.formatToParameters = function (cols) {
        var filters = [];
        $.each(cols, function (i, col) {
            if (this.rowData[col.data] !== "")
                filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
        }.bind(this));
        return filters;
    };

    this.formatToMutipleParameters = function (cols) {
        var filters = [];
        $.each(cols, function (i, col) {
            if (this.rowData[col.data] !== "")
                filters.push(new fltr_obj(col.Type, col.FormControl.Name, this.rowData[col.data]));
        }.bind(this));
        return filters;
    };

    this.collapseTreeGroup = function (e) {
        let el = (e.target).closest("td");
        let curRow = $(el).parents().closest("[role=row]");
        var level = parseInt($(curRow).attr("data-lvl"));
        var isShow = ($(el).children("i").hasClass("fa-minus-square-o")) ? false : true;
        let count = this.RowCount;
        let rows = {};
        for (var i = level; i >= 0; i--) {
            let temp = curRow.nextUntil("[data-lvl=" + i + "]");
            if (temp.length < count) {
                count = temp.length;
                rows = temp;
            }
        }
        if (isShow) {
            rows.show();
            $(el).children("i").removeClass("fa-plus-square-o").addClass("fa-minus-square-o");
            rows.children().find("i.fa-plus-square-o").removeClass("fa-plus-square-o").addClass("fa-minus-square-o");
        }
        else {
            rows.hide();
            $(el).children("i").removeClass("fa-minus-square-o").addClass("fa-plus-square-o");
        }
    }.bind(this);

    this.AppendTreeModal = function () {
        $("#treemodal").remove();
        let modal1 = `<div class="modal fade" id="treemodal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
    <div class="modal-dialog">
        <div class="treemodal-container">
            <h4 class="treemodal-header">Move <span id="itemorgroup"></span></h4>
            <div class="tree_item_cont">
                <label>From </label>
                <span id="movefrom"></span>
            </div>
            <div class="tree_item_cont">
                <label>To</label>
                <button class="btn treemodalul">Select Group
                <span class="caret"></span></button>
            </div>
            <div class="pull-right">
                <button class="btn" id="treemodal_submit">Move</button>
                <button class="btn" id="treemodal_cancel">Cancel</button>
            </div>
        </div>
    </div>
</div>`;

        $("body").prepend(modal1);
    };

    this.MoveGroupOrItem = function (key, opt, event) {
        this.AppendTreeModal();
        let rowindex = this.Api.row(opt.$trigger.parent().closest("[role=row]")).index();
        this.movefromtext = this.unformatedData[rowindex][this.treeColumn.data];
        if (opt.selector === ".itemform")
            $("#itemorgroup").text("Item : " + this.movefromtext);
        else
            $("#itemorgroup").text("Group : " + this.movefromtext);
        this.IdColumnIndex = this.EbObject.Columns.$values.filter(function (obj) { return obj.name === "id"; })[0].data;
        this.movefromId = this.unformatedData[rowindex][this.IdColumnIndex];
        this.Items = {};
        this.createTreeItems___(this.treeData, this.Items);
        this.Items = this.Items.items;
        this.InitTreemodalContextmenu();
        $("#treemodal").modal("show");
        $("#treemodal_submit").off("click").on("click", this.MoveOKClick.bind(this));
        $("#treemodal_cancel").off("click").on("click", this.MoveCancelClick.bind(this));
    };

    this.createTreeItems___ = function (initems, outitems) {
        $.each(initems, function (_in, _out, i, item) {
            let Exist = item.item.filter(function (obj) { return obj === this.movefromtext; }.bind(this));
            if (Exist.length === 0) {
                if (item.isGroup) {
                    this.ulid = item.item[this.treeColumn.data];
                    if (!_out.hasOwnProperty("items"))
                        _out.items = {};
                    _out.items[this.ulid] = { "name": this.ulid, "data-pid": item.item[this.IdColumnIndex] };
                    this.createTreeItems___(item.children, _out.items[this.ulid]);
                }
            }
            else {
                $("#movefrom").text(outitems.name);
            }
        }.bind(this, initems, outitems));
    };

    this.InitTreemodalContextmenu = function () {
        $.contextMenu('destroy', '.treemodalul');
        $.contextMenu({
            selector: '.treemodalul',
            callback: this.MoveDDClick.bind(this),
            className: 'contextmenu-custom__highlight',
            items: this.Items,
            trigger: "left",
            autoHide: true,
            events: {
                show: function (options) {
                    this.clickCounter = 0;
                    return true;
                }.bind(this)
            }
        });
        this.clickCounter = 0;
        $(".contextmenu-custom__highlight .context-menu-submenu").off("click").on("click", this.MoveDDClick.bind(this));
    };

    this.getClickedItem = function (key) {
        $.each(this.Items, function (i, objOuter) {
            if (objOuter.name === key) {
                this.moveToPid = objOuter["data-pid"];
                return false;
            }
            else {
                if (objOuter.hasOwnProperty("items"))
                    this.getRecursivelyGetClickedItem(key, objOuter);
            }
        }.bind(this));
    };

    this.getRecursivelyGetClickedItem = function (key, objOuter) {
        $.each(objOuter.items, function (i, objInner) {
            if (objInner.name === key) {
                this.moveToPid = objInner["data-pid"];
                return false;
            }
            else {
                if (objInner.hasOwnProperty("items"))
                    this.getRecursivelyGetClickedItem(key, objInner);
            }
        }.bind(this));
    };

    this.MoveDDClick = function (key, options) {
        if (this.clickCounter === 0) {
            if (options === undefined)
                key = $(key.currentTarget).children("span").text();
            $("#treemodal .treemodalul").text(key).append('<span class="caret"></span></button>');
            this.getClickedItem(key);
            $(".contextmenu-custom__highlight").hide();
            $(".treemodalul").removeClass("context-menu-active");
            $("#context-menu-layer").remove();
            this.clickCounter++;
        }
    };

    this.MoveOKClick = function () {
        if (this.tableName !== null && this.moveToPid !== null && this.movefromId !== null) {
            let sql = `UPDATE ${this.tableName} SET ${this.treeColumn.ParentColumn.$values[0].name}= ${this.moveToPid}
                        WHERE id=${this.movefromId} `;
            $.ajax({
                type: "POST",
                url: "../DV/ExecuteTreeUpdate",
                data: { sql: sql },
                success: this.UpdateSuccess.bind(this)
            });
        }
        else {
            alert("Select One Group.....");
        }
    };

    this.MoveCancelClick = function () {
        this.clickCounter = 0;
        $("#treemodal").modal("hide");
    };

    this.UpdateSuccess = function () {
        this.$submit.trigger("click");
        $("#treemodal").modal("hide");
        this.clickCounter = 0;
    };

    this.setFilterboxValue = function (i, obj) {
        $(obj).children('div').children('.eb_finput').on("keydown", function (event) {
            if (event.keyCode === $.ui.keyCode.TAB &&
                $(this).autocomplete("instance").menu.active) {
                event.preventDefault();
            }
        });
        var name = $(obj).children('span').text();
        var tempobj = $.grep(this.EbObject.Columns.$values, function (col) { return col.name === name; });
        if (tempobj.length > 0)
            var idx = tempobj[0].data;
        var data = arrayColumn(this.unformatedData, idx);
        data = data.filter(function (elem, pos) {
            return data.indexOf(elem) === pos;
        });
        if ($(obj).children('div').children('.eb_finput').attr("data-coltyp") === "string") {
            this.setFilterboxValueInner(obj, data);
        }
        else {
            if ($(obj).children('div').length === 0) {
                var $lctrl = $("#" + this.tableId + "_wrapper .DTFC_LeftHeadWrapper table tr[class=addedbyeb] th:eq(" + i + ")").find(".eb_finput");
                var $rctrl = $("#" + this.tableId + "_wrapper .DTFC_RightHeadWrapper table tr[class=addedbyeb] th:eq(" + i + ")").find(".eb_finput");
                if ($lctrl.length > 0) {
                    this.setfiletrvalueFixedcolumns($lctrl, data);
                }
                if ($rctrl.length > 0) {
                    this.setfiletrvalueFixedcolumns($rctrl, data);
                }
            }

        }
    };

    this.setFilterboxValueInner = function (obj, data) {
        $(obj).children('div').children('.eb_finput').autocomplete({
            source: function (request, response) {
                response($.ui.autocomplete.filter(
                    $.unique(data), extractLast(request.term)));
            }.bind(this),
            focus: function () {
                return false;
            },
            select: function (event, ui) {
                var terms = splitval(this.value);
                terms.pop();
                terms.push(ui.item.value);
                terms.push("");
                this.value = terms.join(" | ");
                return false;
            },
            search: function (event, ui) {
            }
        });
    }

    this.setfiletrvalueFixedcolumns = function ($ctrl, data) {
        if ($ctrl.attr("data-coltyp") === "string") {
            $ctrl.autocomplete({
                source: function (request, response) {
                    response($.ui.autocomplete.filter(
                        $.unique(data), extractLast(request.term)));
                }.bind(this),
                focus: function () {
                    return false;
                },
                select: function (event, ui) {
                    var terms = splitval(this.value);
                    terms.pop();
                    terms.push(ui.item.value);
                    terms.push("");
                    this.value = terms.join(" | ");
                    return false;
                },
                search: function (event, ui) {
                }
            });
        }
    };

    this.orderingEvent = function (e) {
        //var col = $(e.target).children('span').text();
        var col = $(e.target).text();
        var tempobj = $.grep(this.Api.settings().init().aoColumns, function (obj) { return obj.sTitle === col });
        var cls = $(e.target).attr('class');
        if (col !== '' && col !== "#") {
            this.order_info.col = tempobj[0].name;
            this.order_info.dir = (cls.indexOf('sorting_asc') > -1) ? 1 : 0;
            //this.orderColl = $.grep(this.orderColl, function (obj) { return obj.Column !== this.order_info.col }.bind(this));
            //if (this.EbObject.rowGrouping.$values.length === 0)
            //    this.orderColl = [];
            this.orderColl = [];
            this.orderColl.push(new order_obj(this.order_info.col, this.order_info.dir));
        }
    };

    this.GetFiltersFromSettingsTbl = function (zidx) {
        this.zindex = zidx;
        if (this.zindex === 50)
            this.eb_filter_controls_4fc = [];
        else if (this.zindex === 1)
            this.eb_filter_controls_4sb = [];

        //$.each(this.ebSettings.Columns.$values, this.GetFiltersFromSettingsTbl_inner.bind(this));
        $.each(this.Api.settings().init().aoColumns, this.GetFiltersFromSettingsTbl_inner.bind(this));
    };

    this.GetFiltersFromSettingsTbl_inner = function (i, col) {
        var _ls = "";

        if (col.bVisible === true) {
            var span = "<span hidden>" + col.name + "</span>";
            //var span = "";

            var htext_class = this.tableId + "_htext";

            var data_colum = "data-colum='" + col.name + "'";
            var data_table = "data-table='" + this.tableId + "'";

            var header_select = this.tableId + "_" + col.name + "_hdr_sel";
            var header_text1 = this.tableId + "_" + col.name + "_hdr_txt1";
            var header_text2 = this.tableId + "_" + col.name + "_hdr_txt2";

            _ls += "<th>";
            if (col.name === "serial") {
                _ls += (span + "<a class='btn btn-sm center-block'  id='clearfilterbtn_" + this.tableId + "' data-table='@tableId' data-toggle='tooltip' title='Clear Filter' style='height:100%'><i class='fa fa-filter' aria-hidden='true' style='color:black'></i></a>");
            }
            else if (col.IsCustomColumn) {
                _ls += span;
            }
            else {
                if (col.RenderType === parseInt(gettypefromString("Int32")) || col.RenderType === parseInt(gettypefromString("Decimal")) || col.RenderType === parseInt(gettypefromString("Int64")) || col.RenderType == parseInt(gettypefromString("Double")) || col.RenderType == parseInt(gettypefromString("Numeric"))) {
                    if (parseInt(EbEnums.ControlType.Text) === col.filterControl)
                        _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else if (parseInt(EbEnums.ControlType.Date) === col.filterControl)
                        _ls += (span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else
                        _ls += (span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                }
                else if (col.RenderType === parseInt(gettypefromString("String"))) {
                    //if (this.dtsettings.filterParams === null || this.dtsettings.filterParams === undefined)
                    if (parseInt(EbEnums.ControlType.Numeric) === col.filterControl)
                        _ls += (span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else if (parseInt(EbEnums.ControlType.Date) === col.filterControl)
                        _ls += (span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else
                        _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    //else
                    //   _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, this.dtsettings.filterParams));
                }
                else if (col.RenderType === parseInt(gettypefromString("DateTime")) || col.RenderType === parseInt(gettypefromString("Date"))) {
                    if (parseInt(EbEnums.ControlType.Numeric) === col.filterControl)
                        _ls += (span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else if (parseInt(EbEnums.ControlType.Text) === col.filterControl)
                        _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else
                        _ls += (span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                }
                else if (col.RenderType === parseInt(gettypefromString("Boolean")) && col.name !== "checkbox")
                    _ls += (span + this.getFilterForBoolean(col.name, this.tableId, this.zindex));
                else
                    _ls += (span);
            }

            _ls += ("</th>");

            ((this.zindex === 50) ? this.eb_filter_controls_4fc : this.eb_filter_controls_4sb).push(_ls);
        }
    };

    this.getFilterForNumeric = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx, DefOp) {
        var coltype = "data-coltyp='number'";
        var drptext = "";
        var op = String.empty;
        switch (DefOp.toString()) {
            case EbEnums.NumericOperators.Equals: op = '='; break;
            case EbEnums.NumericOperators.LessThan: op = '<'; break;
            case EbEnums.NumericOperators.GreaterThan: op = '>'; break;
            case EbEnums.NumericOperators.LessThanOrEqual: op = '<='; break;
            case EbEnums.NumericOperators.GreaterThanOrEqual: op = '>='; break;
            case EbEnums.NumericOperators.Between: op = 'B'; break;
            default: op = '=';
        }
        drptext = "<div class='input-group input-group-sm'>" +
            "<div class='input-group-btn'>" +
            " <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'> " + op + " </button>" +
            " <ul class='dropdown-menu'>" +//  style='z-index:" + zidx.toString() + "'
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> = </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Equal to</span></li>" +
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> < </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Less than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> > </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Greater than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> <= </a><span class='filtertext eb_fsel" + this.tableId + "'> Less than or Equal</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> >= </a><span class='filtertext eb_fsel" + this.tableId + "'> Greater than or Equal</span></li>" +
            "<li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> B </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Between</span></li>" +
            " </ul>" +
            " </div>" +
            " <input type='number' data-toggle='tooltip' class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            //" <span class='input-group-btn'></span>" +
            //" <input type='number' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return drptext;
    };

    this.getFilterForDateTime = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx, DefOp) {
        var op = String.empty;
        switch (DefOp.toString()) {
            case EbEnums.NumericOperators.Equals: op = '='; break;
            case EbEnums.NumericOperators.LessThan: op = '<'; break;
            case EbEnums.NumericOperators.GreaterThan: op = '>'; break;
            case EbEnums.NumericOperators.LessThanOrEqual: op = '<='; break;
            case EbEnums.NumericOperators.GreaterThanOrEqual: op = '>='; break;
            case EbEnums.NumericOperators.Between: op = 'B'; break;
            default: op = '=';
        }
        var coltype = "data-coltyp='date'";
        var filter = "<div class='input-group input-group-sm'>" +
            "<div class='input-group-btn'>" +
            " <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'> " + op + " </button>" +
            "<ul class='dropdown-menu'>" +//  style='z-index:" + zidx.toString() + "'
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> = </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Equal to</span></li>" +
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> < </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Less than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> > </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Greater than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> <= </a><span class='filtertext eb_fsel" + this.tableId + "'> Less than or Equal</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> >= </a><span class='filtertext eb_fsel" + this.tableId + "'> Greater than or Equal</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> B </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Between</span></li>" +
            " </ul>" +
            " </div>" +
            " <input type='text' placeholder='" + this.datePattern + "' data-toggle='tooltip' class='no-spin form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            //" <span class='input-group-btn'></span>" +
            //" <input type='date' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">" +
            " </div> ";

        return filter;

    };

    this.getFilterForString = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx, DefOp) {
        var op = String.empty;
        switch (DefOp.toString()) {
            case EbEnums.StringOperators.Equals: op = '='; break;
            case EbEnums.StringOperators.Startwith: op = 'x*'; break;
            case EbEnums.StringOperators.EndsWith: op = '*x'; break;
            case EbEnums.StringOperators.Between: op = '*x*'; break;
            default: op = '=';
        }
        var coltype = " data-coltyp='string'";
        var drptext = "";
        drptext = "<div class='input-group input-group-sm'>" +
            "<div class='input-group-btn'>" +// style='z-index:" + zidx.toString() + "'
            " <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'>" + op + "</button>" +
            " <ul class='dropdown-menu'>" +

            "   <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> x* </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 5px;'> Starts with</span></li>" +
            "  <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> *x </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 5px;'> Ends with</span></li>" +
            "  <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> *x* </a><span class='filtertext eb_fsel" + this.tableId + "' > Contains</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> = </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 9px;'> Exact match</span></li>" +
            " </ul>" +
            " </div>" +
            " <input type='text' data-toggle='tooltip'  class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return drptext;
    };

    this.getFilterForBoolean = function (colum, tableId, zidx) {
        var filter = "";
        var id = tableId + "_" + colum + "_hdr_txt1";
        var cls = tableId + "_hchk";
        filter = "<input type='checkbox' id='" + id + "' data-toggle='tooltip' title='' data-colum='" + colum + "' data-coltyp='boolean' data-table='" + tableId + "' class='" + cls + " " + tableId + "_htext eb_fbool" + this.tableId + "' style='margin-left: 50%;'></center>";
        return filter;
    };

    this.clearFilter = function () {
        var flag = false;
        var tableid = this.tableId;
        $('.' + this.tableId + '_htext').each(function (i) {

            if ($(this).hasClass(tableid + '_hchk')) {
                if (!($(this).is(':indeterminate'))) {
                    flag = true;
                    $(this).prop("indeterminate", true);
                }
            }
            else {
                if ($(this).val() !== '') {
                    flag = true;
                    $(this).val('');
                }
            }
        });
        if (flag || this.filterFlag) {
            this.columnSearch = [];
            this.Api.ajax.reload();
            this.filterFlag = false;
            $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-times").addClass("fa-filter");
            $(".tooltip").remove();
        }
    };

    this.setLiValue = function (e) {
        let elemnt = ($(e.target).is("a")) ? $(e.target) : $(e.target).siblings("a");
        var selText = $(elemnt).text();
        var table = $(elemnt).attr('data-table');
        var flag = false;
        var colum = $(elemnt).attr('data-colum');
        var ctype = $(elemnt).parents('.input-group').find("input").attr('data-coltyp');
        var dateclas = (ctype === "date") ? "no-spin" : "";
        $(elemnt).parents('.input-group-btn').find('.dropdown-toggle').html(selText);
        if (selText.trim() === 'B') {
            if ($(elemnt).parents('.input-group').find("input").length == 1) {
                if (ctype === "date") {
                    $(elemnt).parents('.input-group').append("<input type='text' placeholder='" + this.datePattern + "' class='" + dateclas + " between-inp form-control eb_finput " + this.tableId + "_htext' id='" + this.tableId + "_" + colum + "_hdr_txt2' data-coltyp='" + ctype + "'>");
                    $("#" + this.tableId + "_" + colum + "_hdr_txt2").datepicker({
                        dateFormat: this.datePattern.replace(new RegExp("M", 'g'), "m").replace(new RegExp("yy", 'g'), "y"),
                        beforeShow: function (elem, obj) {
                            $(".ui-datepicker").addClass("datecolumn-picker");
                        }
                    });
                    $("#" + this.tableId + "_" + colum + "_hdr_txt2").on("click", function () {
                        $(this).datepicker("show");
                    });
                }
                else {
                    $(e.target).parents('.input-group').append("<input type='number' class='" + dateclas + " between-inp form-control eb_finput " + this.tableId + "_htext' id='" + this.tableId + "_" + colum + "_hdr_txt2' data-coltyp='" + ctype + "'>");
                }
                $("#" + this.tableId + "_" + colum + "_hdr_txt1").addClass("between-inp");
                $("#" + this.tableId + "_" + colum + "_hdr_txt2").on("keyup", this.call_filter);

            }
        }
        else if (selText.trim() !== 'B') {
            if ($(elemnt).parents('.input-group').find("input").length == 2) {
                $(elemnt).parents('.input-group').find("input").eq(1).remove();
                $("#" + this.tableId + "_" + colum + "_hdr_txt1").removeClass("between-inp");
            }
        }
        this.Api.columns.adjust();
        e.preventDefault();
    };

    this.call_filter = function (e) {
        if (e.keyCode === 13) {
            var flag = true;
            if ($(e.target).siblings(".eb_finput").length === 1) {
                if ($(e.target).val() === "") {
                    $(e.target).css("border-color", "red");
                    flag = false;
                }
                else
                    $(e.target).css("border-color", "#ccc");
                if ($(e.target).siblings(".eb_finput").val() === "") {
                    $(e.target).siblings(".eb_finput").css("border-color", "red");
                    flag = false;
                }
                else
                    $(e.target).siblings(".eb_finput").css("border-color", "#ccc");
            }
            else {
                if ($(e.target).val().trim() == "") {
                    flag = false;
                    $(e.target).css("border-color", "red");
                }
                else
                    $(e.target).css("border-color", "#ccc");
            }

            if (flag) {
                this.columnSearch = this.repopulate_filter_arr();
                $('#' + this.tableId).DataTable().ajax.reload();
                if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-filter"))
                    $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-filter").addClass("fa-times");
            }
        }
        else {
            $("[data-coltyp=date]").datepicker("hide");
            this.columnSearch = this.repopulate_filter_arr();
            if (typeof (e.key) === "undefined") {
                $('#' + this.tableId).DataTable().ajax.reload();
                if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-filter"))
                    $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-filter").addClass("fa-times");
            }
        }

    }.bind(this);

    this.dblclickDateColumn = function () {
        this.type = "text";
        this.select();
    };

    this.pasteDateColumn = function (e) {
        var data = e.originalEvent.clipboardData.getData('Text');
        var dt = data.split("/");
        this.value = [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("-");
        e.preventDefault();
    };

    this.focusoutDateColumn = function () {
        var data = $(event.target)[0].value;
        var dt = data.split("/");
        if (dt.length === 1)
            dt = data.split("-");
        if (dt[0].length <= 2)
            data = [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("-");
        else
            data = [dt[0].trim(), dt[1].trim(), dt[2].trim()].join("-");
        $(event.target)[0].value = formatDate(data);
        $(event.target)[0].type = "date";
        if (this.Api)
            this.Api.columns.adjust();
    };

    this.changeDateOrder = function (data) {
        var dt = data.split("/");
        var dtp = this.datePattern.split("/");
        if (dt.length === 1)
            dt = data.split("-");
        if (dtp.length === 1)
            dtp = this.datePattern.split("-");

        if (dt[0].length <= 2)
            return [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("-");
        else
            return [dt[0].trim(), dt[1].trim(), dt[2].trim()].join("-");
    };

    this.retainDateOrder = function (data) {
        var dt = data.split("-");
        return [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("/");
    };

    this.toggleInFilter = function (e) {
        var table = $(e.target).attr('data-table');
        this.call_filter({ keyCode: 10 });
        //this.Api.ajax.reload();
    };

    this.toggleFilterdialog = function () {
        $("#" + this.ContextId).toggle();
    };

    this.togglePPGrid = function () {
        $(".ppcont").toggle();
    };

    this.fselect_func = function (e) {
        let element = ($(e.target).is("a")) ? $(e.target) : $(e.target).siblings("a");
        var selValue = $(element).text().trim();
        $(element).parents('.input-group-btn').find('.dropdown-toggle').html(selValue);
        var table = $(element).attr('data-table');
        var colum = $(element).attr('data-column');
        var decip = $(element).attr('data-decip');
        var col = this.Api.column(colum + ':name');
        var ftrtxt;
        var agginfo = $.grep(this.eb_agginfo, function (obj) { return obj.colname === colum; });
        ftrtxt = '.dataTables_scrollFootInner #' + this.tableId + '_' + colum + '_ftr_txt0';
        if ($(ftrtxt).length === 0)
            ftrtxt = '.DTFC_LeftFootWrapper #' + this.tableId + '_' + colum + '_ftr_txt0';
        if ($(ftrtxt).length === 0)
            ftrtxt = '.DTFC_RightFootWrapper #' + this.tableId + '_' + colum + '_ftr_txt0';

        if (selValue === '')
            pageTotal = (typeof this.summary[agginfo[0].data] !== "undefined") ? this.summary[agginfo[0].data][0] : 0;
        else if (selValue === 'x')
            pageTotal = (typeof this.summary[agginfo[0].data] !== "undefined") ? this.summary[agginfo[0].data][1] : 0;

        $(ftrtxt).val(pageTotal);
        e.preventDefault();
        //e.stopPropagation();
    };

    this.clickAlSlct = function (e) {
        //var tableid = $(e.target).attr('data-table');
        if (e.target.checked)
            $('#' + this.tableId + '_wrapper tbody [type=checkbox]:not(:checked)').trigger('click');
        else
            $('#' + this.tableId + '_wrapper tbody [type=checkbox]:checked').trigger('click');

        e.stopPropagation();
    };

    this.renderCheckBoxCol = function (data2, type, row, meta) {
        if (this.FlagPresentId) {
            var idpos = $.grep(this.ebSettings.Columns.$values, function (e) { return e.name === "id"; })[0].data;
            this.rowId = meta.row; //do not remove - for updateAlSlct
            if (row[idpos])
                return "<input type='checkbox' class='" + this.tableId + "_select' name='" + this.tableId + "_id' value='" + row[idpos].toString() + "'/>";
            else
                return "<input type='checkbox' class='" + this.tableId + "_select'/>";
        }
        else
            return "<input type='checkbox' class='" + this.tableId + "_select'/>";
    };

    this.updateAlSlct = function (e) {
        var idx = this.Api.row($(e.target).parent().parent()).index();
        if (e.target.checked) {
            this.Api.rows(idx).select();
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", true);
        }
        else {
            this.Api.rows(idx).deselect();
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", true);
        }
        var CheckedCount = $('.' + this.tableId + '_select:checked').length;
        var UncheckedCount = this.Api.rows().count() - CheckedCount;
        if (CheckedCount === this.Api.rows().count()) {
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", false);
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop('checked', true);
        }
        else if (UncheckedCount === this.Api.rows().count()) {
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", false);
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop('checked', false);
        }
    };

    this.showOrHideAggrControl = function (e) {
        $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner tfoot tr:eq(0)').toggle();
        $("#" + this.tableId + "_wrapper .DTFC_LeftFootWrapper tfoot tr:eq(0)").toggle();
        $("#" + this.tableId + "_wrapper .DTFC_RightFootWrapper tfoot tr:eq(0)").toggle();
        this.Api.columns.adjust();
    };

    this.link2NewTable = function (e) {
        this.rowgroupFilter = [];
        var rows = this.Api.rows(idx).nodes();
        var cData;
        var colindex = -1;
        this.isContextual = true;
        if ($(e.target).closest("a").attr("data-latlong") !== undefined)
            cData = $(e.target).closest("a").attr("data-latlong");
        else if ($(e.target).closest("a").attr("data-inline") !== undefined) {
            cData = $(e.target).closest("a").attr("data-data");
            this.inline = true;
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        else if ($(e.target).closest("a").attr("data-popup") !== undefined) {
            cData = $(e.target).closest("a").attr("data-data");
            this.popup = true;
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        else {
            cData = $(e.target).text();
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        this.linkDV = $(e.target).closest("a").attr("data-link");
        var idx = this.Api.row($(e.target).parents().closest("td")).index();
        if (typeof (idx) !== "undefined")
            this.rowData = this.unformatedData[idx];
        else {//incomplete...
            this.rowData = [];
        }
        var x = this.getStaticParameter(colindex);
        this.filterValuesforForm = [];
        if (parseInt(this.linkDV.split("-")[2]) !== EbObjectTypes.WebForm)
            this.filterValues = this.getFilterValues().concat(this.getfilterFromRowdata()).concat(x);
        else
            this.filterValuesforForm = this.getfilterFromRowdata();

        if ($(e.target).parent("b").attr("data-rowgroup") !== undefined) {

            this.getRowGroupFilter($(e.target).parent("b"));
            if (this.CurrentRowGroup.$type.indexOf("SingleLevelRowGroup") !== -1) {
                $.each($(e.target).parent("b").siblings("b"), function (i, elem) {
                    this.getRowGroupFilter($(elem));
                }.bind(this));
            }
            else {
                var $elem = $(e.target).parents().closest(".group");
                let count = $elem.attr("group");
                for (var i = count - 1; i >= 0; i--) {
                    $elem = $(e.target).parents().closest(".group").prevAll().closest(".group[group=" + i + "]").last();
                    this.getRowGroupFilter($elem.children().find("b"));
                }
            }

            this.filterValues = this.filterValues.concat(this.rowgroupFilter);
        }

        if (this.inline) {
            this.inline = false;
            if ($(rows).eq(idx).next().attr("id") !== "containerrow" + colindex) {
                this.drawInlinedv(rows, e, idx, colindex);
            }
            else {
                this.OpenInlineDv(rows, e, idx, colindex);
            }
        }
        else if (this.popup) {
            this.popup = false;
            CallWebFormCollectionRender({
                _source: 'tv', _refId: this.linkDV,
                _params: btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))),
                _mode: 1, _locId: ebcontext.locations.getCurrent()
            });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../webform/index?_r=${this.linkDV}&_p=${btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm))))}&_m=1${this.dvformMode}&_l=${store.get("Eb_Loc-" + this.TenantId + this.UserId)}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            if (this.login === "uc")
                dvcontainerObj.drawdvFromTable(btoa(unescape(encodeURIComponent(JSON.stringify(this.rowData)))), btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues)))), btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))), cData.toString(), this.dvformMode);//, JSON.stringify(this.filterValues)
            else
                this.OpeninNewTab(idx, cData);
        }
        //this.filterValues = [];
    };

    this.drawInlinedv = function (rows, e, idx, colindex) {
        $("#eb_common_loader").EbLoader("show");
        $(e.target).parents().closest("td").siblings().children(".tablelink").children("i").removeClass("fa-caret-up").addClass("fa-caret-down");
        this.call2newDv(rows, idx, colindex);
        $(e.target).closest("I").removeClass("fa-caret-down").addClass("fa-caret-up");
    };
    this.OpenInlineDv = function (rows, e, idx, colindex) {
        if ($(e.target).closest("I").hasClass("fa-caret-up")) {
            $(e.target).closest("I").removeClass("fa-caret-up").addClass("fa-caret-down");
            $(rows).eq(idx).next().hide();
        }
        else {
            $(e.target).closest("I").removeClass("fa-caret-down").addClass("fa-caret-up");
            $(rows).eq(idx).next().show();
        }
        this.Api.columns.adjust();
    };

    this.getRowGroupFilter = function ($elem) {
        let name = $elem.attr("data-colname");
        let type = parseInt($elem.attr("data-coltype"));
        let val = $elem.attr("data-data");
        if (type === 5 || type === 6)
            val = val.split("/").join('-');
        this.rowgroupFilter.push(new fltr_obj(type, name, val));
    };

    this.call2newDv = function (rows, idx, colindex) {
        $.ajax({
            type: "POST",
            url: "../DV/getdv",
            data: { refid: this.linkDV },
            success: this.GetData4InlineDv.bind(this, rows, idx, colindex)
        });
    };

    this.GetData4InlineDv = function (rows, idx, colindex, result) {
        var Dvobj = JSON.parse(result).DsObj;
        var param = this.Params4InlineTable(Dvobj);
        $.ajax({
            type: "POST",
            url: "../DV/getData4Inline",
            data: param,
            success: this.LoadInlineDv.bind(this, rows, idx, Dvobj, colindex)
        });
    };

    this.LoadInlineDv = function (rows, idx, Dvobj, colindex, result) {
        let colspan = Dvobj.Columns.$values.length;
        let str = "";
        $.each(this.rowgroupCols, function (k, obj) {
            str += "<td>&nbsp;</td>";
        });
        $.each(this.extraCol, function (k, obj) {
            if (obj.bVisible)
                str += "<td>&nbsp;</td>";
        });

        $(rows).eq(idx).next(".containerrow").remove();
        if (Dvobj.$type.indexOf("EbTableVisualization") !== -1) {
            $(rows).eq(idx).after("<tr class='containerrow' id='containerrow" + colindex + "'>" + str + "<td colspan='" + colspan + "'><div class='inlinetable '><div class='close' type='button' title='Close'>x</div><div class='Obj_title' id='objName" + idx + "'>" + Dvobj.DisplayName + "</div><table id='tbl" + idx + "' class='table display table-bordered compact'></table></td></tr></div>");

            var o = new Object();
            o.tableId = "tbl" + idx;
            o.showFilterRow = false;
            o.showSerialColumn = true;
            o.showCheckboxColumn = false;
            o.source = "inline";
            o.scrollHeight = "200px";
            o.dvObject = Dvobj;
            o.data = result;
            o.keys = false;
            this.datatable = new EbBasicDataTable(o);
            if (this.EbObject.DisableRowGrouping || this.EbObject.RowGroupCollection.$values.length === 0)
                $(".inlinetable").css("width", $(window).width() - 115);
            else
                $(".inlinetable").css("width", $(window).width() - 175);
            this.datatable.Api.columns.adjust();
        }
        else {
            $(rows).eq(idx).after("<tr class='containerrow' id='containerrow" + colindex + "'>" + str + "<td colspan='" + colspan + "'><div class='inlinetable'><div class='close' type='button' title='Close'>x</div><div class='Obj_title' id='objName" + idx + "'>" + Dvobj.DisplayName + "</div><div id='canvasDivchart" + idx + "' ></div></td></tr></div>");
            var o = new Object();
            o.tableId = "chart" + idx;
            o.dvObject = Dvobj;
            o.data = result.data;
            this.chartApi = new EbBasicChart(o);
            $(".inlinetable").css("height", "380px");
            $("#canvasDivchart" + idx).css("width", $(window).width() - 100);
            $("#canvasDivchart" + idx).css("height", "inherit");
        }
        $(".containerrow .close").off("click").on("click", function (e) {
            $(e.target).parents().closest(".containerrow").prev().children().find("I").removeClass("fa-caret-up").addClass("fa-caret-down");
            $(e.target).parents().closest(".containerrow").remove();
            this.Api.columns.adjust();
        }.bind(this));

        $("#eb_common_loader").EbLoader("hide");
        this.Api.columns.adjust();
    };

    this.Params4InlineTable = function (Dvobj) {
        var dq = new Object();
        dq.RefId = Dvobj.DataSourceRefId;
        dq.TFilters = [];
        dq.Params = this.filterValues;
        dq.Start = 0;
        dq.Length = 500;
        dq.DataVizObjString = JSON.stringify(Dvobj);
        return dq;
    };

    this.getStaticParameter = function (index) {
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.data == index });
        var array = [];
        if (temp[0].StaticParameters.$values.length > 0) {
            $.each(temp[0].StaticParameters.$values, function (i, obj) {
                array.push(new fltr_obj(obj.Type, obj.Name, obj.Value));
            });
        }
        return array;
    };

    this.deleteTab = function (e) {
        var tabContentId = $(e.target).parent().attr("href");
        $(e.target).parent().parent().remove(); //remove li of tab
        $('#table_tabs a:last').tab('show'); // Select first tab
        $(tabContentId).remove();
    };

    this.CopyToClipboard = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-copy').click();
    };

    this.ExportToPrint = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-print')[0].click();
    };


    this.ExportToExcel = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-excel').click();
        //var ob = new Object();
        //ob.DataVizObjString = JSON.stringify(this.EbObject);
        //ob.Params = this.filterValues;
        //ob.TFilters = this.columnSearch;
        //this.ss = new EbServerEvents({ ServerEventUrl: 'https://se.eb-test.shop', Channels: ["ExportToExcel"] });
        //this.ss.onExcelExportSuccess = function (url) {
        //    window.location.href = url;
        //};
        //$.ajax({
        //    type: "POST",
        //    url: "../DV/exportToexcel",
        //    data: { req: ob }
        //});

    };

    this.ExportToCsv = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-csv').click();
    };

    this.ExportToPdf = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-pdf').click();
    };

    this.printSelected = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-print')[1].click();
    };

    this.printAll = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-print')[0].click();
    };

    this.SwitchToChart = function () {
        $('#' + this.tableId).parents().find(".sub-windows").hide();
        this.stickBtn.hide();
        let chartobj = new EbObjects["EbChartVisualization"]("Container_" + Date.now());
        chartobj.Columns = JSON.parse(JSON.stringify(this.EbObject.Columns));
        chartobj.DSColumns = JSON.parse(JSON.stringify(this.EbObject.DSColumns));
        chartobj.DataSourceRefId = this.EbObject.DataSourceRefId;
        chartobj.Pippedfrom = this.EbObject.Name;
        let chartapi = eb_chart(chartobj.DataSourceRefId, null, null, chartobj, null, this.tabNum, this.ssurl, this.login, this.counter, this.MainData, btoa(JSON.stringify(this.rowData)), btoa(JSON.stringify(this.filterValues)), this.cellData, this.propGrid);
    };

    this.openColumnTooltip = function (e, i) {
        //$(e.currentTarget).siblings(".popover").find(".popover-content").empty().append(atob($(e.currentTarget).attr("data-contents")));
        //$(e.currentTarget).siblings(".popover").find(".arrow").remove();
    };

    this.collapseFilter = function () {
        this.filterBox.toggle();
        if (this.filterBox.css("display") == "none") {
            $("#btnCollapse" + this.tableId).children().remove();
            $("#btnCollapse" + this.tableId).append("<i class='fa fa-chevron-down' aria-hidden='true'></i>");
        }
        else {
            $("#btnCollapse" + this.tableId).children().remove();
            $("#btnCollapse" + this.tableId).append("<i class='fa fa-chevron-up' aria-hidden='true'></i>");
        }
    };


    this.updateRenderFunc = function () {
        $.each(this.ebSettings.Columns.$values, this.updateRenderFunc_Inner.bind(this));
    };

    this.updateRenderFunc_Inner = function (i, col) {
        this.ebSettings.Columns.$values[i].sClass = "";
        this.ebSettings.Columns.$values[i].className = "";

        if (col.RenderType === parseInt(gettypefromString("Int32")) || col.RenderType == parseInt(gettypefromString("Decimal")) || col.RenderType == parseInt(gettypefromString("Int64")) || col.RenderType == parseInt(gettypefromString("Numeric"))) {

            if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                this.ebSettings.Columns.$values[i].className += " tdheight dt-right";
        }
        if (col.RenderType === parseInt(gettypefromString("Boolean"))) {
            if (this.ebSettings.Columns.$values[i].name === "eb_void" || this.ebSettings.Columns.$values[i].name === "sys_cancelled") {
                this.ebSettings.Columns.$values[i].render = (this.ebSettings.Columns.$values[i].name === "sys_locked") ? this.renderLockCol.bind(this) : this.renderEbVoidCol.bind(this);
                this.ebSettings.Columns.$values[i].mRender = (this.ebSettings.Columns.$values[i].name === "sys_locked") ? this.renderLockCol.bind(this) : this.renderEbVoidCol.bind(this);
            }
            else {
                if (this.ebSettings.Columns.$values[i].RenderAs.toString() === EbEnums.BooleanRenderType.IsEditable) {
                    this.ebSettings.Columns.$values[i].render = this.renderEditableCol.bind(this);
                    this.ebSettings.Columns.$values[i].mRender = this.renderEditableCol.bind(this);
                }
                else if (this.ebSettings.Columns.$values[i].RenderAs.toString() === EbEnums.BooleanRenderType.Icon) {
                    this.ebSettings.Columns.$values[i].render = this.renderIconCol.bind(this);
                    this.ebSettings.Columns.$values[i].mRender = this.renderIconCol.bind(this);
                }
                else {
                    this.ebSettings.Columns.$values[i].render = function (data, type, row, meta) { return data; };
                    this.ebSettings.Columns.$values[i].mRender = function (data, type, row, meta) { return data; };
                }
            }
            if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                this.ebSettings.Columns.$values[i].className += " tdheight text-center";
        }
        if (col.RenderType === parseInt(gettypefromString("String")) || col.RenderType == parseInt(gettypefromString("Double"))) {
            if (this.ebSettings.Columns.$values[i].RenderAs.toString() === EbEnums.StringRenderType.Chart) {
                this.ebSettings.Columns.$values[i].render = this.lineGraphDiv.bind(this);
                this.ebSettings.Columns.$values[i].mRender = this.lineGraphDiv.bind(this);
            }
            else if (this.ebSettings.Columns.$values[i].RenderAs.toString() === EbEnums.StringRenderType.Image) {
                this.ebSettings.Columns.$values[i].render = this.renderFBImage.bind(this);
                this.ebSettings.Columns.$values[i].mRender = this.renderFBImage.bind(this);
            }
            else if (this.ebSettings.Columns.$values[i].RenderAs.toString() === EbEnums.StringRenderType.Icon) {
                this.ebSettings.Columns.$values[i].render = this.renderIconCol.bind(this);
                this.ebSettings.Columns.$values[i].mRender = this.renderIconCol.bind(this);
            }

            if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                this.ebSettings.Columns.$values[i].className += " tdheight dt-left";
        }
        if (col.RenderType === parseInt(gettypefromString("Date")) || col.RenderType == parseInt(gettypefromString("DateTime"))) {
            if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                this.ebSettings.Columns.$values[i].className += " tdheight dt-left";
        }
        if (col.name === "eb_created_by" || col.name === "eb_lastmodified_by")
            col.className += " dt-left";
        if (col.Font !== null) {
            var style = document.createElement('style');
            style.type = 'text/css';
            var array = [this.tableId, col.name, col.Font.FontName, col.Font.Size, col.Font.color.replace("#", "")];
            if ($("." + array.join("_")).length === 0) {
                style.innerHTML = "." + array.join("_") + "{font-family: " + col.Font.FontName + "!important; font-size: " + col.Font.Size + "px!important; color: " + col.Font.color + "!important; }";
                document.getElementsByTagName('body')[0].appendChild(style);
            }
            this.ebSettings.Columns.$values[i].className = array.join("_");
            this.ebSettings.Columns.$values[i].sClass = array.join("_");
        }

        if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Left)
            this.ebSettings.Columns.$values[i].className += " tdheight dt-left";
        else if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Right)
            this.ebSettings.Columns.$values[i].className += " tdheight dt-right";
        else if (this.ebSettings.Columns.$values[i].Align.toString() === EbEnums.Align.Center)
            this.ebSettings.Columns.$values[i].className += " tdheight text-center";

        this.ebSettings.Columns.$values[i].sClass = this.ebSettings.Columns.$values[i].className;
    };

    this.renderProgressCol = function (deci, data, type, row, meta) {
        return "<div class='progress'><div class='progress-bar' role='progressbar' aria-valuenow='" + parseFloat(data.toString()).toFixed(deci) + "' aria-valuemin='0' aria-valuemax='100' style='width:" + data.toString() + "%'>" + parseFloat(data.toString()).toFixed(deci) + "</div></div>";
    };

    this.renderToDecimalPlace = function (data, type, row, meta) {
        return parseFloat(data).toFixed();
    };

    this.renderEditableCol = function (data) {
        return (data === true) ? "<input type='checkbox' data-toggle='toggle' data-size='mini' checked>" : "<input type='checkbox' data-toggle='toggle' data-size='mini'>";
    };

    this.renderIconCol = function (data, type, row, meta) {
        if (meta.settings.aoColumns[meta.col].TrueValue.toLowerCase() === data.toLowerCase())
            return "<i class='fa fa-check' aria-hidden='true'  style='color:green'></i>";
        else if (meta.settings.aoColumns[meta.col].FalseValue.toLowerCase() === data.toLowerCase())
            return "<i class='fa fa-times' aria-hidden='true' style='color:red'></i>";
        else
            return data;
    };

    this.renderEbVoidCol = function (data) {
        return (data === "T") ? "<i class='fa fa-ban' aria-hidden='true'></i>" : "";
    };

    this.renderLockCol = function (data) {
        return (data === true) ? "<i class='fa fa-lock' aria-hidden='true'></i>" : "";
    };

    this.renderlink4NewTable = function (data, type, row, meta) {
        if (meta.settings.aoColumns[meta.col].LinkType.toString() === EbEnums.LinkTypeEnum.Popout)
            return "<a href='#' oncontextmenu='return false' class ='tablelink' data-link='" + meta.settings.aoColumns[meta.col].LinkRefId + "'>" + data + "</a>";
        else if (meta.settings.aoColumns[meta.col].LinkType.toString() === EbEnums.LinkTypeEnum.Inline)
            return data + `<a href='#' oncontextmenu='return false' class ='tablelink' data-link='${meta.settings.aoColumns[meta.col].LinkRefId}' data-inline="true" data-data='${data}'> <i class="fa fa-plus"></i></a>`;
        else
            return "<a href='#' oncontextmenu='return false' class ='tablelink' data-link='" + meta.settings.aoColumns[meta.col].LinkRefId + "'>" + data + "</a>" + ` &nbsp; <a href='#' oncontextmenu='return false' class ='tablelink' data-link='${meta.settings.aoColumns[meta.col].LinkRefId}' data-inline="true" data-data='${data}'> <i class="fa fa-plus"></i></a>`;
    };

    this.renderlinkandDecimal = function (deci, data) {
        return "<a href='#' oncontextmenu='return false' class ='tablelink' data-link='" + this.linkDV + "'>" + parseFloat(data).toFixed(deci) + "</a>";
    };

    this.colorRow = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        $.each(this.ebSettings.Columns.$values, function (i, value) {
            if (value.name === 'sys_row_color') {
                HEX = Number(aData[value.data]).toString(16);
                var t = (HEX.toString().length < 6) ? ("0" + HEX.toString()) : HEX;
                $(nRow).css('background-color', '#' + t);
            }

            if (value.name === 'sys_cancelled') {
                var tr = aData[value.data];
                if (tr === true)
                    $(nRow).css('color', '#f00');
            }
        });
    };

    this.lineGraphDiv = function (data, type, row, meta) {
        if (!data)
            return "";
        else
            return "<canvas id='eb_cvs" + meta.row + "' class='eb_canvas" + this.tableId + "' style='width:120px; height:40px; cursor:pointer;' data-graph='" + data + "' data-toggle='modal'></canvas><script>renderLineGraphs(" + meta.row + "); $('#eb_cvs" + meta.row + "').mousemove(function(e){ GPointPopup(e); });</script>";
    };

    this.RenderGraphModal = function () {
        $(document.body).append("<div class='modal fade' id='graphmodal' role='dialog'>"
            + "<div class='modal-dialog modal-lg'>"
            + " <div class='modal-content'>"
            + "<div class='modal-header'>"
            + "<button type = 'button' class='close' data-dismiss='modal'>&times;</button>"
            + "<h4 class='modal-title'><center>Graph</center></h4>"
            + "</div>"
            + "<div class='modal-body'>"
            + "<div class='dygraph-Wrapper'>"
            + "<div id='graphdiv' style='width:100%;height:500px;'></div>"
            + "</div>  "
            + "</div>"
            + "</div>"
            + "</div>"
            + "</div>");
        $(document).on('show.bs.modal', '.modal', function (event) {
            var zIndex = 1040 + (10 * $('.modal:visible').length);
            $(this).css('z-index', zIndex);
            setTimeout(function () {
                $('.modal-backdrop').not('.modal-stack').css('z-index', zIndex - 1).addClass('modal-stack');
            }, 0);
        });
    };

    this.renderMainGraph = function (e) {
        $("#graphmodal").modal('show');

        setTimeout(function () {
            var gcsv = csv($(e.target).attr("data-graph").toString());
            new Dygraph(
                document.getElementById('graphdiv'),
                gcsv,
                {
                    showRangeSelector: true,
                    interactionModel: Dygraph.defaultInteractionModel,
                    includeZero: true,
                    stackedGraph: true,
                    axes: {
                        y: {
                            valueFormatter: function (y) {
                                return y;
                            },
                            axisLabelFormatter: function (y) {
                                y = y.toString();
                                if (y.slice(-3) === '000')
                                    return y.slice(0, -3) + 'K';
                                else
                                    return y;
                            },
                        },
                        logscale: true
                    }
                }
            );
        }, 500);
    };

    this.ModifyDvname = function () {
        this.ebSettings.Name = $("#dvnametxt").val();
        $("label.dvname").text(this.ebSettings.Name);
    };

    this.ModifyTableHeight = function () {
        this.ebSettings.scrollY = $("#TableHeighttxt").val();
        this.ebSettings.scrollY = (this.ebSettings.scrollY < 100) ? "300" : this.ebSettings.scrollY;
    };

    this.renderMarker = function (data) {
        if (data !== ",")
            return `<a href='#' class ='columnMarker_${this.tableId}' data-latlong='${data}'><i class='fa fa-map-marker fa-2x' style='color:red;'></i></a>`;
        else
            return null;
    };

    this.renderFBImage = function (data) {
        //if (typeof (data) === "string")
        //    return `<img class='img-thumbnail' src='http://graph.facebook.com/${data}/picture?type=square' style="height: 20px;width: 25px;"/>`;
        //else
        //    return `<img class='img-thumbnail' src='http://graph.facebook.com/12345678/picture?type=square' style="height: 20px;width: 25px;"/>`;

        return `<img class='img-thumbnail columnimage' src='/images/small/${data}.jpg'/>`;
    };

    this.renderDataAsLabel = function (data) {
        return `<label class='labeldata'>${data}</label>`;
    };

    this.renderDateformat = function (data, sym) {
        if (typeof data !== "object" && typeof data !== "undefined") {
            var date = new Date(parseInt(data.substr(6)));
            var month = date.getMonth() + 1;
            var dt = date.getDate();
            if (sym === "-")
                return (dt.toString().length > 1 ? dt : "0" + dt) + "-" + (month.toString().length > 1 ? month : "0" + month) + "-" + date.getFullYear();
            else
                return (dt.toString().length > 1 ? dt : "0" + dt) + "/" + (month.toString().length > 1 ? month : "0" + month) + "/" + date.getFullYear();
        }
        else
            return "";
    };

    this.CreateRelationString = function () { };

    this.ValidateCalcExpression = function (obj) {
        $.ajax({
            url: "../RB/ValidateCalcExpression",
            type: "POST",
            cache: false,
            data: {
                refid: this.EbObject.DataSourceRefId,
                expression: atob(obj.ValueExpression)
            },
            success: function (result) {

            }.bind(this)
        });
    }

    this.start();
};

var ConditionalFormat = function () {
    this.getModal = function () {
        let modal1 = `
            <div class="modal fade" id="treemodal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
                <div class="modal-dialog">
                    <div class="treemodal-container">
                        <h4 class="treemodal-header">Conditional Rendering</span></h4>
                        <div class="tree_item_cont">
                            <label>From </label>
                            <span id="movefrom"></span>
                        </div>
                        <div class="tree_item_cont">
                            <label>To</label>
                            <button class="btn treemodalul">Select Group
                            <span class="caret"></span></button>
                        </div>
                        <div class="pull-right">
                            <button class="btn" id="treemodal_submit">Move</button>
                            <button class="btn" id="treemodal_cancel">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>`;
        $("body").append(modal1);
    };

    this.getModal();
};


function csv(gdata) {
    //gdata = ["201607:58179.28","201608:66329.35","201609:67591.27","201610:61900.93","201611:38628.72","201612:48536.31","201701:25256.74","201702:0"];
    var pairs = gdata.split(',');

    var r = 'date, Value\n';
    var ft;
    for (var i = 0; i < pairs.length; i++) {
        ft = pairs[i].split(':')[0].replace("\"", "").replace("[", "");

        ft = ft.slice(0, 4) + '/' + ft.slice(4);

        r += ft.replace("\"", "");
        r += '-01,' + pairs[i].split(':')[1].replace("\"", "");
        r += '\n';
    }
    return r.replace("]", "");
};

function renderLineGraphs(id) {
    var canvas = document.getElementById('eb_cvs' + id);
    var gdata = $(canvas).attr("data-graph").toString();
    var context = canvas.getContext('2d');
    if (gdata) {
        //gdata = '["201607:4529218.75","201608:4643253.00","201609:4886894.55","201610:5272744.25","201611:5253090.25","201612:5541506.00","201701:2964522.00"]';
        context.fillStyle = "rgba(255, 255, 255, 1)";
        context.beginPath();
        context.fillRect(0, 0, 1000, 1000);
        context.fillStyle = "rgba(51, 122, 183, 0.7)";
        var Gpoints = [];
        var Ypoints = [];
        Gpoints = gdata.split(",");
        var xInterval = (parseInt(canvas.style.width) * 2.5) / (Gpoints.length);
        context.moveTo(xInterval, 1000);
        var xPoint = 0;
        var yPoint;
        for (var i = 0; i < Gpoints.length; i++) {
            yPoint = parseInt(Gpoints[i].split(":")[1]);
            Ypoints.push(yPoint);
        }
        var Ymax = Ypoints.max();
        for (i = 0; i < Gpoints.length; i++) {
            xPoint += xInterval;
            context.lineTo(xPoint, 3.76 * (40 - ((Ypoints[i] / Ymax) * 40)));//
        }
        context.lineTo(xPoint, 1000);
        canvas.strokeStyle = "black";
        context.fill();
        context.stroke();
    }
};

function GPointPopup(e) {
    //alert(e.pageX);
};

$.fn.setCursorPosition = function (pos) {
    this.each(function (index, elem) {
        if (elem.setSelectionRange) {
            elem.setSelectionRange(pos, pos);
        } else if (elem.createTextRange) {
            var range = elem.createTextRange();
            range.collapse(true);
            range.moveEnd('character', pos);
            range.moveStart('character', pos);
            range.select();
        }
    });
    return this;
};

function formatDate(date) {
    var d = new Date(date),
        month = '' + (d.getMonth() + 1),
        day = '' + d.getDate(),
        year = d.getFullYear();
    if (month.length < 2) month = '0' + month;
    if (day.length < 2) day = '0' + day;

    return [year, month, day].join('-');
}

function getColdata(matrix, col) {
    var column = [];
    for (var i = 0; i < matrix.length; i++) {
        column.push(matrix[i][col]);
    }
    return column;
}



//refid, ver_num, type, dsobj, cur_status, tabNum, ssurl
var EbBasicDataTable = function (Option) {
    console.log(100000000000000000000);
    this.contId = Option.containerId;
    this.dsid = Option.dsid || null;
    this.tableId = Option.tableId;
    this.showSerialColumn = typeof Option.showSerialColumn !== 'undefined' ? Option.showSerialColumn : true;
    this.showCheckboxColumn = typeof Option.showCheckboxColumn !== 'undefined' ? Option.showCheckboxColumn : true;
    this.showFilterRow = typeof Option.showFilterRow !== 'undefined' ? Option.showFilterRow : true;
    this.scrollHeight = Option.scrollHeight || "inherit";
    this.hiddenFieldName = Option.hiddenFieldName || "id";
    this.columns = Option.columns || null;
    this.dom = Option.dom;
    this.pageLength = Option.pageLength || 100;
    this.hiddenIndex = null;
    this.isSecondTime = false;
    this.Api = null;
    this.order_info = new Object();
    this.order_info.col = '';
    this.order_info.dir = 0;
    this.EbObject = Option.dvObject || null;
    this.ebSettings = null;
    this.login = "dc";
    this.FD = false;
    //Controls & Buttons
    this.table_jQO = null;
    this.eb_filter_controls_4fc = [];
    this.eb_filter_controls_4sb = [];
    this.linkDV = null;
    this.filterFlag = false;
    this.filterValues = Option.filterValues || [];
    this.FlagPresentId = false;
    this.columnSearch = Option.columnSearch || [];
    this.MainData = Option.data || null;
    this.showHeader = typeof Option.showHeader !== 'undefined' ? Option.showHeader : true;
    this.getFilterValues = Option.getFilterValuesFn || function () { };
    this.source = Option.source || "";
    this.IsQuery = Option.IsQuery;

    this.extraCol = [];
    this.modifyDVFlag = false;
    this.initCompleteflag = false;
    this.isTagged = false;
    this.isRun = false;

    this.orderColl = [];
    this.eb_agginfo = [];
    this.Aggregateflag = false;
    this.QueryIndex = Option.QueryIndex || 0;
    this.datetimeformat = Option.datetimeformat;

    this.action = Option.action || null;
    this.Levels = Option.levels || [];
    this.PreviousHTML = Option.previousHTML;
    this.NextHTML = Option.nextHTML;


    this.init = function () {
        if (this.EbObject === null)
            this.EbObject = new EbTableVisualization(this.tableId);
        this.EbObject.IsPaging = Option.IsPaging || false;
        this.$dtLoaderCont = $(`<div id='${this.tableId}dtloadercont' class='dt-loader-cont'></div>`);
        this.$dtLoaderCont.insertBefore($("#" + this.contId));
        if (this.MainData === null)
            this.call2FD();
        else {
            if (this.columns !== null)
                this.EbObject.Columns.$values = this.columns;
            this.getColumnsSuccess();
        }
    };

    this.showLoader = function () {
        this.$dtLoaderCont.EbLoader("hide");
        this.$dtLoaderCont.EbLoader("show", { maskItem: { Id: `#${this.contId}` }, maskLoader: false });
    };

    this.call2FD = function () {
        this.EbObject.DataSourceRefId = this.dsid;
        this.showLoader();
        if (this.columns === null) {
            $.ajax({
                type: "POST",
                url: "../boti/dvView1",
                data: { dvobj: JSON.stringify(this.EbObject) },
                success: this.ajaxSucc.bind(this)
            });
        }
        else {
            this.EbObject.Columns = this.columns;
            this.getColumnsSuccess();
        }
    };

    this.ajaxSucc = function (text) {
        $("#" + this.contId).append(text);////////////////        
        this.EbObject = dvGlobal.Current_obj;
        this.getColumnsSuccess();
    }.bind(this);


    this.getColumnsSuccess = function () {
        this.EbObject.IsPaging = Option.IsPaging || false;
        this.showLoader();
        this.extraCol = [];
        this.ebSettings = this.EbObject;

        this.dvName = this.ebSettings.Name;
        this.initCompleteflag = false;

        this.addSerialAndCheckboxColumns();
        if (this.ebSettings.$type.indexOf("EbTableVisualization") !== -1) {
            this.Init();
        }
        var temp = [];
        $.extend(temp, this.EbObject.Columns.$values);
        temp.sort(this.ColumnsComparer);
        this.sortedColumns = temp;
    };

    this.Init = function () {
        //$.event.props.push('dataTransfer');
        this.updateRenderFunc();
        this.table_jQO = $('#' + this.tableId);

        this.eb_agginfo = this.getAgginfo();

        this.table_jQO.append($(this.getFooterFromSettingsTbl()));

        //this.table_jQO.children("tfoot").hide();

        this.table_jQO.on('processing.dt', function (e, settings, processing) {
            if (processing === true) {
                $("#obj_icons .btn").prop("disabled", true);
                this.showLoader();
            }
            else {
                $("#obj_icons .btn").prop("disabled", false);
                this.$dtLoaderCont.EbLoader("hide");
            }
        }.bind(this));


        this.table_jQO.on('error.dt', function (settings, techNote, message) {
            console.log('An error has been reported by DataTables: ', message);
        });

        this.Api = this.table_jQO.DataTable(this.createTblObject());

        this.Api.off('select').on('select', this.selectCallbackFunc.bind(this));

        this.Api.off('key').on('key', this.DTKeyPressCallback.bind(this));

        this.Api.off('key-focus').on('key-focus', Option.arrowFocusCallback);

        this.Api.off('key-blur').on('key-blur', Option.arrowBlurCallback);

        jQuery.fn.dataTable.Api.register('sum()', function () {
            return this.flatten().reduce(function (a, b) {
                if (typeof a === 'string') {
                    a = a.replace(/[^\d.-]/g, '') * 1;
                }
                if (typeof b === 'string') {
                    b = b.replace(/[^\d.-]/g, '') * 1;
                }

                return a + b;
            }, 0);
        });

        jQuery.fn.dataTable.Api.register('average()', function () {
            var data = this.flatten();
            var sum = data.reduce(function (a, b) {
                return (a * 1) + (b * 1); // cast values in-case they are strings
            }, 0);

            return sum / data.length;
        });

        jQuery.fn.dataTable.ext.errMode = 'alert';

        this.table_jQO.off('draw.dt').on('draw.dt', this.doSerial.bind(this));
        //this.table_jQO.off('order.dt').on('order.dt', this.doSerial.bind(this));
        ////this.table_jQO.off('init.dt').on('init.dt', this.doSerial.bind(this));

        //this.table_jQO.on('length.dt', function (e, settings, len) {
        //    console.log('New page length: ' + len);
        //});


        $('#' + this.tableId + ' tbody').off('dblclick').on('dblclick', 'tr', this.dblclickCallbackFunc.bind(this));
        $('#' + this.tableId + ' tbody').off('click').on('click', 'tr', this.rowclick.bind(this));

    };

    this.addSerialAndCheckboxColumns = function () {
        this.CheckforColumnID();//"sWidth":"10px", 
        var serialObj = (JSON.parse('{"sWidth":"10px", "searchable": false, "orderable": false, "bVisible":true, "name":"serial", "title":"#", "Type":11}'));
        if (this.showSerialColumn) {
            this.extraCol.push(serialObj);
            //if (this.source !== "")
            //    serialObj.data = this.ebSettings.Columns.$values.length;
        }
        this.addcheckbox();
    };

    this.CheckforColumnID = function () {
        $.each(this.ebSettings.Columns.$values, function (i, col) {
            if (col.name.toLocaleLowerCase() === this.hiddenFieldName.toLocaleLowerCase()) {
                this.FlagPresentId = true;
                col.bVisible = false;
                return false;
            }
        }.bind(this));
    };

    this.addcheckbox = function () {
        var chkObj = new Object();
        chkObj.data = null;
        chkObj.title = "<input id='{0}_select-all' class='eb_selall" + this.tableId + "' type='checkbox' data-table='{0}'/>".replace("{0}", this.tableId);
        chkObj.sWidth = "10px";
        chkObj.orderable = false;
        chkObj.bVisible = (this.showCheckboxColumn) ? true : false;
        chkObj.name = "checkbox";
        chkObj.Type = 3;
        chkObj.render = this.renderCheckBoxCol.bind(this);
        chkObj.pos = "-1";

        this.extraCol.push(chkObj);
        var _array = $.grep(this.ebSettings.Columns.$values, function (obj) { return obj.name.toLocaleLowerCase() === this.hiddenFieldName.toLocaleLowerCase(); }.bind(this));
        if (_array.length > 0)
            this.hiddenIndex = _array[0].data;
    };

    this.createTblObject = function () {
        var url = "";
        if (Option.rendererName === 'Bot')
            url = "../boti/getData";
        else if (this.IsQuery)
            url = "../Eb_Object/getData";
        else if (this.source === "datareader")
            url = "../CE/getDataCollcetion";
        else if (this.source === "powerselect")
            url = "../dv/getData4PowerSelect";
        else
            url = "../dv/getData";
        var o = new Object();
        o.scrollY = this.scrollHeight;
        o.scrollX = "100%";
        o.bAutoWidth = false;
        o.autowidth = false;
        o.serverSide = (this.MainData === null) ? true : false;
        o.processing = true;
        o.language = {
            processing: "<div class='fa fa-spinner fa-pulse fa-3x fa-fw'></div>",
            info: "_START_ - _END_ / _TOTAL_",
            paginate: {
                "previous": this.PreviousHTML || "Prev",
                "next": this.NextHTML || "Next",
            },
            lengthMenu: "_MENU_ / Page",
            infoFiltered: (this.source === "powerselect") ? "(total _MAX_)" : "",
            infoEmpty: "_TOTAL_  / _TOTAL_"
        };
        o.columns = this.extraCol.concat(this.ebSettings.Columns.$values);
        o.order = [];
        o.dom = this.dom || ((this.EbObject.IsPaging ? "ip" : "") + "<'col-md-12 noPadding display_none'>rt");
        o.paging = this.EbObject.IsPaging;
        o.lengthChange = this.EbObject.IsPaging;
        o.pagingType = "simple";
        o.pageLength = this.pageLength;
        //o.fixedColumns = { leftColumns: 1, rightColumns: 1 };
        o.select = true;
        o.keys = true;
        if (this.MainData === null) {
            o.ajax = {
                url: url,
                type: 'POST',
                data: this.ajaxData.bind(this),
                dataSrc: this.receiveAjaxData.bind(this),
            };
        }
        else {
            o.data = this.MainData.formattedData || this.MainData.data || this.MainData;
            this.data = this.MainData.data || this.MainData;
            this.formatteddata = this.MainData.formattedData || this.MainData.data || this.MainData;
        }
        o.fnRowCallback = this.rowCallBackFunc.bind(this);
        o.drawCallback = this.drawCallBackFunc.bind(this);
        o.initComplete = this.initCompleteFunc.bind(this);
        return o;
    };

    this.ajaxData = function (dq) {
        delete dq.columns; delete dq.order; delete dq.search;
        dq.RefId = this.EbObject.DataSourceRefId;
        if (this.showFilterRow)
            this.columnSearch = this.repopulate_filter_arr();
        dq.TFilters = this.columnSearch;
        //if (this.filterValues.length === 0)
        this.filterValues = this.getFilterValues();
        this.AddUserAndLcation();
        dq.Params = this.filterValues || [];
        dq.rowData = this.rowData || "";
        //if (this.orderColl.length > 0)
        //    dq.OrderBy = this.orderColl;
        if (this.order_info.col !== "")
            dq.OrderBy = new order_obj(this.order_info.col, this.order_info.dir);
        if (this.columnSearch.length > 0) {
            this.filterFlag = true;
        }
        dq.Ispaging = this.EbObject.IsPaging;
        if (Option.rendererName === 'Bot') {
            dq.start = 0;
            dq.length = 25;/////////hard coding
        }
        dq.QueryIndex = this.QueryIndex;
        dq.DataVizObjString = JSON.stringify(this.EbObject);
        dq.TableId = this.tableId;
        if (this.source === "powerselect")
            dq = { req: JSON.stringify(dq) };
        return dq;
    };

    this.AddUserAndLcation = function () {
        let temp = $.grep(this.filterValues, function (obj) { return obj.Name === "eb_loc_id"; });
        if (temp.length === 0)
            this.filterValues.push(new fltr_obj(11, "eb_loc_id", store.get("Eb_Loc-" + ebcontext.sid + ebcontext.user.UserId)));

        temp = $.grep(this.filterValues, function (obj) { return obj.Name === "eb_currentuser_id"; });
        if (temp.length === 0)
            this.filterValues.push(new fltr_obj(11, "eb_currentuser_id", ebcontext.user.UserId));
        if (ebcontext.languages != undefined) {
            temp = $.grep(this.filterValues, function (obj) { return obj.Name === "eb_current_language_id"; });
            if (temp.length === 0)
                this.filterValues.push(new fltr_obj(11, "eb_current_language_id", ebcontext.languages.getCurrentLanguage()));

            temp = $.grep(this.filterValues, function (obj) { return obj.Name === "eb_current_locale"; });
            if (temp.length === 0)
                this.filterValues.push(new fltr_obj(16, "eb_current_locale", ebcontext.languages.getCurrentLocale()));
        }
    };

    this.filterDisplay = function () {
        if ($("#sub_window_" + this.tableId).find(".dataTables_scroll").children().hasClass("filter_Display")) {
            $(".filter_Display").empty();
            var $controls = $("#sub_windows_sidediv_" + this.tableId + " #filterBox").children().not("[type=hidden],.commonControl");
            var filter = "";
            if ($controls.length > 0) {
                $.each($controls, function (i, ctrl) {
                    var ctype = $(ctrl).attr("ctype");
                    filter += $($(ctrl).children()[0]).text();
                    if (ctype !== "Date")
                        filter += " " + $($(ctrl).children()[1]).val();
                    else
                        filter += " " + $(ctrl).find("input").val();
                    filter += " AND ";
                });
            }

            if (this.columnSearch.length > 0) {
                $.each(this.columnSearch, function (i, search) {
                    filter += search.Column + " " + search.Operator;
                    if (search.Value.includes("|")) {
                        filter += "(";
                        $.each(search.Value.split("|"), function (i, val) {
                            if (val.trim() !== "")
                                filter += " " + val + " OR";
                        });
                        filter = filter.substring(0, filter.lastIndexOf("OR"));
                        filter += ")";
                    }
                    else
                        filter += " " + search.Value;
                    filter += "AND "
                });
            }

            filter = filter.substring(0, filter.lastIndexOf("AND"));
            $(".filter_Display").text(filter);
        }
    }

    this.getfilter = function (fltr_collection, i, data) {
        fltr_collection.push(new fltr_obj(data.Type, data.name, this.rowData[i]));
    };

    this.receiveAjaxData = function (dd) {
        this.isRun = true;
        this.MainData = dd;
        this.data = dd.data;
        this.formatteddata = dd.formattedData || dd.data;
        return this.formatteddata;
    };

    this.compareFilterValues = function () {
        var filter = this.getFilterValues();
        if (focusedId !== undefined) {
            $.each(filter, function (i, obj) {
                if (obj.Value !== dvcontainerObj.dvcol[focusedId].filterValues[i].Value) {
                    filterChanged = true;
                    return false;
                }

            }.bind(this));
        }
        else
            filterChanged = true;
    }

    this.fixedColumnCount = function () {
        var count = this.ebSettings.LeftFixedColumn;
        var visCount = 0;
        if (count > 1) {
            $.each(this.Api.settings().init().aoColumns, function (i, col) {
                if (!col.bVisible) {
                    if (this.ebSettings.LeftFixedColumn > visCount)
                        count++;
                    else
                        return count;
                }
                else
                    visCount++;
            }.bind(this));
        }
        return count;
    }


    this.ColumnsComparer = function (a, b) {
        if (a.data < b.data) return -1;
        if (a.data > b.data) return 1;
        if (a.data === b.data) return 0;
    };

    this.getAgginfo = function () {
        var _ls = [];
        $.each(this.ebSettings.Columns.$values, this.getAgginfo_inner.bind(this, _ls));
        return _ls;
    };

    this.getAgginfo_inner = function (_ls, i, col) {
        var type = col.Type || col.type;
        if (col.bVisible && (type === parseInt(gettypefromString("Int32")) || type === parseInt(gettypefromString("Decimal")) || type === parseInt(gettypefromString("Int64")) || type === parseInt(gettypefromString("Double"))) && col.name !== "serial")
            _ls.push(new Agginfo(col.name, this.ebSettings.Columns.$values[i].DecimalPlaces, col.data));
    };

    this.getFooterFromSettingsTbl = function () {
        var ftr_part = "";
        $.each(this.extraCol, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th style=\"padding: 0px; margin: 0px\"></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        $.each(this.ebSettings.Columns.$values, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th style=\"padding: 0px; margin: 0px\"></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        return "<tfoot>" + ftr_part + "<tr>" + ftr_part + "</tr></tfoot>";
    };

    this.repopulate_filter_arr = function () {
        var table = this.tableId;
        var filter_obj_arr = [];
        var api = this.Api;
        if (api !== null) {
            this.Api.columns().every(function (i) {
                var colum = api.settings().init().aoColumns[i].name;
                if (colum !== 'checkbox' && colum !== 'serial') {
                    var oper;
                    var val1, val2;
                    var textid = '#' + table + '_' + colum + '_hdr_txt1';
                    var type = api.settings().init().aoColumns[i].Type;
                    var Rtype = api.settings().init().aoColumns[i].RenderType;
                    if (Rtype === 3) {
                        val1 = ($(textid).is(':checked')) ? "true" : "false";
                        if ($(textid)[0] && !($(textid).is(':indeterminate')))
                            filter_obj_arr.push(new filter_obj(colum, "=", val1, type));
                    }
                    else {
                        oper = $('#' + table + '_' + colum + '_hdr_sel').text();
                        if (api.columns(i).visible()[0]) {
                            if (oper !== '' && $(textid).val() !== '') {
                                if (oper === 'B') {
                                    val1 = $(textid).val();
                                    val2 = $(textid).siblings('input').val();
                                    if (oper === 'B' && val1 !== '' && val2 !== '') {
                                        if (Rtype === 8 || Rtype === 7 || Rtype === 11 || Rtype === 12) {
                                            filter_obj_arr.push(new filter_obj(colum, ">=", Math.min(val1, val2)));
                                            filter_obj_arr.push(new filter_obj(colum, "<=", Math.max(val1, val2), type));
                                        }
                                        else if (Rtype === 5 || Rtype === 6) {
                                            if (val2 > val1) {
                                                filter_obj_arr.push(new filter_obj(colum, ">=", val1, type));
                                                filter_obj_arr.push(new filter_obj(colum, "<=", val2, type));
                                            }
                                            else {
                                                filter_obj_arr.push(new filter_obj(colum, ">=", val2, type));
                                                filter_obj_arr.push(new filter_obj(colum, "<=", val1, type));
                                            }
                                        }
                                    }
                                }
                                else {
                                    filter_obj_arr.push(new filter_obj(colum, oper, $(textid).val(), type));
                                }
                            }
                        }
                    }
                }
            });
        }

        if (filter_obj_arr.length === 0)
            return this.columnSearch;

        return filter_obj_arr;
    };

    this.rowCallBackFunc = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        this.colorRow(nRow, aData, iDisplayIndex, iDisplayIndexFull);
        $(nRow).attr("data-uid", aData[this.hiddenIndex]);
    };

    this.initCompleteFunc = function (settings, json) {
        this.doSerial();
        this.GenerateButtons();
        if (this.eb_agginfo.length > 0) {
            this.createFooter(0);
        }
        else
            $('#' + this.tableId + '_wrapper .dataTables_scrollFoot').hide();

        if (this.login === "uc") {
            this.initCompleteflag = true;
            //if (this.isSecondTime) { }
            this.ModifyingDVs(dvcontainerObj.currentObj.Name, "initComplete");
        }
        if (this.Api === null)
            this.Api = $("#" + this.tableId).DataTable();
        this.Api.columns.adjust();
        this.$dtLoaderCont.EbLoader("hide");

        if (this.showFilterRow) {
            this.createFilterRowHeader();
            if(this.source === "powerselect")
                $("#" + this.tableId + "_wrapper tr.addedbyeb .input-group-btn").hide();
        }
        this.addFilterEventListeners();
        setTimeout(function () {
            if (Option.fninitComplete)
                Option.fninitComplete();
            if (Option.fninitComplete4SetVal)
                Option.fninitComplete4SetVal();
            if (Option.fns4PSonLoad && Option.fns4PSonLoad.length > 0)
                Option.fns4PSonLoad[0]();
        }, 1);

        if (!this.showHeader) {
            $("#"+this.contId).find(".dataTables_scrollHead").addClass("headhide");
        }
        if (this.data.length > 7 && this.Aggregateflag) {
            $(".containerrow #" + this.tableId + "_wrapper .dataTables_scroll").style("height", "210px", "important");
            $(".containerrow #" + this.tableId + "_wrapper .dataTables_scrollBody").style("height", "140px", "important");
        }
    };

    this.contextMenu = function () {
        $.contextMenu({
            selector: ".tablelink_" + this.tableId,
            items: {
                "OpenNewTab": { name: "Open in New Tab", icon: "fa-external-link-square", callback: this.OpeninNewTab.bind(this) }
            }
        });
    };

    this.contextMenu4Label = function () {
        $.contextMenu({
            selector: ".labeldata",
            items: {
                "Copy": { name: "Copy", icon: "fa-external-link-square", callback: this.copyLabelData.bind(this) }
            }
        });
    };

    this.OpeninNewTab = function (key, opt, event) {
        var cData = opt;
        this.isContextual = true;
        var idx;
        if (event !== undefined) {
            idx = this.Api.row(opt.$trigger.parent().parent()).index();
            cData = opt.$trigger.text();
        }
        else
            idx = key;
        this.rowData = this.Api.row(idx).data();
        //this.filterValues = this.getFilterValues("link");
        var splitarray = this.linkDV.split("-");
        if (splitarray[2] === "3") {
            var url = "http://" + this.url + "/ReportRender/BeforeRender?refid=" + this.linkDV;
            var copycelldata = cData.replace(/[^a-zA-Z ]/g, "").replace(/ /g, "_");
            if ($(`#RptModal${copycelldata}`).length !== 0)
                $(`#RptModal${copycelldata}`).remove();
            $("#parent-div0").append(`<div class="modal fade RptModal" id="RptModal${copycelldata}" role="dialog">
                <div class="modal-dialog modal-sm">
                    <div class="modal-content">
                        <div class="modal-header">
                            <button type="button" class="close" data-dismiss="modal">&times;</button>                              
                        </div>
                        <div class="modal-body"> <iframe id="reportIframe${copycelldata}" class="reportIframe" src='../ReportRender/Renderlink?refid=${this.linkDV}&_params=${btoa(JSON.stringify(this.filterValues))}'></iframe>
            </div>
                    </div>
                </div>
            </div>
            `);
            $(`#RptModal${copycelldata}`).modal();
            $(`#reportIframe${copycelldata}`).css("height", "80vh");
            //else {
            //    $(`#RptModal${copycelldata}`).modal();
            //    $.LoadingOverlay("hide");
            //}
        }
        else {
            this.tabNum++;
            let url = "http://" + this.url + "/DV/dv?refid=" + this.linkDV;

            var _form = document.createElement("form");
            _form.setAttribute("method", "post");
            _form.setAttribute("action", url);
            _form.setAttribute("target", "_blank");

            var input = document.createElement('input');
            input.type = 'hidden';
            input.name = "rowData";
            input.value = this.rowData.toString();
            _form.appendChild(input);

            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "filterValues";
            input.value = JSON.stringify(this.filterValues);
            _form.appendChild(input);

            input = document.createElement('input');
            input.type = 'hidden';
            input.name = "tabNum";
            input.value = this.tabNum;
            _form.appendChild(input);

            document.body.appendChild(_form);

            //note I am using a post.htm page since I did not want to make double request to the page 
            //it might have some Page_Load call which might screw things up.
            //window.open("post.htm", name, windowoption);       
            _form.submit();
            document.body.removeChild(_form);
        }

    };

    this.ModifyingDVs = function (parentName, source) {
        $.each(dvcontainerObj.dvcol, function (key, obj) {
            if (parentName === obj.EbObject.Pippedfrom) {
                if (obj.EbObject.$type.indexOf("EbChartVisualization") !== -1 || obj.EbObject.$type.indexOf("EbGoogleMap") !== -1) {
                    dvcontainerObj.dvcol[key].EbObject.data = dvcontainerObj.currentObj.data;
                    dvcontainerObj.dvcol[key].drawGraphHelper(this.Api.data());
                    this.ModifyingDVs(dvcontainerObj.dvcol[key].EbObject.Name, "draw");
                }
                else {
                    if (source === "draw") {
                        dvcontainerObj.dvcol[key].modifyDVFlag = true;
                        dvcontainerObj.dvcol[key].Api.clear().rows.add(this.Api.data());
                        dvcontainerObj.dvcol[key].EbObject.data = dvcontainerObj.currentObj.data;
                        dvcontainerObj.dvcol[key].Api.columns.adjust().draw();
                        this.ModifyingDVs(dvcontainerObj.dvcol[key].EbObject.Name, "draw");
                    }
                }
            }
        }.bind(this));
    };

    this.drawCallBackFunc = function (settings) {
        //if (this.ebSettings.rowGrouping.$values.length > 0)
        if (this.source === "sqljob")
            this.doRowgrouping();
        //this.summarize2();
        //if (this.login === "uc" && !this.modifyDVFlag && this.initCompleteflag) {
        //    //this.ModifyingDVs(dvcontainerObj.currentObj.Name, "draw");
        //}
        //this.filterDisplay();
        if (Option.searchCallBack)
            Option.searchCallBack();
        if (Option.drawCallback)
            Option.drawCallback();
        if (this.Api !== null)
            this.Api.columns.adjust();
    };

    this.selectCallbackFunc = function (e, dt, type, indexes) {
        if (Option.fnKeyUpCallback)
            Option.fnKeyUpCallback(e, dt, type, indexes);
    };

    this.dblclickCallbackFunc = function (e) {
        if (Option.fnDblclickCallback)
            Option.fnDblclickCallback(e);
    };

    this.DTKeyPressCallback = function (e, datatable, key, cell, originalEvent) {
        if (Option.keyPressCallbackFn)
            Option.keyPressCallbackFn(e, datatable, key, cell, originalEvent);
    };

    this.rowclick = function (e, dt, type, indexes) {
        if (Option.rowclick)
            Option.rowclick(e, dt, type, indexes);
    };

    this.doRowgrouping = function () {
        if (this.Api === null)
            this.Api = $("#" + this.tableId).DataTable();
        var rows = this.Api.rows().nodes();
        var count = this.Api.columns()[0].length;
        $.each(this.Levels, function (i, obj) {
            if (obj.insertionType !== "After")
                $(rows).eq(obj.rowIndex).before(obj.html);
            else
                $(rows).eq(obj.rowIndex).after(obj.html);
        });
        var ct = $("#" + this.tableId + " .group[group=1]").length;
        $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` Groups (${ct}) - `);

        $("#" + this.tableId + " tbody").off("click", "tr.group").on("click", "tr.group", this.collapseGroup);

    };

    //this.doRowgrouping = function () {
    //    var rows = this.Api.rows({ page: 'current' }).nodes();
    //    var last = null;
    //    var count = this.ebSettings.Columns.$values.length;
    //    this.Api.column(this.Api.columns(this.ebSettings.rowGrouping.$values[0].name + ':name').indexes()[0], { page: 'current' }).data().each(function (group, i) {
    //        if (last !== group) {
    //            $(rows).eq(i).before("<tr class='group'><td colspan=" + count + ">" + group + "</td></tr>");
    //            last = group;
    //        }
    //    });
    //};

    this.doRowgrouping_inner = function (last, rows, group, i) {
        if (last !== group) {
            $(rows).eq(i).before("<tr class='group'><td colspan=" + this.ebSettings.Columns.$values.length + ">" + group + "</td></tr>");
            last = group;
        }
    };

    this.doSerial = function () {
        if (this.showSerialColumn)
            $('#' + this.tableId).DataTable().column(0).nodes().each(function (cell, i) { cell.innerHTML = i + 1; });
        $('#' + this.tableId).DataTable().columns.adjust();
    };

    this.createFooter = function (pos) {
        var tx = this.ebSettings;
        var tid = this.tableId;
        var aggFlag = false;
        var lfoot = $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper table');
        var rfoot = $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper table');
        var scrollfoot = $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner table');

        if (lfoot !== null || rfoot !== null)
            var eb_footer_controls_lfoot = this.GetAggregateControls(pos, 50);
        if (scrollfoot !== null)
            var eb_footer_controls_scrollfoot = this.GetAggregateControls(pos, 1);
        if (pos === 0) {
            if (this.Api !== null) {
                $.each(this.Api.settings().init().aoColumns, function (i, col) {
                    if (col.Aggregate) {
                        $('#' + tid + '_btntotalpage').css("display", "inline");
                        aggFlag = true;
                        return false;
                    }
                });
            }
            else {
                $.each(this.ebSettings.Columns.$values, function (i, col) {
                    if (col.Aggregate) {
                        $('#' + tid + '_btntotalpage').css("display", "inline");
                        aggFlag = true;
                        return false;
                    }
                });
            }
            if (!aggFlag || this.data.length === 0) {
                $('#' + this.tableId + '_wrapper .dataTables_scrollFoot').hide();
            }
        }
        var j = 0;
        $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner tfoot tr:eq(' + pos + ') th').each(function (idx) {
            if (lfoot !== null) {
                if (j < tx.LeftFixedColumn)
                    $(this).html(eb_footer_controls_lfoot[idx]);
            }

            if (rfoot !== null) {
                if (j === eb_footer_controls_lfoot.length - tx.RightFixedColumn) {
                    if (j < eb_footer_controls_lfoot.length)
                        $(this).html(eb_footer_controls_lfoot[idx]);
                }
            }

            if (scrollfoot !== null) {
                if (tx.LeftFixedColumns + tx.RightFixedColumn > 0) {
                    if (j < eb_footer_controls_scrollfoot.length - tx.RightFixedColumn)
                        $(this).html(eb_footer_controls_scrollfoot[idx]);
                }

                else {
                    if (j < eb_footer_controls_scrollfoot.length)
                        $(this).html(eb_footer_controls_scrollfoot[idx]);
                }
            }

            j++;
        });

        this.summarize2();
    };

    this.GetAggregateControls = function (footer_id, zidx) {
        var ScrollY = this.ebSettings.scrollY;
        var ResArray = [];
        var tableId = this.tableId;
        var api = $("#" + this.tableId).DataTable();
        //$.each(this.ebSettings.Columns.$values, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        if (this.Api !== null)
            $.each(this.Api.settings().init().aoColumns, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        else
            $.each(api.settings().init().aoColumns, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        return ResArray;
    };

    this.GetAggregateControls_inner = function (ResArray, footer_id, zidx, i, col) {
        var _ls;
        if (col.bVisible) {
            //(col.Type ==parseInt( gettypefromString("Int32")) || col.Type ==parseInt( gettypefromString("Decimal")) || col.type ==parseInt( gettypefromString("Int64")) || col.Type ==parseInt( gettypefromString("Double"))) && col.name !== "serial"
            if (col.Aggregate) {
                this.Aggregateflag = true;
                var footer_select_id = this.tableId + "_" + col.name + "_ftr_sel" + footer_id;
                var fselect_class = this.tableId + "_fselect";
                var data_colum = "data-column=" + col.name;
                var data_table = "data-table=" + this.tableId;
                var footer_txt = this.tableId + "_" + col.name + "_ftr_txt" + footer_id;
                var data_decip = "data-decip=" + col.DecimalPlaces;

                _ls = "<div class='input-group input-group-sm'>" +
                    "<div class='input-group-btn dropup'>" +
                    "<button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + footer_select_id + "'>&sum;</button>" +
                    " <ul class='dropdown-menu'>" +
                    "  <li><a href ='#' class='eb_ftsel" + this.tableId + "' data-sum='Sum' " + data_table + " " + data_colum + " " + data_decip + ">&sum;</a></li>" +
                    "  <li><a href ='#' class='eb_ftsel" + this.tableId + "' " + data_table + " " + data_colum + " " + data_decip + " {4}>x&#772;</a></li>" +
                    " </ul>" +
                    " </div>" +
                    " <input type='text' class='form-control' id='" + footer_txt + "' disabled style='text-align: right;' style='z-index:" + zidx.toString() + "'>" +
                    " </div>";
            }
            else
                _ls = "&nbsp;";

            ResArray.push(_ls);
        }
    };

    this.summarize2 = function () {
        var api = null;
        if (this.Api === null)
            api = $("#" + this.tableId).DataTable();
        else
            api = this.Api;
        var tableId = this.tableId;
        var scrollY = this.ebSettings.scrollY;
        var p;
        var ftrtxt;
        $.each(this.eb_agginfo, function (index, agginfo) {
            if (agginfo.colname) {
                p = $('.dataTables_scrollFootInner #' + tableId + '_' + agginfo.colname + '_ftr_sel0').text().trim();
                ftrtxt = '.dataTables_scrollFootInner #' + tableId + '_' + agginfo.colname + '_ftr_txt0';
                var col = api.column(agginfo.colname + ':name');

                var summary_val = 0;
                if (p === '')
                    summary_val = col.data().sum();
                if (p === 'x') {
                    summary_val = col.data().average();
                }
                $(ftrtxt).val(summary_val.toFixed(agginfo.deci_val));
            }
        });
    };

    this.createFilterRowHeader = function () {
        var tableid = this.tableId;
        var order_info_ref = this.order_info;

        var fc_lh_tbl = $('#' + tableid + '_wrapper .DTFC_LeftHeadWrapper table');
        var fc_rh_tbl = $('#' + tableid + '_wrapper .DTFC_RightHeadWrapper table');

        if (fc_lh_tbl.length !== 0 || fc_rh_tbl.length !== 0) {
            this.GetFiltersFromSettingsTbl(50);
            if (fc_lh_tbl.length !== 0) {
                fc_lh_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
                for (let j = 0; j < this.ebSettings.LeftFixedColumn; j++)
                    $(fc_lh_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4fc[j]));
            }
            if (fc_rh_tbl.length !== 0) {
                fc_rh_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
                for (let j = this.eb_filter_controls_4fc.length - this.ebSettings.RightFixedColumn; j < this.eb_filter_controls_4fc.length; j++)
                    $(fc_rh_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4fc[j]));
            }
        }

        var sc_h_tbl = $('#' + tableid + '_wrapper .dataTables_scrollHeadInner table');
        if (sc_h_tbl !== null) {
            this.GetFiltersFromSettingsTbl(1);
            sc_h_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
            if (this.ebSettings.LeftFixedColumn + this.ebSettings.RightFixedColumn > 0) {
                for (let j = 0; j < this.eb_filter_controls_4sb.length; j++) {
                    if (j < this.ebSettings.LeftFixedColumn) {
                        $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                        $(sc_h_tbl.find("tr[class=addedbyeb] th:eq(" + j + ")")).children().not("span").remove();
                    }
                    else {
                        if (j < this.eb_filter_controls_4sb.length - this.ebSettings.RightFixedColumn)
                            $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                        else {
                            $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                            $(sc_h_tbl.find("tr[class=addedbyeb] th:eq(" + j + ")")).children().not("span").remove();
                        }
                    }
                }
            }
            else {
                for (let j = 0; j < this.eb_filter_controls_4sb.length; j++)
                    $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
            }
        }

        // $('#' + tableid + '_wrapper table thead tr[class=addedbyeb]').hide();

        //$('thead:eq(0) tr:eq(1) [type=checkbox]').prop('indeterminate', true);
        $(".addedbyeb [type=checkbox]").prop('indeterminate', true);
    };

    this.addFilterEventListeners = function () {
        if (this.Api !== null) {
            $('#' + this.tableId + '_wrapper thead tr:eq(0)').off('click').on('click', 'th', this.orderingEvent.bind(this));
            $.each($(this.Api.columns().header()).parent().siblings().children().toArray(), this.setFilterboxValue.bind(this));
            this.Api.on('key-focus', function (e, datatable, cell) {
                datatable.rows().deselect();
                datatable.row(cell.index().row).select();
            });
        }
        $(".eb_fsel" + this.tableId).off("click").on("click", this.setLiValue.bind(this));
        $(".eb_ftsel" + this.tableId).off("click").on("click", this.fselect_func.bind(this));
        $(".eb_fbool" + this.tableId).off("change").on("change", this.toggleInFilter.bind(this));
        $(".eb_selall" + this.tableId).off("click").on("click", this.clickAlSlct.bind(this));
        $("." + this.tableId + "_select").off("change").on("change", this.updateAlSlct.bind(this));
        $(".eb_canvas" + this.tableId).off("click").on("click", this.renderMainGraph);
        $(".tablelink_" + this.tableId).off("click").on("click", this.link2NewTable.bind(this));
        $("#clearfilterbtn_" + this.tableId).off("click").on("click", this.clearFilter.bind(this));
        //$("#" + this.tableId + "_btntotalpage").off("click").on("click", this.showOrHideAggrControl.bind(this));
        $(".columnMarker_" + this.tableId).off("click").on("click", this.link2NewTable.bind(this));
        $('[data-toggle="tooltip"]').tooltip({
            placement: 'bottom'
        });
        $('.columntooltip').popover({
            container: 'body',
            trigger: 'hover',
            placement: this.PopoverPlacement,
            html: true,
            content: function (e, i) {
                return atob($(this).attr("data-contents"));
            },
        });
        //$('.columntooltip').on('shown.bs.popover', this.openColumnTooltip.bind(this));
        this.filterDisplay();
    };

    this.GenerateButtons = function () {
        this.addFilterEventListeners();
    };

    this.setFilterboxValue = function (i, obj) {
        $(obj).children('div').children('.eb_finput').off("keyup").on("keyup", this.call_filter);
        //$(obj).children('div').children('.eb_finput').on("keydown", function (event) {
        //    if (event.keyCode === $.ui.keyCode.TAB &&
        //        $(this).autocomplete("instance").menu.active) {
        //        event.preventDefault();
        //    }
        //});
        //var name = $(obj).children('span').text();
        //var idx = this.Api.columns(name + ':name').indexes()[0];
        //var data = this.Api.columns(idx).data()[0];
        //if ($(obj).children('div').children('.eb_finput').attr("data-coltyp") === "string") {
        //    $(obj).children('div').children('.eb_finput').autocomplete({
        //        //source: $.unique(this.Api.columns(idx).data()[0]),
        //        source: function (request, response) {
        //            // delegate back to autocomplete, but extract the last term
        //            response($.ui.autocomplete.filter(
        //                $.unique(data), extractLast(request.term)));
        //        }.bind(this),
        //        focus: function () {
        //            // prevent value inserted on focus
        //            return false;
        //        },
        //        select: function (event, ui) {
        //            var terms = splitval(this.value);
        //            // remove the current input
        //            terms.pop();
        //            // add the selected item
        //            terms.push(ui.item.value);
        //            // add placeholder to get the comma-and-space at the end
        //            terms.push("");
        //            this.value = terms.join(" | ");
        //            //$(this).setCursorPosition(this.value.length-1);
        //            return false;
        //        },
        //        search: function (event, ui) {
        //        }
        //    });
        //}
        //else {
        //    if ($(obj).children('div').length === 0) {
        //        var $lctrl = $("#" + this.tableId + "_wrapper .DTFC_LeftHeadWrapper table tr[class=addedbyeb] th:eq(" + i + ")").find(".eb_finput");
        //        var $rctrl = $("#" + this.tableId + "_wrapper .DTFC_RightHeadWrapper table tr[class=addedbyeb] th:eq(" + i + ")").find(".eb_finput");
        //        if ($lctrl.length > 0) {
        //            if ($lctrl.attr("data-coltyp") === "string") {
        //                $lctrl.autocomplete({
        //                    //source: $.unique(this.Api.columns(idx).data()[0]),
        //                    source: function (request, response) {
        //                        // delegate back to autocomplete, but extract the last term
        //                        response($.ui.autocomplete.filter(
        //                            $.unique(data), extractLast(request.term)));
        //                    }.bind(this),
        //                    focus: function () {
        //                        // prevent value inserted on focus
        //                        return false;
        //                    },
        //                    select: function (event, ui) {
        //                        var terms = splitval(this.value);
        //                        // remove the current input
        //                        terms.pop();
        //                        // add the selected item
        //                        terms.push(ui.item.value);
        //                        // add placeholder to get the comma-and-space at the end
        //                        terms.push("");
        //                        this.value = terms.join(" | ");
        //                        //$(this).setCursorPosition(this.value.length-1);
        //                        return false;
        //                    },
        //                    search: function (event, ui) {
        //                    }
        //                });
        //            }
        //        }
        //        if ($rctrl.length > 0) {
        //            if ($rctrl.attr("data-coltyp") === "string") {
        //                $rctrl.autocomplete({
        //                    //source: $.unique(this.Api.columns(idx).data()[0]),
        //                    source: function (request, response) {
        //                        // delegate back to autocomplete, but extract the last term
        //                        response($.ui.autocomplete.filter(
        //                            $.unique(data), extractLast(request.term)));
        //                    }.bind(this),
        //                    focus: function () {
        //                        // prevent value inserted on focus
        //                        return false;
        //                    },
        //                    select: function (event, ui) {
        //                        var terms = splitval(this.value);
        //                        // remove the current input
        //                        terms.pop();
        //                        // add the selected item
        //                        terms.push(ui.item.value);
        //                        // add placeholder to get the comma-and-space at the end
        //                        terms.push("");
        //                        this.value = terms.join(" | ");
        //                        //$(this).setCursorPosition(this.value.length-1);
        //                        return false;
        //                    },
        //                    search: function (event, ui) {
        //                    }
        //                });
        //            }
        //        }
        //    }

        //}
    };

    this.orderingEvent = function (e) {
        //var col = $(e.target).children('span').text();
        var col = $(e.target).text();
        var tempobj = $.grep(this.Api.settings().init().aoColumns, function (obj) { return obj.sTitle === col; });
        var cls = $(e.target).attr('aria-sort') || "descending";
        if (col !== '' && col !== "#") {
            this.order_info.col = tempobj[0].name;
            this.order_info.dir = (cls.indexOf('ascending') > -1) ? 2 : 1;
            this.orderColl = [];
            this.orderColl.push(new order_obj(this.order_info.col, this.order_info.dir));
        }
    };

    this.GetFiltersFromSettingsTbl = function (zidx) {
        this.zindex = zidx;
        if (this.zindex === 50)
            this.eb_filter_controls_4fc = [];
        else if (this.zindex === 1)
            this.eb_filter_controls_4sb = [];

        //$.each(this.ebSettings.Columns.$values, this.GetFiltersFromSettingsTbl_inner.bind(this));
        if (this.Api === null)
            this.Api = $("#" + this.tableId).DataTable();

        $.each(this.Api.settings().init().aoColumns, this.GetFiltersFromSettingsTbl_inner.bind(this));
    };

    this.GetFiltersFromSettingsTbl_inner = function (i, col) {
        var _ls = "";
        if (col.bVisible === true) {
            var span = "<span hidden>" + col.name + "</span>";
            //var span = "";

            var htext_class = this.tableId + "_htext";

            var data_colum = "data-colum='" + col.name + "'";
            var data_table = "data-table='" + this.tableId + "'";

            var header_select = this.tableId + "_" + col.name + "_hdr_sel";
            var header_text1 = this.tableId + "_" + col.name + "_hdr_txt1";
            var header_text2 = this.tableId + "_" + col.name + "_hdr_txt2";

            _ls += "<th>";
            if (col.name === "serial") {
                _ls += (span + "<a class='btn btn-sm center-block'  id='clearfilterbtn_" + this.tableId + "' data-table='@tableId' data-toggle='tooltip' title='Clear Filter' style='height:100%'><i class='fa fa-filter' aria-hidden='true' style='color:black'></i></a>");
            }
            else {
                var type = col.type || col.Type;
                if (type === parseInt(gettypefromString("Int32")) || type === parseInt(gettypefromString("Decimal")) || type === parseInt(gettypefromString("Int64")) || type === parseInt(gettypefromString("Double")) || type === parseInt(gettypefromString("Numeric"))) {

                    _ls += span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex);
                }
                else if (type === parseInt(gettypefromString("String"))) {

                    _ls += span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex);
                }
                else if (type === parseInt(gettypefromString("DateTime"))) {

                    _ls += span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex);
                }
                else if (type === parseInt(gettypefromString("Boolean")) && col.name !== "checkbox")
                    _ls += span + this.getFilterForBoolean(col.name, this.tableId, this.zindex);
                else
                    _ls += span;
            }

            _ls += "</th>";

            ((this.zindex === 50) ? this.eb_filter_controls_4fc : this.eb_filter_controls_4sb).push(_ls);
        }
    };

    this.getFilterForNumeric = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx) {
        var coltype = "data-coltyp='number'";
        var drptext = "";

        drptext = "<div class='input-group input-group-sm' style='width:100%!important'>" +
            "<div class='input-group-btn' style='height:100%!important'>" +
            " <button type='button' style='width:100% !important;height:100%!important;' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'> = </button>" +
            " <ul class='dropdown-menu'  style='z-index:" + zidx.toString() + "'>" +
            "   <li ><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">=</a></li>" +
            " <li><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "><</a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">></a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "><=</a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">>=</a></li>" +
            "<li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">B</a></li>" +
            " </ul>" +
            " </div>" +
            " <input type='number' data-toggle='tooltip' title='' style='width:100%!important' class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            //" <span class='input-group-btn'></span>" +
            //" <input type='number' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return drptext;
    };

    this.getFilterForDateTime = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx) {
        var coltype = "data-coltyp='date'";
        var filter = "<div class='input-group input-group-sm' style='width:100%!important'>" +
            "<div class='input-group-btn' style='height:100%!important'>" +
            " <button type='button' style='width:100% !important;height:100% !important;' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'> = </button>" +
            "<ul class='dropdown-menu'  style='z-index:" + zidx.toString() + "'>" +
            " <li ><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">=</a></li>" +
            " <li><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "><</a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">></a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "><=</a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">>=</a></li>" +
            " <li ><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">B</a></li>" +
            " </ul>" +
            " </div>" +
            " <input type='date' data-toggle='tooltip' title='' style='width:100%!important' class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            //" <span class='input-group-btn'></span>" +
            //" <input type='date' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return filter;
    };

    this.getFilterForString = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx) {
        var coltype = " data-coltyp='string'";
        var drptext = "";
        drptext = "<div class='input-group input-group-sm' style='width:100%!important'>" +
            "<div class='input-group-btn' style='z-index:" + zidx.toString() + "'>" +
            " <button type='button' style='width:100% !important' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'>x*</button>" +
            " <ul class='dropdown-menu'>" +
            "   <li ><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">x*</a></li>" +
            "  <li><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">*x</a></li>" +
            "  <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">*x*</a></li>" +
            " <li><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + ">=</a></li>" +
            " </ul>" +
            " </div>" +
            " <input type='text' data-toggle='tooltip' title='' style='width:100%!important'  class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return drptext;
    };

    this.getFilterForBoolean = function (colum, tableId, zidx) {
        var filter = "";
        var id = tableId + "_" + colum + "_hdr_txt1";
        var cls = tableId + "_hchk";
        filter = "<center><input type='checkbox' id='" + id + "' data-toggle='tooltip' title='' data-colum='" + colum + "' data-coltyp='boolean' data-table='" + tableId + "' class='" + cls + " " + tableId + "_htext eb_fbool" + this.tableId + "' style='vertical-align: middle;'></center>";
        return filter;
    };

    this.clearFilter = function () {
        var flag = false;
        var tableid = this.tableId;
        $('#' + tableid + '_wrapper table:eq(0) .' + tableid + '_htext').each(function (i) {
            if ($(this).hasClass(tableid + '_hchk')) {
                if (!($(this).is(':indeterminate'))) {
                    flag = true;
                    $(this).prop("indeterminate", true);
                }
            }
            else {
                if ($(this).val() !== '') {
                    flag = true;
                    $(this).val('');
                }
            }
        });
        if (flag || this.filterFlag) {
            this.Api.ajax.reload();
            this.filterFlag = false;
            $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-times").addClass("fa-filter");
        }
    };

    this.setLiValue = function (e) {
        var selText = $(e.target).text();
        var table = $(e.target).attr('data-table');
        var flag = false;
        var colum = $(e.target).attr('data-colum');
        var ctype = $(e.target).parents('.input-group').find("input").attr('data-coltyp');
        $(e.target).parents('.input-group-btn').find('.dropdown-toggle').html(selText);
        //" <input type='number' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">"dv173_1_discount_hdr_txt1
        //$(e.target).parents('.input-group').find('#' + table + '_' + colum + '_hdr_txt2').eq(0).css('visibility', ((selText.trim() === 'B') ? 'visible' : 'hidden'));
        if (selText.trim() === 'B') {
            if ($(e.target).parents('.input-group').find("input").length == 1) {
                $(e.target).parents('.input-group').append("<input type='" + ctype + "' class='between-inp form-control eb_finput " + this.tableId + "_htext' id='" + this.tableId + "_" + colum + "_hdr_txt2'>");
                $("#" + this.tableId + "_" + colum + "_hdr_txt1").addClass("between-inp");
                $("#" + this.tableId + "_" + colum + "_hdr_txt2").on("keyup", this.call_filter);
            }
            //flag = true;
        }
        else if (selText.trim() !== 'B') {
            if ($(e.target).parents('.input-group').find("input").length == 2) {
                $(e.target).parents('.input-group').find("input").eq(1).remove();
                $("#" + this.tableId + "_" + colum + "_hdr_txt1").removeClass("between-inp");
                //$("#" + this.tableId + "_" + colum + "_hdr_txt1").style("width", "100%", "important"); 
            }
            //flag = false;
        }
        this.Api.columns.adjust();
        e.preventDefault();
    };

    this.call_filter = function (e) {
        if (this.Api.settings().init().serverSide) {
            if (e.keyCode === 13) {
                var flag = true;
                if ($(e.target).siblings(".eb_finput").length === 1) {
                    if ($(e.target).val() === "") {
                        $(e.target).css("border-color", "red");
                        flag = false;
                    }
                    else
                        $(e.target).css("border-color", "#ccc");
                    if ($(e.target).siblings(".eb_finput").val() === "") {
                        $(e.target).siblings(".eb_finput").css("border-color", "red");
                        flag = false;
                    }
                    else
                        $(e.target).siblings(".eb_finput").css("border-color", "#ccc");
                }
                else {
                    if ($(e.target).val().trim() == "") {
                        flag = false;
                        $(e.target).css("border-color", "red");
                    }
                    else
                        $(e.target).css("border-color", "#ccc");
                }

                if (flag) {
                    $('#' + this.tableId).DataTable().ajax.reload();
                    if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-filter"))
                        $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-filter").addClass("fa-times");
                }
            }
        }
        else {
            this.Implementlocalsearch();
        }
    }.bind(this);

    this.Implementlocalsearch = function () {
        if (this.Api !== null) {
            this.Api.columns().every(function (i) {
                var colum = this.Api.settings().init().aoColumns[i].name;
                var textid = '#' + this.tableId + '_' + colum + '_hdr_txt1';
                let val = $(textid).val();
                if (colum !== 'checkbox' && colum !== 'serial' && val !== undefined) {
                    this.Api.column(i).search(val).draw();
                }
            }.bind(this));
        }
    };

    this.toggleInFilter = function (e) {
        var table = $(e.target).attr('data-table');
        this.Api.ajax.reload();
    };

    this.fselect_func = function (e) {
        var selValue = $(e.target).text().trim();
        $(e.target).parents('.input-group-btn').find('.dropdown-toggle').html(selValue);
        var table = $(e.target).attr('data-table');
        var colum = $(e.target).attr('data-column');
        var decip = $(e.target).attr('data-decip');
        var col = this.Api.column(colum + ':name');
        var ftrtxt;

        ftrtxt = '.dataTables_scrollFootInner #' + this.tableId + '_' + colum + '_ftr_txt0';

        if (selValue === '')
            pageTotal = col.data().sum();
        else if (selValue === 'x')
            pageTotal = col.data().average();
        // IF decimal places SET, round using toFixed  
        //$(ftrtxt).val((decip > 0) ? pageTotal.toFixed(decip) : pageTotal.toFixed(2));
        $(ftrtxt).val(pageTotal.toFixed(decip));
        e.preventDefault();
        //e.stopPropagation();
    };

    this.clickAlSlct = function (e) {
        //var tableid = $(e.target).attr('data-table');
        if (e.target.checked)
            $('#' + this.tableId + '_wrapper tbody [type=checkbox]:not(:checked)').trigger('click');
        else
            $('#' + this.tableId + '_wrapper tbody [type=checkbox]:checked').trigger('click');

        e.stopPropagation();
    };

    this.arrangeFooterWidth = function () {
        var lfoot = $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper table');
        var rfoot = $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper table');
        var scrollfoot = $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner table');

        if (this.ebSettings.LeftFixedColumn > 0 || this.ebSettings.RightFixedColumn > 0) {
            if (this.ebSettings.LeftFixedColumn > 0) {
                for (let j = 0; j < this.ebSettings.LeftFixedColumn; j++) {
                    $(lfoot).children().find("tr").eq(0).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(0).children("th").eq(j).css("width"));
                }
            }

            if (this.ebSettings.RightFixedColumn > 0) {
                var start = scrollfoot.find("tr").eq(0).children().length - this.ebSettings.RightFixedColumn;
                for (let j = 0; (j + start) < scrollfoot.find("tr").eq(0).children().length; j++) {
                    $(rfoot).children().find("tr").eq(0).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(0).children("th").eq(j + start).css("width"));
                }
            }
        }

        $("#" + this.tableId + " thead tr:eq(1) .eb_finput").parent().remove();
    };

    this.renderCheckBoxCol = function (data2, type, row, meta) {
        if (this.FlagPresentId) {
            this.hiddenIndex = $.grep(this.ebSettings.Columns.$values, function (obj) { return obj.name.toLocaleLowerCase() === this.hiddenFieldName.toLocaleLowerCase(); }.bind(this))[0].data;
            //var idpos = getObjByval(this.ebSettings.Columns.$values, "name", this.hiddenFieldName).data;
            this.rowId = meta.row; //do not remove - for updateAlSlct
            return "<input type='checkbox' class='" + this.tableId + "_select' name='" + this.tableId + "_id' value='" + ((row[this.hiddenIndex] !== null) ? row[this.hiddenIndex].toString() : null) + "'/>";
        }
        else
            return "<input type='checkbox' class='" + this.tableId + "_select'/>";
    };

    this.updateAlSlct = function (e) {
        var idx = this.Api.row($(e.target).parent().parent()).index();
        if (e.target.checked) {
            this.Api.rows(idx).select();
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", true);
        }
        else {
            this.Api.rows(idx).deselect();
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", true);
        }
        var CheckedCount = $('.' + this.tableId + '_select:checked').length;
        var UncheckedCount = this.Api.rows().count() - CheckedCount;
        if (CheckedCount === this.Api.rows().count()) {
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", false);
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop('checked', true);
        }
        else if (UncheckedCount === this.Api.rows().count()) {
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", false);
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop('checked', false);
        }
    };


    this.link2NewTable = function (e) {
        var cData;
        this.isContextual = true;
        if ($(e.target).closest("a").attr("data-latlong") !== undefined)
            cData = $(e.target).closest("a").attr("data-latlong");
        else
            cData = $(e.target).text();
        this.linkDV = $(e.target).closest("a").attr("data-link");
        var idx = this.Api.row($(e.target).parent().parent()).index();
        this.rowData = this.Api.row(idx).data();
        this.filterValues = this.getFilterValues("link");
        if (this.login === "uc")
            dvcontainerObj.drawdvFromTable(this.rowData.toString(), JSON.stringify(this.filterValues), cData.toString());//, JSON.stringify(this.filterValues)
        else
            this.OpeninNewTab(idx, cData);
    };

    this.call2newTable = function () {

        //var EbDataTable_Newtable = new EbDataTable({
        //    dv_id: this.linkDV,
        //    ss_url: "https://expressbaseservicestack.azurewebsites.net",
        //    tid: 'dv' + this.linkDV + '_' + index,
        //    linktable: true,
        //    cellData: this.cellData,
        //    rowData: this.rowData,
        //    filterValues: this.filterValues
        //    //directLoad: true
        //});

        $.ajax({
            type: "POST",
            url: "../DV/dvTable",
            data: { objid: this.linkDV, objtype: 16 },
            success: function (text) {
                var myWindow = window.open("", "");
                myWindow.document.write(text);
            }
        });
    };

    this.collapseFilter = function () {
        this.filterBox.toggle();
        if (this.filterBox.css("display") == "none") {
            $("#btnCollapse" + this.tableId).children().remove();
            $("#btnCollapse" + this.tableId).append("<i class='fa fa-chevron-down' aria-hidden='true'></i>")
        }
        else {
            $("#btnCollapse" + this.tableId).children().remove();
            $("#btnCollapse" + this.tableId).append("<i class='fa fa-chevron-up' aria-hidden='true'></i>")
        }
    };

    this.updateRenderFunc = function () {
        $.each(this.ebSettings.Columns.$values, this.updateRenderFunc_Inner.bind(this));
    };

    this.updateRenderFunc_Inner = function (i, col) {
        var type = col.Type || col.type;
        if (type === parseInt(gettypefromString("Date")) || type === parseInt(gettypefromString("DateTime"))) {
            if (this.datetimeformat) {
                this.ebSettings.Columns.$values[i].render = this.renderDateformat.bind(this);
                this.ebSettings.Columns.$values[i].mRender = this.renderDateformat.bind(this);
            }
        }
    };

    this.openColumnTooltip = function (e, i) {
        $(e.currentTarget).siblings(".popover").find(".popover-content").empty().append(atob($(e.currentTarget).attr("data-content")));
        $(e.currentTarget).siblings(".popover").find(".arrow").remove();
    };

    this.renderProgressCol = function (deci, data, type, row, meta) {
        return "<div class='progress'><div class='progress-bar' role='progressbar' aria-valuenow='" + parseFloat(data.toString()).toFixed(deci) + "' aria-valuemin='0' aria-valuemax='100' style='width:" + data.toString() + "%'>" + parseFloat(data.toString()).toFixed(deci) + "</div></div>";
    };

    this.renderToDecimalPlace = function (data, type, row, meta) {
        return parseFloat(data).toFixed();
    };

    this.renderEditableCol = function (data) {
        return (data === true) ? "<input type='checkbox' data-toggle='toggle' data-size='mini' checked>" : "<input type='checkbox' data-toggle='toggle' data-size='mini'>";
    };

    this.renderIconCol = function (data) {
        return (data === true) ? "<i class='fa fa-check' aria-hidden='true'  style='color:green'></i>" : "<i class='fa fa-times' aria-hidden='true' style='color:red'></i>";
    };

    this.renderEbVoidCol = function (data) {
        return (data === true) ? "<i class='fa fa-ban' aria-hidden='true'></i>" : "";
    };

    this.renderLockCol = function (data) {
        return (data === true) ? "<i class='fa fa-lock' aria-hidden='true'></i>" : "";
    };

    this.renderlink4NewTable = function (data, type, row, meta) {
        return "<a href='#' oncontextmenu='return false' class ='tablelink_" + this.tableId + "' data-link='" + this.ebSettings.Columns.$values[meta.col - 2].LinkRefId + "'>" + data + "</a>";
    };

    this.renderlinkandDecimal = function (deci, data) {
        return "<a href='#' oncontextmenu='return false' class ='tablelink_" + this.tableId + "' data-link='" + this.linkDV + "'>" + parseFloat(data).toFixed(deci) + "</a>";
    };

    this.colorRow = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        $.each(this.ebSettings.Columns.$values, function (i, value) {
            var rgb = '';
            var fl = '';
            if (value.name === 'sys_row_color') {
                HEX = Number(aData[value.data]).toString(16);
                var t = (HEX.toString().length < 6) ? ("0" + HEX.toString()) : HEX;
                $(nRow).css('background-color', '#' + t);
            }

            if (value.name === 'sys_cancelled') {
                var tr = aData[value.data];
                if (tr === true)
                    $(nRow).css('color', '#f00');
            }
        });
    };

    this.lineGraphDiv = function (data, type, row, meta) {
        if (!data)
            return "";
        else
            return "<canvas id='eb_cvs" + meta.row + "' class='eb_canvas" + this.tableId + "' style='width:120px; height:40px; cursor:pointer;' data-graph='" + data + "' data-toggle='modal'></canvas><script>renderLineGraphs(" + meta.row + "); $('#eb_cvs" + meta.row + "').mousemove(function(e){ GPointPopup(e); });</script>";
    };

    this.RenderGraphModal = function () {
        $(document.body).append("<div class='modal fade' id='graphmodal' role='dialog'>"
            + "<div class='modal-dialog modal-lg'>"
            + " <div class='modal-content'>"
            + "<div class='modal-header'>"
            + "<button type = 'button' class='close' data-dismiss='modal'>&times;</button>"
            + "<h4 class='modal-title'><center>Graph</center></h4>"
            + "</div>"
            + "<div class='modal-body'>"
            + "<div class='dygraph-Wrapper'>"
            + "<div id='graphdiv' style='width:100%;height:500px;'></div>"
            + "</div>  "
            + "</div>"
            + "</div>"
            + "</div>"
            + "</div>");
        $(document).on('show.bs.modal', '.modal', function (event) {
            var zIndex = 1040 + (10 * $('.modal:visible').length);
            $(this).css('z-index', zIndex);
            setTimeout(function () {
                $('.modal-backdrop').not('.modal-stack').css('z-index', zIndex - 1).addClass('modal-stack');
            }, 0);
        });
    };

    this.renderMainGraph = function (e) {
        $("#graphmodal").modal('show');

        setTimeout(function () {
            var gcsv = csv($(e.target).attr("data-graph").toString());
            new Dygraph(
                document.getElementById('graphdiv'),
                gcsv,
                {
                    showRangeSelector: true,
                    interactionModel: Dygraph.defaultInteractionModel,
                    includeZero: true,
                    stackedGraph: true,
                    axes: {
                        y: {
                            valueFormatter: function (y) {
                                return y;
                            },
                            axisLabelFormatter: function (y) {
                                y = y.toString();
                                if (y.slice(-3) === '000')
                                    return y.slice(0, -3) + 'K';
                                else
                                    return y;
                            },
                        },
                        logscale: true
                    }
                }
            );
        }, 500);
    };

    this.ModifyDvname = function () {
        this.ebSettings.Name = $("#dvnametxt").val();
        $("label.dvname").text(this.ebSettings.Name);
    };

    this.ModifyTableHeight = function () {
        this.ebSettings.scrollY = $("#TableHeighttxt").val();
        this.ebSettings.scrollY = (this.ebSettings.scrollY < 100) ? "300" : this.ebSettings.scrollY;
    };

    this.renderMarker = function (data) {
        if (data !== ",")
            return `<a href='#' class ='columnMarker_${this.tableId}' data-latlong='${data}'><i class='fa fa-map-marker fa-2x' style='color:red;'></i></a>`;
        else
            return null;
    };

    this.renderFBImage = function (data) {
        if (typeof (data) === "string")
            return `<img class='img-thumbnail' src='http://graph.facebook.com/${data}/picture?type=square' />`;
        else
            return `<img class='img-thumbnail' src='http://graph.facebook.com/12345678/picture?type=square' />`;
    };

    this.getRowDataByUid = function (Uid) {
        var $tr = $("#" + this.tableId + " tr[data-uid='" + Uid + "']");
        var rowData = this.Api.row($tr).data();
        return rowData;
    };


    this.renderDataAsLabel = function (data) {
        return `<label class='labeldata'>${data}</label>`;
    };

    this.renderDateformat = function (data, sym) {
        if (typeof data !== "object" && typeof data !== "undefined") {
            var date = new Date(parseInt(data.substr(6)));
            var month = date.getMonth() + 1;
            var dt = date.getDate();
            if (sym === "-")
                return (dt.toString().length > 1 ? dt : "0" + dt) + "-" + (month.toString().length > 1 ? month : "0" + month) + "-" + date.getFullYear();
            else
                return (dt.toString().length > 1 ? dt : "0" + dt) + "/" + (month.toString().length > 1 ? month : "0" + month) + "/" + date.getFullYear();
        }
        else
            return "";
    };

    this.init();
};


var EbCommonDataTable = function (Option) {

    //let AllMetas = AllMetasRoot["EbDataVisualizationObject"];// newly added line to declare a local variable named "AllMetas"  which contains contextaul metas

    //if (typeof (AllMetas) === 'undefined') var AllMetas = AllMetas_w;
    //if (typeof (EbEnums) === 'undefined') var EbEnums = EbEnums_w;
    //if (typeof (EbObjects) === 'undefined') var EbObjects = EbObjects_w;

    this.propGrid = Option.PGobj;
    this.Api = null;
    this.order_info = new Object();
    this.order_info.col = '';
    this.order_info.dir = 0;
    this.MainData = Option.data || null;
    this.isPipped = false;
    this.isContextual = false;
    this.chartJs = null;
    this.url = Option.url;
    this.EbObject = Option.dvObject;
    this.showFilterRow = typeof Option.showFilterRow !== 'undefined' ? Option.showFilterRow : true;
    this.showSerialColumn = typeof Option.showSerialColumn !== 'undefined' ? Option.showSerialColumn : true;
    this.showCheckboxColumn = typeof Option.showCheckboxColumn !== 'undefined' ? Option.showCheckboxColumn : true;
    this.hiddenFieldName = Option.hiddenFieldName || "id";
    this.tabNum = Option.tabNum;
    this.Refid = Option.refid;
    this.tableId = Option.tableId || null;
    this.ssurl = Option.ssurl;
    this.login = Option.login;
    this.counter = Option.counter;
    this.datePattern = Option.datePattern || "dd-MM-yyyy";
    this.TenantId = Option.TenantId;
    this.UserId = Option.UserId;
    this.relatedObjects = null;
    this.FD = false;
    this.table_jQO = null;
    this.filterBox = null;
    this.filterbtn = null;
    this.clearfilterbtn = null;
    this.totalpagebtn = null;
    this.copybtn = null;
    this.printbtn = null;
    this.settingsbtn = null;
    this.OuterModalDiv = null;
    this.settings_tbl = null;
    this.ajaxCallCounter = 0;

    this.eb_filter_controls_4fc = [];
    this.eb_filter_controls_4sb = [];
    this.zindex = 0;
    this.rowId = -1;
    this.dropdown_colname = null;
    this.deleted_colname = null;
    this.tempcolext = [];
    this.linkDV = null;
    this.filterFlag = false;
    this.rowData = Option.rowData ? JSON.parse(decodeURIComponent(escape(window.atob(Option.rowData)))) : null;
    this.filterValues = Option.filterValues ? JSON.parse(decodeURIComponent(escape(window.atob(Option.filterValues)))) : [];
    this.FlagPresentId = false;
    this.flagAppendColumns = false;
    this.drake = null;
    this.draggedPos = null;
    this.droppedPos = null;
    this.dragNdrop = false;
    this.flagColumnVisible = false;
    this.pg = null;
    this.ppgridChildren = null;
    this.columnDefDuplicate = null;
    this.extraCol = [];
    this.PcFlag = false;
    this.modifyDVFlag = false;
    this.initCompleteflag = false;
    this.isTagged = false;
    this.isRun = false;
    this.cellData = Option.cellData;
    this.columnSearch = [];
    this.isSecondTime = false;
    this.tempColumns = [];
    this.filterHtml = "";
    this.orderColl = [];
    this.RGIndex = [];
    this.NumericIndex = [];
    this.inline = false;
    this.rowgroupCols = [];
    this.treeCols = [];
    this.rowgroupFilter = [];
    this.CurrentRowGroup = null;
    this.permission = [];
    this.isCustomColumnExist = false;
    this.dvformMode = -1;
    this.IsTree = false;
    this.GroupFormLink = null;
    this.ItemFormLink = null;
    this.treeColumn = null;
    this.treeData = [];
    this.tableName = null;
    this.moveToPid = null;
    this.movefromId = null;
    this.columnCount = null;
    this.Source = Option.Source || "EbDataTable";
    this.columns = Option.columns || ((this.EbObject) ? this.EbObject.Columns.$values : null);
    this.contId = Option.containerId;
    this.scrollHeight = Option.scrollHeight || "inherit";
    this.IsPaging = typeof Option.IsPaging !== 'undefined' ? Option.IsPaging : true;
    this.LeftFixedColumn = Option.LeftFixedColumn || 0;
    this.RightFixedColumn = Option.RightFixedColumn || 0;
    this.RowHeight = Option.RowHeight || "15";
    this.ObjectLinks = Option.ObjectLinks || [];
    this.AllowSelect = typeof Option.AllowSelect !== 'undefined' ? Option.AllowSelect : true;
    this.AllowSorting = typeof Option.AllowSorting !== 'undefined' ? Option.AllowSorting : true;


    if (this.Source === "EbDataTable") {
        if (this.EbObject && this.EbObject.ApiRefId !== null && this.EbObject.ApiRefId !== "")
            this.Source = "PivotTable";
        this.split = new splitWindow("parent-div0", "contBox");

        this.split.windowOnFocus = function (ev) {
            $("#Relateddiv").hide();
            if ($(ev.target).attr("class") !== undefined) {
                if ($(ev.target).attr("class").indexOf("sub-windows") !== -1) {
                    var id = $(ev.target).attr("id");
                    focusedId = id;
                }
            }
        }.bind(this);

        this.init = function () {
            this.tableId = "dv" + this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter;
            this.ContextId = "filterWindow_" + this.tableId;
            this.FDCont = $(`<div id='${this.ContextId}' class='filterCont fd'></div>`);
            $("#parent-div0").before(this.FDCont);
            $(".filterCont").hide();
        };
    }


    this.call2FD = function (value) {
        if (this.Source === "EbDataTable") {
            this.submitId = "btnGo" + this.tableId;
            var isCustom = (typeof (value) !== "undefined") ? ((value === "Yes") ? true : false) : true;
            this.relatedObjects = this.EbObject.DataSourceRefId;
            $("#eb_common_loader").EbLoader("show", { maskItem: { Id: "#parent", Style: { "top": "39px", "margin-left": "unset", "margin-right": "unset" } }, maskLoader: false });
            $.ajax({
                type: "POST",
                url: "../DV/dvCommon",
                data: { dvobj: JSON.stringify(this.EbObject), dvRefId: this.Refid, _flag: this.PcFlag, login: this.login, contextId: this.ContextId, customcolumn: isCustom, _curloc: ebcontext.locations.CurrentLoc, submitId: this.submitId },
                success: this.ajaxSucc
            });
        }
        else {
            if (this.columns === null) {
                $.ajax({
                    type: "POST",
                    url: "../boti/dvView1",
                    data: { dvobj: JSON.stringify(this.EbObject) },
                    success: this.ajaxSucc.bind(this)
                });
            }
        }
    };

    this.ajaxSucc = function (text) {
        if (this.Source === "EbDataTable" || this.Source === "PivotTable") {
            var flag = false;
            if (this.MainData !== null) {
                this.isPipped = true;
                $("#Pipped").show();
                $("#Pipped").text("Pipped From: " + this.EbObject.Pippedfrom);
                this.filterValues = dvcontainerObj.dvcol[prevfocusedId].filterValues;
            }
            else if (this.filterValues !== null && this.filterValues.length > 0) {
                this.isContextual = true;
            }
            else
                this.isTagged = true;
            var subDivId = "#sub_window_dv" + this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter;
            $("#content_dv" + this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter).empty();
            this.filterHtml = text;
            let search = $('#obj_icons .toolb-srchbx-wrpr').detach();
            $('#obj_icons').empty().append(search);
            this.$submit = $("<button id='" + this.submitId + "' class='btn commonControl'><i class='fa fa-play' aria-hidden='true'></i></button>");
            $("#obj_icons").append(this.$submit);
            this.$submit.click(this.getColumnsSuccess.bind(this));

            this.FDCont = $("#filterWindow_" + this.tableId);
            $("#filterWindow_" + this.tableId).empty();
            $("#filterWindow_" + this.tableId).append("<div class='pgHead'> Param window <div class='icon-cont  pull-right' id='close_paramdiv_" + this.tableId + "'><i class='fa fa-thumb-tack' style='transform: rotate(90deg);'></i></div></div>");//

            $("#filterWindow_" + this.tableId).children().find("#close_paramdiv_" + this.tableId).off('click').on('click', this.CloseParamDiv.bind(this));

            $("#filterWindow_" + this.tableId).append(text);
            $("#filterWindow_" + this.tableId).children().find("#btnGo").click(this.getColumnsSuccess.bind(this));

            this.FilterDialog = (typeof (FilterDialog) !== "undefined") ? FilterDialog : {};

            if (text !== "") {
                if (typeof commonO !== "undefined")
                    this.EbObject = commonO.Current_obj;
                else
                    this.EbObject = dvcontainerObj.currentObj;
            }
            //this.InitializeColumns();
            this.SetColumnRef();
            //this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
            if (this.PcFlag === true)
                this.compareAndModifyRowGroup();

            if (jQuery.isEmptyObject(this.FilterDialog)) {
                this.FD = false;
                $(".filterCont").hide();
                $("#eb_common_loader").EbLoader("hide");
                this.$submit.trigger("click");
            }
            else {
                $(".ppcont").hide();
                this.filterid = "filter" + this.tableId;
                this.$filter = $("<button id='" + this.filterid + "' class='btn commonControl'><i class='fa fa-filter' aria-hidden='true'></i></button>");
                $("#obj_icons").append(this.$filter);
                this.$filter.click(this.CloseParamDiv.bind(this));
                this.FD = true;
                if (this.isPipped || this.isContextual) {
                    this.placefiltervalues();
                    if (!this.FilterDialog.FormObj.AutoRun)
                        this.$submit.trigger("click");
                }
                else {
                    this.FDCont.show();
                }
                $("#eb_common_loader").EbLoader("hide");
            }
            $(subDivId).focus();

            this.PcFlag = false;

            if (this.propGrid !== null) {
                //this.propGrid.PropertyChanged = this.tmpPropertyChanged;
                //this.CreatePgButton();
            }
        }
        else {
            if (this.MainData !== null)
                this.isPipped = true;
            $("#" + this.contId).append(text);////////////////        
            this.EbObject = dvGlobal.Current_obj;
            this.getColumnsSuccess();
        }
        this.FDCont.css("right", "0");
    }.bind(this);

    this.GetFD = function () {
        $("#eb_common_loader").EbLoader("show");
        this.RemoveColumnRef();
        this.FilterDialogRefId = this.EbObject.FilterDialogRefId;
        if (this.FilterDialogRefId !== "" && this.FilterDialogRefId)
            $.post("../dv/GetFilterBody", { dvobj: JSON.stringify(this.EbObject), contextId: "paramdiv" + this.tabNum }, this.ajaxSucc.bind(this));
    };

    this.GetFD4Pivot = function () {
        $("#eb_common_loader").EbLoader("show");
        this.RemoveColumnRef();
        this.ApiRefId = this.EbObject.ApiRefId;
        if (this.ApiRefId !== "" && this.ApiRefId)
            $.post("../dv/GetFD4Pivot", { dvobj: JSON.stringify(this.EbObject), contextId: "paramdiv" + this.tabNum }, this.ajaxSucc.bind(this));
    };

    this.SetColumnRef = function () {
        $.each(this.EbObject.Columns.$values, function (i, obj) {
            obj.ColumnsRef = this.EbObject.Columns;
        }.bind(this));
    };

    this.RemoveColumnRef = function () {
        $.each(this.EbObject.Columns.$values, function (i, obj) {
            obj.ColumnsRef = null;
        }.bind(this));
    };

    this.CloseParamDiv = function () {
        this.FDCont.toggle('drop', { direction: 'right' }, 150);
        if (this.FDCont.is(":visible"))
            $(".ppcont").hide();
    };

    this.tmpPropertyChanged = function (obj, Pname, newval, oldval) {
        //this.isSecondTime = true;
        if (Pname === "Name") {
            $("#objname").text(obj.DisplayName);
            console.log(obj);
        }
        else if (Pname === "Columns") {
            console.log(obj);
        }
        else if (Pname === "Formula") {
            this.ValidateCalcExpression(obj);
        }
        else if (Pname === "RowGroupCollection") {
            this.CurrentRowGroup = null;
            this.rowgroupCols = [];
        }
    }.bind(this);

    this.dialogboxAction = function (value) {
        this.call2FD(value);
    };

    this.compareAndModifyRowGroup = function () {
        var temparr = [];
        $.each(this.EbObject.RowGroupCollection.$values, function (i, obj) {
            $.each(obj.RowGrouping.$values, function (j, col) {
                var tempcol = $.grep(this.EbObject.Columns.$values, function (column) { return column.name === col.name && column.Type === col.Type });
                if (tempcol.length !== 1) {
                    temparr.push(i);
                    return false;
                }
            }.bind(this));
        }.bind(this));
        $.each(temparr, function (i, index) {
            this.EbObject.RowGroupCollection.$values.splice(index, 1);
        }.bind(this));
        this.CurrentRowGroup = null;
    };

    //Initialisation
    this.start4EbDataTable = function () {
        if (this.EbObject === null) {
            this.EbObject = new EbObjects["EbTableVisualization"]("Container_" + Date.now());
            this.split.createContentWindow(this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter, "EbTableVisualization");
        }
        else {
            if (this.MainData !== null)
                this.split.createContentWindow(this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter, "EbTableVisualization", prevfocusedId);
            else
                this.split.createContentWindow(this.EbObject.EbSid + "_" + this.tabNum + "_" + this.counter, "EbTableVisualization");
        }

        $("#objname").text(this.EbObject.DisplayName);
        //this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
        this.init();
        $("title").text(this.EbObject.DisplayName);
        if (this.EbObject.DataSourceRefId) {
            this.call2FD();
            this.EbObject.IsPaging = this.IsPaging;
        }
        else {
            this.EbObject.IsPaging = this.IsPaging = false;
            if (this.EbObject.IsDataFromApi && this.EbObject.FilterDialogRefId)
                this.GetFD();
            else if (this.EbObject.ApiRefId)
                this.GetFD4Pivot();
            else
                this.getColumnsSuccess();
        }
    };

    this.start4Other = function () {
        if (!this.EbObject)
            this.EbObject = new EbObjects["EbTableVisualization"]("Container_" + Date.now());
        if (this.columns === null)
            this.call2FD();
        else {
            this.EbObject.Columns.$values = this.columns;
        }
        if (this.MainData !== null)
            this.isPipped = true;
        this.EbObject.IsPaging = this.IsPaging;
        this.getColumnsSuccess();
    };

    this.getColumnsSuccess = function (e) {
        this.showEbLoader();
        if (this.Source === "EbDataTable") {
            this.Do4EbdataTable();
            this.Done4All();
        }
        else if (this.Source === "Calendar") {
            $("#" + this.contId).empty();
            $("#" + this.contId).append(`<table id="${this.tableId}" class="table display table-bordered compact"></table>`);
            this.EbObject.LeftFixedColumn = this.LeftFixedColumn;
            this.EbObject.RightFixedColumn = 0;
            this.EbObject.RowHeight = this.RowHeight;
            //this.EbObject.DataSourceRefId = Option.dsid;
            //this.MainData = null;
            this.Done4All();
        }
        else if (this.Source === "datagrid") {
            this.EbObject.LeftFixedColumn = this.LeftFixedColumn;
            this.EbObject.RightFixedColumn = this.RightFixedColumn;
            this.Done4All();
        }
        else if (this.Source === "WebForm") {
            this.MainData = null;
            this.totalcount = 0;
            this.Done4All();
        }
        else if (this.Source === "PivotTable") {
            this.GetData4Pivot();
        }
        else {
            this.Done4All();
        }
    };

    this.Done4All = function () {
        this.getNotvisibleColumns();
        this.initCompleteflag = false;
        this.extraCol = [];
        this.check4Customcolumn();
        this.CheckforTree();
        this.addSerialAndCheckboxColumns();
        this.ModifyColumnObject();
        this.treeCols = [];
        this.getColumnCount();
        //hard coding
        this.orderColl = [];
        let rowG_coll = this.EbObject.RowGroupCollection.$values;
        let CurR_RowG = this.CurrentRowGroup;
        if (rowG_coll.length > 0 && !this.EbObject.DisableRowGrouping) {
            if (CurR_RowG === null) {
                CurR_RowG = rowG_coll.find(obj => obj.RowGrouping.$values.length > 0);
                this.CurrentRowGroup = CurR_RowG;
            }
            this.visibilityCheck();
        }
        else {
            if (this.CurrentRowGroup !== null) {
                $.each(this.EbObject.Columns.$values, function (i, colobj) {
                    $.each(CurR_RowG.RowGrouping.$values, function (i, rgobj) {
                        if (colobj.name === rgobj.name) {
                            colobj.bVisible = true;
                        }
                    }.bind(this));
                }.bind(this));
            }
            this.CurrentRowGroup = null;
            this.RGIndex = [];
            this.rowgroupCols = [];

        }


        //----------
        if (this.EbObject.$type.indexOf("EbTableVisualization") !== -1) {
            $("#content_" + this.tableId).empty();
            $("#content_" + this.tableId).append("<div id='" + this.tableId + "divcont' class='wrapper-cont_inner'><table id='" + this.tableId + "' class='table display table-bordered compact'></table></div>");

        }
        this.Init();
    };

    this.GetData4Pivot = function () {
        $(".ppcont").hide();
        $(".filterCont").hide();
        if (this.FilterDialog) {
            this.validateFD = this.FilterDialog.IsFDValidationOK;
            if (this.isContextual) {
                if (this.isSecondTime) {
                    if (this.validateFD && !this.validateFD())
                        return;
                    this.filterValues = this.getFilterValues("filter");
                }
            }
            else {
                if (this.validateFD && !this.validateFD())
                    return;
                this.filterValues = this.getFilterValues("filter");
            }
        }
        $("#eb_common_loader").EbLoader("show");
        this.filtervalues = this.getFilterValues();
        this.RemoveColumnRef();
        $.ajax({
            url: "../dv/getData",
            type: 'POST',
            data: { RefId: null, DataVizObjString: JSON.stringify(this.EbObject), ModifyDv: true, Params: this.filtervalues, LocId: store.get("Eb_Loc-" + ebcontext.sid + ebcontext.user.UserId) },
            success: this.GetData4PivotSuccess.bind(this),
        });
    };

    this.GetData4PivotSuccess = function (result) {
        if (result.responseStatus) {
            if (result.responseStatus.message !== null) {
                console.log("Table View PreProcessing Error " + result.responseStatus.message);
                if (this.Source === "WebForm" || this.Source === "Bot" || this.Source === "DashBoard")
                    $("#" + this.tableId + "_processing").text("Something went wrong..");
                else
                    EbPopBox("show", { Message: "Table View PreProcessing Error Occured...", Title: "Error" });
            }
        }
        this.MainData = result;
        this.EbObject = JSON.parse(result.returnObjString);
        this.isPipped = true;
        this.Done4All();
    };

    this.getNotvisibleColumns = function () {
        if (this.EbObject.NotVisibleColumns.$values.length === 0)
            this.EbObject.NotVisibleColumns.$values = this.EbObject.Columns.$values.filter((obj) => !obj.bVisible);
    };

    this.Do4EbdataTable = function () {
        $("#objname").text(this.EbObject.DisplayName);
        if (this.isSecondTime)
            this.MainData = null;
        $(".ppcont").hide();
        $(".filterCont").hide();
        if (this.FilterDialog) {
            this.validateFD = this.FilterDialog.IsFDValidationOK;
            if (this.isContextual) {
                if (this.isSecondTime) {
                    if (this.validateFD && !this.validateFD())
                        return;
                    this.filterValues = this.getFilterValues("filter");
                }
            }
            else {
                if (this.validateFD && !this.validateFD())
                    return;
                this.filterValues = this.getFilterValues("filter");
            }
        }
        this.isSecondTime = false;
        this.totalcount = 0;
        //if (this.login === "uc")
        //    $(".dv-body1").show();
        $.extend(this.tempColumns, this.EbObject.Columns.$values);
        //this.tempColumns.sort(this.ColumnsComparer);
        this.dsid = this.EbObject.DataSourceRefId;//not sure..
        this.dvName = this.EbObject.Name;
    };

    this.check4Customcolumn = function () {
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.IsCustomColumn; });
        if (temp.length === 0)
            this.isCustomColumnExist = false;
        else {
            this.isCustomColumnExist = true;
            temp.forEach(function (x) {
                if (x.$type.indexOf("DVPhoneColumn") !== -1)
                    x.orderable = true;
                else
                    x.orderable = false;
            });
        }
    };

    this.CheckforTree = function () {
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.IsTree; });
        if (temp.length === 0) {
            //this.EbObject.DisableRowGrouping = false;
            this.IsTree = false;
        }
        else {
            this.EbObject.DisableRowGrouping = true;
            this.IsTree = true;
            this.GroupFormLink = temp[0].GroupFormLink;
            this.ItemFormLink = temp[0].ItemFormLink;
            this.treeColumn = temp[0];
            this.treeColumnIndex = (this.Source === "locationTree") ? 0 : this.EbObject.Columns.$values.findIndex(x => x.data === this.treeColumn.data);
        }
        if (this.IsTree)
            this.EbObject.IsPaging = false;
    };

    this.ModifyColumnObject = function () {
        if (this.IsTree) {
            this.EbObject.Columns.$values.map(function (x) {
                x.orderable = false;
                return x;
            });
        }
    };

    this.getColumnCount = function () {
        this.columnCount = this.rowgroupCols.length + this.extraCol.length;
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.bVisible; });
        this.columnCount += temp.length;
    };

    this.InitializeColumns = function () {
        $.each(this.EbObject.Columns.$values, function (i, col) {
            if (col.HideDataIfRowMoreThan === null)
                col.HideDataIfRowMoreThan = { "$type": "ExpressBase.Objects.Objects.DVRelated.HideColumnData, ExpressBase.Objects", "Enable": false, "UnRestrictedRowCount": 0, "ReplaceByCharacter": "", "ReplaceByText": "" };
        }.bind(this));
    };

    this.validateFD = function () { }

    this.Init = function () {
        //this.MainData = null;
        //$.event.props.push('dataTransfer');
        //this.Eb_DataTable_StyleFn();
        this.updateRenderFunc();
        this.table_jQO = $('#' + this.tableId);
        this.copybtn = $("#btnCopy" + this.tableId);
        this.printbtn = $("#btnPrint" + this.tableId);
        this.printSelectedbtn = $("#btnprintSelected" + this.tableId);
        this.excelbtn = $("#btnExcel" + this.tableId);
        this.csvbtn = $("#btnCsv" + this.tableId);
        this.pdfbtn = $("#btnPdf" + this.tableId);

        this.eb_agginfo = this.getAgginfo();

        this.table_jQO.append($(this.getFooterFromSettingsTbl()));

        //this.table_jQO.children("tfoot").hide();
        this.table_jQO.children().find("tr").addClass("addedbyeb");

        //this.table_jQO.on('pre-row-reorder.dt', function (e, node, index) {
        //    console.log('Row reorder started: ', node, index);
        //});

        this.table_jQO.on('processing.dt', function (e, settings, processing) {
            if (processing == true) {
                if (this.Source != 'WebForm') {
                    $("#obj_icons .btn").prop("disabled", true);
                    $("#eb_common_loader").EbLoader("show");
                }
            }
            else {
                if (this.Source != 'WebForm') {
                    $("#obj_icons .btn").prop("disabled", false);
                    $("#eb_common_loader").EbLoader("hide");
                }
                $("[data-coltyp=date]").datepicker("hide");
            }
        }.bind(this));

        jQuery.fn.dataTable.ext.errMode = 'throw';

        this.table_jQO.on('error.dt', function (settings, techNote, message) {
            console.log('An error has been reported by DataTables: ', message);
        });

        $.fn.dataTable.ext.errMode = function (settings, helpPage, message) {
            console.log("Table View Error......" + message);
            if (this.Source === "WebForm" || this.Source === "Bot" || this.Source === "DashBoard")
                $("#" + settings.sTableId + "_processing").text("Something went wrong..");
            else
                EbPopBox("show", { Message: "Table View Error Occured....", Title: "Error" });
            this.hideEbLoader();
        }.bind(this);

        if (this.Source === "datagrid")
            this.table_jQO.off('draw.dt').on('draw.dt', this.doSerial.bind(this));

        this.Api = this.table_jQO.DataTable(this.createTblObject());

        this.Api.off('select').on('select', this.selectCallbackFunc.bind(this));

        this.Api.off('key-focus').on('key-focus', this.DTKeyFocusCallback.bind(this));

        $('#' + this.tableId + ' tbody').off('dblclick').on('dblclick', 'tr', this.dblclickCallbackFunc.bind(this));
        //$('#' + this.tableId + ' tbody').off('click').on('click', 'td', this.DTclickTDCallbackFunc.bind(this));

        jQuery.fn.dataTable.Api.register('sum()', function () {
            return this.flatten().reduce(function (a, b) {
                if (typeof a === 'string') {
                    a = a.replace(/[^\d.-]/g, '') * 1;
                    if (isNaN(a))
                        a = 0;
                }
                if (typeof b === 'string') {
                    b = b.replace(/[^\d.-]/g, '') * 1;
                    if (isNaN(b))
                        b = 0;
                }

                return a + b;
            }, 0);
        });

        jQuery.fn.dataTable.Api.register('average()', function () {
            var data = this.flatten();
            var sum = data.reduce(function (a, b) {
                if (typeof a === 'string') {
                    a = a.replace(/[^\d.-]/g, '') * 1;
                    if (isNaN(a))
                        a = 0;
                }
                if (typeof b === 'string') {
                    b = b.replace(/[^\d.-]/g, '') * 1;
                    if (isNaN(b))
                        b = 0;
                }

                return (a * 1) + (b * 1); // cast values in-case they are strings
            }, 0);

            return sum / data.length;
        });

        //$('#' + this.tableId + ' tbody').off('click').on('click', 'tr', this.rowclick.bind(this));
        //$('#' + this.tableId + ' tbody').off('mouseenter').on('mouseenter mouseleave', 'tr', this.mouseenter.bind(this));

        //this.Api.on('row-reorder', function (e, diff, edit) {
        //});
    };

    this.addSerialAndCheckboxColumns = function () {
        this.CheckforColumnID();//, 
        var serialObj = new Object();
        serialObj.data = (this.Source === "datagrid") ? null : this.EbObject.Columns.$values.length;
        serialObj.searchable = false;
        serialObj.orderable = false;
        serialObj.bVisible = this.showSerialColumn;
        serialObj.name = "serial";
        serialObj.title = "#";
        serialObj.Type = 11;
        serialObj.sWidth = "10px";
        if (this.IsTree) {
            serialObj.bVisible = false;
        }
        this.extraCol.push(serialObj);
        this.addcheckbox();
    }

    this.CheckforColumnID = function () {
        this.FlagPresentId = false;
        $.each(this.EbObject.Columns.$values, function (i, col) {
            if (col.name === this.hiddenFieldName.toLocaleLowerCase()) {
                this.FlagPresentId = true;
                col.bVisible = false;
                return false;
            }
        }.bind(this));
    };

    this.addcheckbox = function () {
        var chkObj = new Object();
        //chkObj.data = this.EbObject.Columns.$values.length;
        chkObj.title = "<input id='{0}_select-all' class='eb_selall" + this.tableId + "' type='checkbox' data-table='{0}'/>".replace("{0}", this.tableId);
        chkObj.sWidth = "10px";
        chkObj.orderable = false;
        chkObj.bVisible = (this.showCheckboxColumn) ? true : false;
        chkObj.name = "checkbox";
        chkObj.Type = 3;
        chkObj.render = this.renderCheckBoxCol.bind(this);
        chkObj.pos = "-1";

        this.extraCol.push(chkObj);
        var _array = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.name.toLocaleLowerCase() === this.hiddenFieldName.toLocaleLowerCase(); }.bind(this));
        if (_array.length > 0)
            this.hiddenIndex = _array[0].data;
    }

    this.createTblObject = function () {
        var o = new Object();
        o.scrollY = this.scrollHeight;
        o.scrollX = true;
        //o.scrollXInner = "110%";
        o.scrollCollapse = true;
        if (this.Source === "EbDataTable" || this.Source === "Draft") {
            if (this.EbObject.PageLength !== 0) {
                o.lengthMenu = this.generateLengthMenu();
            }
        }
        if (this.EbObject.LeftFixedColumn > 0 || this.EbObject.RightFixedColumn > 0)
            o.fixedColumns = { leftColumns: this.fixedColumnCount(), rightColumns: this.EbObject.RightFixedColumn };
        o.pagingType = "full";
        o.buttons = ['copy', 'csv', 'excel', 'pdf', 'print', { extend: 'print', exportOptions: { modifier: { selected: true } } }];
        o.bAutoWidth = false;
        o.autowidth = false;
        o.serverSide = (this.MainData === null) ? true : false;
        o.processing = true;
        o.pageResize = true;
        //o.deferRender = true;
        //o.scroller = true;
        o.language = {
            //processing: "<div class='fa fa-spinner fa-pulse fa-3x fa-fw'></div>",
            info: "_START_ - _END_ / _TOTAL_",
            paginate: {
                "previous": "Prev"
            },
            lengthMenu: "_MENU_ / Page",
        };
        o.columns = this.rowgroupCols.concat(this.extraCol, this.EbObject.Columns.$values);
        if (this.AllowSorting)
            o.order = [];
        else
            o.ordering = false;
        o.deferRender = true;
        //o.filter = true;
        //o.select = this.AllowSelect;
        //o.retrieve = true;
        o.keys = true;
        //this.filterValues = this.getFilterValues();
        //filterChanged = false;
        //if (!this.isTagged)
        //    this.compareFilterValues();
        //else
        //    filterChanged = true;
        //o.rowReorder = this.IsTree;
        if (this.MainData !== null && this.isPipped) {
            if (this.Source === "EbDataTable") {
                o.dom = "<'col-md-10 noPadding'><'col-md-2 noPadding'f>rt";
                dvcontainerObj.currentObj.data = this.MainData;
                o.ajax = function (data, callback, settings) {
                    setTimeout(function () {
                        callback({
                            draw: dvcontainerObj.currentObj.data.draw,
                            data: dvcontainerObj.currentObj.data.data,
                            recordsTotal: dvcontainerObj.currentObj.data.recordsTotal,
                            recordsFiltered: dvcontainerObj.currentObj.data.recordsFiltered,
                        });
                    }, 50);
                }
                o.data = this.receiveAjaxData(this.MainData);
            }
            else {
                if (this.Source === "Calendar" || this.Source === "PivotTable") {
                    o.dom = "<'col-md-12 noPadding display-none'><'col-md-12 info-search-cont'i>rt";
                    o.language.info = "_START_ - _END_ / _TOTAL_ Entries";
                }
                else {
                    o.dom = "<'col-md-12 noPadding display_none'>rt";
                }
                o.paging = false;
                o.data = this.receiveAjaxData(this.MainData);
            }
        }
        else {
            if (this.Source === "EbDataTable")
                o.dom = "<'pagination-wrapper'lip>rt";
            else
                o.dom = "<'pagination-wrapper'lip>rt";
            o.paging = this.EbObject.IsPaging;
            o.lengthChange = true;
            if (!this.EbObject.IsPaging) {
                if (this.IsTree || this.EbObject.IsDataFromApi || this.Source === "AppsToObjectTable") {
                    o.dom = "<'col-md-12 noPadding display-none'><'col-md-12 info-search-cont'i>rt";
                    o.language.info = "_START_ - _END_ / _TOTAL_ Entries";
                }
                else {
                    o.dom = "<'col-md-12 noPadding display-none'>rt";
                }
                o.paging = false;
                o.lengthChange = false;
            }
            if (this.login === "uc") {
                if (dvcontainerObj)
                    dvcontainerObj.currentObj.Pippedfrom = "";
                $("#Pipped").text("");
                this.isPipped = false;
            }

            try {
                let url = "../dv/getData";
                if (this.Source === "Bot") {
                    url = "../boti/getData";
                }
                o.ajax = {
                    //url: this.ssurl + '/ds/data/' + this.dsid,
                    url: url,
                    type: 'POST',
                    timeout: 180000,
                    data: this.ajaxData.bind(this),
                    dataSrc: this.receiveAjaxData.bind(this),
                    beforeSend: function () {
                    },
                    error: function () {
                        if (this.Source === "WebForm" || this.Source === "Bot" || this.Source === "DashBoard")
                            $("#" + this.tableId + "_processing").text("Timeout Expired..");
                        else
                            EbPopBox("show", { Message: "Timeout Expired..", Title: "Error" });
                        this.hideEbLoader();
                    }.bind(this)
                };
            }
            catch (Error) {
                alert(Error);
            }
        }
        o.fnRowCallback = this.rowCallBackFunc.bind(this);
        o.drawCallback = this.drawCallBackFunc.bind(this);
        o.initComplete = this.initCompleteFunc.bind(this);
        o.headerCallback = this.headerCallback.bind(this);
        //o.fnDblclickCallbackFunc = this.dblclickCallbackFunc.bind(this);
        return o;
    };

    this.generateLengthMenu = function () {
        var ia = [];
        for (var i = 0; i < 5; i++)
            ia[i] = (this.EbObject.PageLength * (i + 1));
        return JSON.parse("[ [{0},-1], [{0},\"All\"] ]".replace(/\{0\}/g, ia.join(',')));
    };

    this.ajaxData = function (dq) {
        if (!this.isSecondTime) {
            $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").hide();
            $("#" + this.tableId + "_wrapper .DTFC_LeftFootWrapper").hide();
            $("#" + this.tableId + "_wrapper .DTFC_RightFootWrapper").hide();
        }

        this.matchColumnSearchAndVisible();
        delete dq.columns; delete dq.order; delete dq.search;
        dq.RefId = this.EbObject.DataSourceRefId;
        dq.TFilters = this.columnSearch;
        if (this.filterValues.length === 0)
            this.filterValues = this.getFilterValues();
        if (this.EbObject.IsDataFromApi)
            this.ModifyRequestParams();
        else
            dq.Params = this.filterValues;

        dq.OrderBy = this.getOrderByInfo();
        if (this.columnSearch.length > 0) {
            this.filterFlag = true;
        }
        dq.Ispaging = this.EbObject.IsPaging;
        if (dq.length === -1)
            dq.length = this.totalcount;
        this.RemoveColumnRef();
        if (!this.Refid)
            dq.DataVizObjString = JSON.stringify(this.EbObject);
        if (this.CurrentRowGroup !== null)
            dq.CurrentRowGroup = JSON.stringify(this.CurrentRowGroup);
        dq.dvRefId = this.Refid;
        dq.TableId = this.tableId;
        dq.showCheckboxColumn = this.showCheckboxColumn;
        dq.counter = ++this.ajaxCallCounter;
        return dq;
    };

    this.ModifyRequestParams = function () {
        let xx = this.EbObject.Parameters.$values.map(function (row) {
            return { Name: row.Name, Value: row.Value, Type: row.Type };
        });

        this.EbObject.ParamsList.$values = this.filterValues.concat(xx);
    };

    this.getOrderByInfo = function () {
        var tempArray = [];
        if (this.CurrentRowGroup !== null) {
            if (this.CurrentRowGroup.RowGrouping.$values.length > 0) {
                for (let i = 0; i < this.CurrentRowGroup.RowGrouping.$values.length; i++)
                    tempArray.push(new order_obj(this.CurrentRowGroup.RowGrouping.$values[i].name, this.CurrentRowGroup.RowGrouping.$values[i].Direction));
            }
            if (this.orderColl.length > 0) {
                $.each(this.orderColl, function (i, obj) {
                    tempArray.push(obj);
                });
            }
            else {
                if (this.CurrentRowGroup.OrderBy.$values.length > 0) {
                    for (let i = 0; i < this.CurrentRowGroup.OrderBy.$values.length; i++)
                        tempArray.push(new order_obj(this.CurrentRowGroup.OrderBy.$values[i].name, this.CurrentRowGroup.OrderBy.$values[i].Direction));
                }
            }
        }

        if (tempArray.length === 0) {
            $.each(this.orderColl, function (i, obj) {
                tempArray.push(obj);
            });
            if (tempArray.length === 0) {
                $.each(this.EbObject.OrderBy.$values, function (i, obj) {
                    if (tempArray.filter(e => e.Column === obj.name).length === 0)
                        tempArray.push(new order_obj(obj.name, obj.Direction));
                });
            }
        }

        return tempArray;
    };

    this.getFilterValues = function (from) {
        //this.filterChanged = false;
        var fltr_collection = [];

        if (this.FD)
            fltr_collection = getValsForViz(this.FilterDialog.FormObj);
        if (this.Source === "Calendar")
            fltr_collection = getValsForViz(FilterDialog.FormObj);
        let temp = $.grep(fltr_collection, function (obj) { return obj.Name === "eb_loc_id"; });
        if (temp.length === 0) {
            if (this.Source === "Bot")
                fltr_collection.push(new fltr_obj(11, "eb_loc_id", 1)); // hard coding temp for bot
            else
                fltr_collection.push(new fltr_obj(11, "eb_loc_id", ebcontext.locations.CurrentLoc || 1));
        }
        temp = $.grep(fltr_collection, function (obj) { return obj.Name === "eb_currentuser_id"; });
        if (temp.length === 0)
            fltr_collection.push(new fltr_obj(11, "eb_currentuser_id", ebcontext.user.UserId));
        if (ebcontext.languages != undefined) {
            temp = $.grep(fltr_collection, function (obj) { return obj.Name === "eb_current_language_id"; });
            if (temp.length === 0)
                fltr_collection.push(new fltr_obj(11, "eb_current_language_id", ebcontext.languages.getCurrentLanguage()));

            temp = $.grep(fltr_collection, function (obj) { return obj.Name === "eb_current_locale"; });
            if (temp.length === 0)
                fltr_collection.push(new fltr_obj(16, "eb_current_locale", ebcontext.languages.getCurrentLocale()));
        }
        //if (this.isContextual && from !== "compare") {
        //    if (from === "filter" && prevfocusedId !== undefined) {
        //        $.each(dvcontainerObj.dvcol[prevfocusedId].filterValues, function (i, obj) {
        //            var f = false;
        //            $.each(fltr_collection, function (j, fObj) {
        //                if (fObj.Name === obj.Name)
        //                    f = true;
        //            });
        //            if (!f)
        //                fltr_collection.push(obj);
        //        });
        //    }
        //    else {
        //        if (this.rowData !== null && this.rowData !== "") {
        //            if (this.Api !== null) {
        //                if (prevfocusedId === undefined)
        //                    from = "link";
        //                $.each(this.rowData, this.rowObj2filter.bind(this, fltr_collection, from));
        //            }
        //        }
        //    }
        //}

        return fltr_collection;
    };

    this.rowObj2filter = function (fltr_collection, from, i, data) {
        if (i < this.EbObject.Columns.$values.length) {
            if (from === "link") {
                let type = this.EbObject.Columns.$values[i].Type;
                //if (type === 5 || type === 6)
                //    data = this.renderDateformat(data, "-");
                if (data !== "")
                    fltr_collection.push(new fltr_obj(type, this.EbObject.Columns.$values[i].name, data));
            }
            else {
                if (dvcontainerObj.dvcol[prevfocusedId].Api !== null) {
                    let type = dvcontainerObj.dvcol[prevfocusedId].EbObject.Columns.$values[i].Type;
                    fltr_collection.push(new fltr_obj(type, dvcontainerObj.dvcol[prevfocusedId].EbObject.Columns.$values[i].name, data));
                }
            }
        }
    };

    this.getFilterForLinkfromColumn = function () {
        this.linkfromcolumn = false;
        this.dvformMode = 1;
        let filters = [];
        var temp = this.EbObject.Columns.$values.filter(obj => obj.name === this.linkDVColumn)[0];
        filters.push(new fltr_obj(temp.IdColumn.Type, temp.IdColumn.name, this.rowData[temp.IdColumn.data]));
        if (this.Source === "Draft" || temp.IsFormDraftMode)
            this.dvformMode = 8;
        return filters;
    };

    this.getfilterFromRowdata = function () {
        var filters = [];
        if (parseInt(this.linkDV.split("-")[2]) !== EbObjectTypes.WebForm) {
            filters = this.FilterfromRow();
        }
        else {
            var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.LinkRefId === this.linkDV && obj.name === this.linkDVColumn; }.bind(this));
            this.dvformMode = temp[0].FormMode;
            if (temp[0].FormMode === 1) {
                var col = temp[0].FormId.$values;
                $.each(col, function (i, col) {
                    filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
                }.bind(this));
            }
            else if (temp[0].FormMode === 2) {
                var cols = temp[0].FormParameters.$values;
                $.each(cols, function (i, col) {
                    if (this.rowData[col.data] !== "")
                        filters.push(new fltr_obj(col.Type, col.FormControl.Name, this.rowData[col.data]));
                }.bind(this));
            }
        }
        return filters;
    };

    this.FilterfromRow = function () {
        var filters = [];
        $.each(this.EbObject.Columns.$values, function (i, col) {
            if (this.rowData[col.data] !== "")
                filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
        }.bind(this));
        return filters;
    };

    this.placefiltervalues = function () {
        //if (this.filterValues.length > 0) {
        //    $.each(this.filterValues, function (i, param) {
        //        $("#" + this.ContextId + ' #' + param.Name).val(param.Value);
        //    });
        //}
        $.each(getFlatControls(this.FilterDialog.FormObj), function (i, obj) {
            var mapobj = getObjByval(this.filterValues, "Name", obj.Name);
            if (typeof mapobj !== "undefined") {
                let val = mapobj.Value;
                obj.setValue(val);
            }
        }.bind(this));
    }

    this.filterDisplay = function () {
        var $controls = $("#" + this.ContextId + " #filterBox").children().not("[type=hidden],button");
        var filter = "";
        var filterdialog = [], columnFilter = [];
        if ($controls.length > 0) {
            $.each($controls, function (i, ctrl) {
                var o = new displayFilter();
                var ctype = $(ctrl).attr("ctype");
                o.name = $($(ctrl).children()[0]).text();
                o.title = $($(ctrl).children()[0]).text();
                o.operator = "=";
                if (ctype === "PowerSelect")
                    o.value = $(ctrl).find("input").attr("display-members");
                else if (ctype === "Date")
                    o.value = $(ctrl).find("input").val();
                else if (ctype === "RadioGroup")
                    o.value = $(ctrl).children().find("[type=radio]:checked").val();
                else if (ctype === "SimpleSelect")
                    o.value = $(ctrl).children().find("option:selected").text();
                else if (ctype === "UserLocation") {
                    let $sel = $(ctrl).find('select');
                    let allsld = $sel.next('div').find('[value=multiselect-all').prop('checked');
                    if (allsld && $sel.attr('isglobal') === 'y')
                        o.value = "Global";
                    else if (allsld)
                        o.value = "Selected all";
                    else
                        o.value = $(ctrl).find('ul').find(".active:not(.multiselect-all)").text().trim().split(" ").join(",");
                }
                else
                    o.value = $($(ctrl).children()[1]).val();

                if (typeof $controls[i + 1] !== "undefined")
                    o.logicOp = "AND";
                else
                    o.logicOp = "";
                if (o.value !== undefined && o.value !== null && o.value !== "")
                    filterdialog.push(o);
            });
        }

        if (this.columnSearch.length > 0) {
            for (i = 0; i < this.columnSearch.length; i++) {
                //$.each(this.columnSearch, function (i, search) {
                search = this.columnSearch[i];
                var o = new displayFilter();
                let colObj = getObjByval(this.EbObject.Columns.$values, "name", search.Column);
                o.title = colObj.sTitle;
                o.name = colObj.name;
                o.operator = search.Operator;
                var searchobj = $.grep(this.columnSearch, function (ob) { return ob.Column === search.Column; });
                if (searchobj.length === 1) {
                    if (search.Value.toString().includes("|")) {
                        $.each(search.Value.split("|"), function (j, val) {
                            if (val.trim() !== "") {
                                var o = new displayFilter();
                                o.title = colObj.sTitle;
                                o.name = colObj.name;
                                o.operator = search.Operator;
                                o.value = val;
                                if (typeof search.Value.split("|")[j + 1] !== "undefined" && search.Value.split("|")[j + 1].trim() !== "")
                                    o.logicOp = "OR";
                                else if (typeof this.columnSearch[i + 1] !== "undefined")
                                    o.logicOp = "AND";
                                else
                                    o.logicOp = "";
                                columnFilter.push(o);
                            }
                        }.bind(this));
                    }
                    else {
                        o.value = search.Value;
                        if (typeof this.columnSearch[i + 1] !== "undefined")
                            o.logicOp = "AND";
                        else
                            o.logicOp = "";
                        columnFilter.push(o);
                    }
                }
                else {
                    i++;
                    o.value = searchobj[0].Value + " AND " + searchobj[1].Value;
                    o.operator = "BETWEEN";
                    if (typeof this.columnSearch[i + 1] !== "undefined")
                        o.logicOp = "AND";
                    else
                        o.logicOp = "";
                    columnFilter.push(o);
                }
            }
        }
        this.Tags = new EbTags({ "displayFilterDialogArr": filterdialog, "displayColumnSearchArr": columnFilter, "id": "#filterdisplayrowtd_" + this.tableId + "", "remove": this.closeTag });
        //this.Tags = new EbTags({ "displayFilterDialogArr": $controls, "displayColumnSearchArr": this.columnSearch, "id": "#filter_Display", "remove": this.closeTag });
    };

    this.closeTag = function (e, obj) {
        var searchObj = $.grep(this.columnSearch, function (ob) { return ob.Column.toLowerCase() === obj.name.toLowerCase(); });
        var index = this.columnSearch.findIndex(x => x.Column.toLowerCase() === obj.name.toLowerCase());
        if (searchObj.length === 1) {
            if (searchObj[0].Value.includes("|")) {
                var val = "";
                if (this.columnSearch[index].Value.includes(obj.value + "|"))
                    val = this.columnSearch[index].Value.replace(obj.value + "|", "");
                else
                    val = this.columnSearch[index].Value.replace("|" + obj.value, "");
                if (val.trim() !== "")
                    this.columnSearch[index].Value = val;
                else
                    this.columnSearch.splice(index, 1);
            }
            else
                this.columnSearch.splice(index, 1);
        }
        else
            this.columnSearch.splice(index, 2);
        this.Api.ajax.reload();
    }.bind(this);

    this.matchColumnSearchAndVisible = function () {

    }

    this.getfilter = function (fltr_collection, i, data) {
        fltr_collection.push(new fltr_obj(data.Type, data.name, this.rowData[i]));
    };

    this.receiveAjaxData = function (dd) {
        if (dd.responseStatus) {
            if (dd.responseStatus.message !== null) {
                console.log("Table View PreProcessing Error " + dd.responseStatus.message);
                if (this.Source === "WebForm" || this.Source === "Bot" || this.Source === "DashBoard")
                    $("#" + this.tableId + "_processing").text("Something went wrong..");
                else
                    EbPopBox("show", { Message: "Table View PreProcessing Error Occured...", Title: "Error" });
            }
        }
        if (dd.counter && this.ajaxCallCounter != dd.counter && this.MainData) {
            console.warn(`Mismatch in counter value: ${this.ajaxCallCounter}, ${dd.counter}`);
            dd = this.MainData;
        }
        if (!this.isSecondTime)
            this.totalcount = dd.recordsFiltered;
        this.isRun = true;
        if (this.login === "uc" && this.Source === "EbDataTable") {
            dvcontainerObj.currentObj.data = dd;
        }
        this.MainData = dd;
        this.RowCount = dd.recordsFiltered;
        //return dd.data;
        this.unformatedData = dd.data;
        this.Levels = dd.levels;
        this.permission = dd.permission;
        this.summary = dd.summary;
        this.tableName = dd.tableName;
        this.treeData = dd.tree;
        this.SetColumnRef();
        this.ImageArray = dd.imageList ? JSON.parse(dd.imageList) : [];
        return dd.formattedData || this.unformatedData;
    };

    this.fixedColumnCount = function () {
        var count = this.EbObject.LeftFixedColumn;
        var visCount = 0;
        if (count > 1) {
            $.each(this.EbObject.Columns.$values, function (i, col) {
                if (!col.bVisible) {
                    if (this.EbObject.LeftFixedColumn > visCount)
                        count++;
                    else
                        return false;
                }
                else
                    visCount++;
            }.bind(this));
        }
        if (this.extraCol.length === 2)
            return count + 1;
        else
            return count;
    };

    this.ColumnsComparer = function (a, b) {
        if (a.data < b.data) return -1;
        if (a.data > b.data) return 1;
        if (a.data === b.data) return 0;
    };

    this.getAgginfo = function () {
        var _ls = [];
        $.each(this.EbObject.Columns.$values, this.getAgginfo_inner.bind(this, _ls));
        return _ls;
    };

    this.getAgginfo_inner = function (_ls, i, col) {
        if (col.bVisible && (col.RenderType == parseInt(gettypefromString("Int32")) || col.RenderType == parseInt(gettypefromString("Decimal")) || col.RenderType == parseInt(gettypefromString("Int64"))
            || col.RenderType == parseInt(gettypefromString("Double")) || col.RenderType == parseInt(gettypefromString("Numeric"))) && col.name !== "serial") {
            _ls.push(new Agginfo(col.name, this.EbObject.Columns.$values[i].DecimalPlaces, col.data));
            this.NumericIndex.push(col.data);
        }
    };

    this.getFooterFromSettingsTbl = function () {
        var ftr_part = "";
        $.each(this.rowgroupCols, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        $.each(this.extraCol, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        $.each(this.EbObject.Columns.$values, function (i, col) {
            if (col.bVisible)
                ftr_part += "<th data-col='" + col.name + "'></th>";
            else
                ftr_part += "<th style=\"display:none;\"></th>";
        });
        return "<tfoot>" + ftr_part + "</tfoot>";
    };

    this.repopulate_filter_arr = function () {
        var table = this.tableId;
        var filter_obj_arr = [];
        var api = this.Api;
        if (api !== null) {
            this.Api.columns().every(function (i) {
                let colobj = api.settings().init().aoColumns[i];
                let paracolum = colobj.name;
                if (colobj.$type && colobj.$type.indexOf("DVPhoneColumn") !== -1)
                    paracolum = colobj.MappingColumn.name;

                if (paracolum !== 'checkbox' && paracolum !== 'serial' && colobj.bVisible) {
                    var oper;
                    var val1, val2;
                    var textid = '#' + table + '_' + colobj.name + '_hdr_txt1';
                    //var type = $(textid).attr('data-coltyp');
                    var type = colobj.Type;
                    var Rtype = colobj.RenderType;
                    if (Rtype === 3) {
                        var obj = this.EbObject.Columns.$values.find(x => x.name === paracolum);
                        val1 = ($(textid).is(':checked')) ? obj.TrueValue : obj.FalseValue;
                        if (!($(textid).is(':indeterminate')))
                            filter_obj_arr.push(new filter_obj(paracolum, "=", val1, type));
                    }
                    else {
                        oper = $('#' + table + '_' + colobj.name + '_hdr_sel').text().trim();
                        if (api.columns(i).visible()[0]) {
                            if (oper !== '' && $(textid).val() !== '') {
                                val1 = $(textid).val();
                                if (oper === 'B')
                                    val2 = $(textid).siblings('input').val();
                                if (Rtype === 5 || Rtype === 6) {
                                    if (!val1 || !moment(val1, 'DD-MM-YYYY', true).isValid())
                                        return;
                                    if (oper === 'B' && (!val2 || !moment(val2, 'DD-MM-YYYY', true).isValid()))
                                        return;
                                }

                                if (oper === 'B') {
                                    if (oper === 'B' && val1 !== '' && val2 !== '') {
                                        if (Rtype === 8 || Rtype === 7 || Rtype === 11 || Rtype === 12) {
                                            filter_obj_arr.push(new filter_obj(paracolum, ">=", Math.min(val1, val2)));
                                            filter_obj_arr.push(new filter_obj(paracolum, "<=", Math.max(val1, val2), type));
                                        }
                                        else if (Rtype === 5 || Rtype === 6) {
                                            let d1 = Date.parse(moment(val1, 'DD-MM-YYYY').format('YYYY-MM-DD'));
                                            let d2 = Date.parse(moment(val2, 'DD-MM-YYYY').format('YYYY-MM-DD'));
                                            if (d2 > d1) {
                                                filter_obj_arr.push(new filter_obj(paracolum, ">=", val1, type));
                                                filter_obj_arr.push(new filter_obj(paracolum, "<=", val2, type));
                                            }
                                            else {
                                                filter_obj_arr.push(new filter_obj(paracolum, ">=", val2, type));
                                                filter_obj_arr.push(new filter_obj(paracolum, "<=", val1, type));
                                            }
                                        }
                                    }
                                }
                                else {
                                    var data = $(textid).val();
                                    filter_obj_arr.push(new filter_obj(paracolum, oper, data, type));
                                }
                            }
                        }
                    }
                }
            }.bind(this));
        }
        return filter_obj_arr;
    };

    this.rowCallBackFunc = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        this.colorRow(nRow, aData, iDisplayIndex, iDisplayIndexFull);
        if (this.treeColumn) {
            let elem = aData[this.treeColumn.data].split("&nbsp;").join("").split("&emsp;").join("");
            let treeElem = $(elem);
            $(nRow).attr("data-lvl", treeElem.attr("data-level"));
            if (treeElem.hasClass("groupform")) {
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).addClass("groupform");
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).children().removeClass("groupform");
            }
            else {
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).addClass("itemform");
                $(nRow).children(`td:eq(${this.treeColumnIndex})`).children().removeClass("itemform");
            }
        }
    };

    this.initCompleteFunc = function (settings, json) {
        this.Run = false;
        if (this.Source === "EbDataTable" || this.Source === "locationTree" || this.Source === "WebForm" || this.Source === "popup" || this.Source === "PivotTable")
            this.GenerateButtons();

        else if (this.Source === "Calendar") {
            this.CreateContextmenu4ObjectSelector();
        }
        if (this.login === "uc") {
            this.initCompleteflag = true;
            //if (this.isSecondTime) { }
            //this.ModifyingDVs(dvcontainerObj.currentObj.Name, "initComplete");            
        }
        setTimeout(function () {
            $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").show();
            $("#" + this.tableId + "_wrapper .DTFC_LeftFootWrapper").show();
            $("#" + this.tableId + "_wrapper .DTFC_RightFootWrapper").show();
            $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").style("padding-top", "100px", "important");
            $("#" + this.tableId + "_wrapper .dataTables_scrollFoot").style("margin-top", "-100px", "important");
            if (!this.IsTree && this.showFilterRow && !this.EbObject.IsDataFromApi) {

                this.createFilterRowHeader();
            }
            else if (this.IsTree || this.Source === "Calendar" || this.EbObject.IsDataFromApi || this.Source === "AppsToObjectTable")
                this.createFilterforTree();
            //if (this.EbObject.AllowLocalSearch)
            //    this.createFilterforTree();
            this.filterDisplay();
            this.createFooter();
            if (this.Source === "EbDataTable" || this.Source === "PivotTable")
                this.arrangeWindowHeight();

            this.CreateHeaderTooltip();
            this.addFilterEventListeners();
            this.arrangeFooterWidth();
            if (this.Source !== "Calendar" || this.EbObject.IsDataFromApi)
                this.placeFilterInText();

            this.hideEbLoader();
            if (this.login === "uc") {
                if (!this.EbObject.DisableCopy)
                    $("#" + focusedId + " .wrapper-cont").removeClass("userselect").addClass("userselect");
                else
                    $("#" + focusedId + " .wrapper-cont").removeClass("userselect");
            }
            else {
                if (!this.EbObject.DisableCopy)
                    $(".wrapper-cont").removeClass("userselect").addClass("userselect");
                else
                    $(" .wrapper-cont").removeClass("userselect");
            }
            this.isSecondTime = true;

            if (this.Source !== "EbDataTable" && this.Source !== "datagrid" && this.Source !== "WebForm" && this.Source !== "AppsToObjectTable" && this.Source !== "Calendar") {
                $('#' + this.tableId + '_wrapper .dataTables_scrollFoot').hide();
                $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper').hide();
                $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper').hide();
                if ($("#" + this.tableId + " tr").length > 7) {
                    $(".containerrow #" + this.tableId + "_wrapper .dataTables_scroll").style("height", "210px", "important");
                    $(".containerrow #" + this.tableId + "_wrapper .dataTables_scrollBody").style("height", "173px", "important");
                }
                $("#" + this.tableId + "_wrapper .DTFC_ScrollWrapper .DTFC_RightBodyWrapper tr").css("height", this.EbObject.RowHeight + "px");
                $("#" + this.tableId + "_wrapper .DTFC_ScrollWrapper .DTFC_LeftBodyWrapper tr").css("height", this.EbObject.RowHeight + "px");
                $("#" + this.tableId + "_wrapper .dataTables_scroll .dataTables_scrollBody tr").css("height", this.EbObject.RowHeight + "px");
            }
            if (Option.initCompleteCallback)
                Option.initCompleteCallback();
            this.Api.columns.adjust();
        }.bind(this), 0);
    };

    this.contextMenu = function () {
        $.contextMenu({
            selector: ".tablelink",
            items: {
                "OpenNewTab": { name: "Open in New Tab", icon: "fa-external-link-square", callback: this.OpeninNewTab.bind(this) }
            }
        });
    };

    this.contextMenu4Label = function () {
        $.contextMenu({
            selector: ".labeldata",
            items: {
                "Copy": { name: "Copy", icon: "fa-external-link-square", callback: this.copyLabelData.bind(this) }
            }
        });
    };

    this.contextMenu4Cell = function () {
        var isDisable = this.EbObject.DisableCopy;
        $.contextMenu('destroy', ".tdheight");
        $.contextMenu({
            selector: ".tdheight",
            items: {
                "Copy": {
                    name: "Copy", icon: "fa-external-link-square", callback: this.copyCellData.bind(this),
                    disabled: function (key, opt) {
                        return isDisable;
                    }
                }
            }
        });

        $('.tdheight').on('contextmenu', function (e) {
            alert(1);
            e.preventDefault();
            return false;
        });
    };

    this.copyCellData = function (key, opt, event) {

    };

    this.OpeninNewTab = function (key, opt, event) {
        var cData = opt;
        this.isContextual = true;
        var idx;
        if (event !== undefined) {
            idx = this.Api.row(opt.$trigger.parent().parent()).index();
            cData = opt.$trigger.text();
        }
        else
            idx = key;

        var splitarray = this.linkDV.split("-");
        if (splitarray[2] === "3") {
            var url = "../ReportRender/BeforeRender?refid=" + this.linkDV;
            var copycelldata = cData.replace(/[^a-zA-Z ]/g, "").replace(/ /g, "_");
            if ($(`#RptModal${copycelldata}`).length !== 0)
                $(`#RptModal${copycelldata}`).remove();
            $("body").append(`<div class="modal fade RptModal" id="RptModal${copycelldata}" role="dialog">
                <div class="modal-dialog modal-sm">
                    <div class="modal-content">
                        <div class="modal-header">
                            <button type="button" class="close" data-dismiss="modal">&times;</button>                              
                        </div>
                        <div class="modal-body"> <iframe id="reportIframe${copycelldata}" class="reportIframe" src='../ReportRender/Renderlink?refid=${this.linkDV}&_params=${btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))))}'></iframe>
            </div>
                    </div>
                </div>
            </div>
            `);
            $(`#RptModal${copycelldata}`).modal();
            $(`#reportIframe${copycelldata}`).css("height", "80vh");
            //else {
            //    $(`#RptModal${copycelldata}`).modal();
            //    $.LoadingOverlay("hide");
            //}
        }
        else if (splitarray[2] === "0") {
            this.WebFormlink(this.linkDV, btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))), this.dvformMode);
        }
        else if (splitarray[2] === "22") {
            this.tabNum++;
            let url = "../DashBoard/DashBoardView?refid=" + this.linkDV;

            let _form = document.createElement("form");
            _form.setAttribute("method", "post");
            _form.setAttribute("action", url);
            _form.setAttribute("target", "_blank");

            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = "rowData";

            input.value = btoa(unescape(encodeURIComponent(JSON.stringify(this.rowData))));
            _form.appendChild(input);

            let input1 = document.createElement('input');
            input1.type = 'hidden';
            input1.name = "filterValues";
            input1.value = btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))));
            _form.appendChild(input1);

            let input2 = document.createElement('input');
            input2.type = 'hidden';
            input2.name = "tabNum";
            input2.value = this.tabNum;
            _form.appendChild(input2);

            document.body.appendChild(_form);

            //note I am using a post.htm page since I did not want to make double request to the page 
            //it might have some Page_Load call which might screw things up.
            //window.open("post.htm", name, windowoption);       
            _form.submit();
            document.body.removeChild(_form);


        }
        else {
            this.tabNum++;
            let url = "../DV/dv?refid=" + this.linkDV;

            let _form = document.createElement("form");
            _form.setAttribute("method", "post");
            _form.setAttribute("action", url);
            _form.setAttribute("target", "_blank");

            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = "rowData";

            input.value = btoa(unescape(encodeURIComponent(JSON.stringify(this.rowData))));
            _form.appendChild(input);

            let input1 = document.createElement('input');
            input1.type = 'hidden';
            input1.name = "filterValues";
            input1.value = btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))));
            _form.appendChild(input1);

            let input2 = document.createElement('input');
            input2.type = 'hidden';
            input2.name = "tabNum";
            input2.value = this.tabNum;
            _form.appendChild(input2);

            document.body.appendChild(_form);

            //note I am using a post.htm page since I did not want to make double request to the page 
            //it might have some Page_Load call which might screw things up.
            //window.open("post.htm", name, windowoption);       
            _form.submit();
            document.body.removeChild(_form);
        }
    };

    this.WebFormlink = function (_refid, _filter, _mode) {
        let _locale = ebcontext.languages.getCurrentLocale();
        let url = `../WebForm/Index?_r=${_refid}&_p=${_filter}&_m=${_mode}&_l=${ebcontext.locations.CurrentLoc}&_lo=${_locale}`;
        window.open(url, '_blank');

        //var _form = document.createElement("form");
        //_form.setAttribute("method", "get");
        //_form.setAttribute("action", url);
        //_form.setAttribute("target", "_blank");

        //var input = document.createElement('input');
        //input.type = 'hidden';
        //input.name = "_r";
        //input.value = _refid;
        //_form.appendChild(input);

        //input = document.createElement('input');
        //input.type = 'hidden';
        //input.name = "_p";
        //input.value = _filter;
        //_form.appendChild(input);

        //input = document.createElement('input');
        //input.type = 'hidden';
        //input.name = "_m";
        //input.value = _mode;
        //_form.appendChild(input);

        //input = document.createElement('input');
        //input.type = 'hidden';
        //input.name = "_l";
        //input.value = ebcontext.locations.CurrentLoc;
        //_form.appendChild(input);

        //document.body.appendChild(_form);
        //_form.submit();
        //document.body.removeChild(_form);
    };

    this.arrangeFooterWidth = function () {
        var lfoot = $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper table');
        var rfoot = $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper table');
        var scrollfoot = $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner table');

        if (this.EbObject.LeftFixedColumn > 0 || this.EbObject.RightFixedColumn > 0) {
            if (this.EbObject.LeftFixedColumn > 0) {
                for (let j = 0; j < this.EbObject.LeftFixedColumn; j++) {
                    $(lfoot).children().find("tr").eq(0).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(0).children("th").eq(j).css("width"));
                }
            }

            if (this.EbObject.RightFixedColumn > 0) {
                var start = scrollfoot.find("tr").eq(0).children().length - this.EbObject.RightFixedColumn;
                for (let j = 0; (j + start) < scrollfoot.find("tr").eq(0).children().length; j++) {
                    $(rfoot).children().find("tr").eq(0).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(0).children("th").eq(j + start).css("width"));
                }
            }
        }

        $("#" + this.tableId + " thead tr:eq(1) .eb_finput").parent().remove();
    };

    this.arrangefixedHedaerWidth = function () {
        var lhead = $('#' + this.tableId + '_wrapper .DTFC_LeftHeadWrapper table');
        var rhead = $('#' + this.tableId + '_wrapper .DTFC_RightHeadWrapper table');
        var lbody = $('#' + this.tableId + '_wrapper .DTFC_LeftBodyLiner table');

        if (this.EbObject.LeftFixedColumn > 0 || this.EbObject.RightFixedColumn.length > 0) {
            if (this.EbObject.LeftFixedColumn > 0) {
                for (let j = 0; j < this.EbObject.LeftFixedColumn; j++) {
                    $(lhead).children().find("tr").eq(0).children("th").eq(j).css("width", lbody.find("tbody").children("tr").eq(0).children("td").eq(j).css("width"));
                }
            }

            if (this.EbObject.RightFixedColumn > 0) {
                var start = lbody.find("tr").eq(0).children().length - this.EbObject.RightFixedColumn;
                for (var j = 0; (j + start) < lbody.find("tr").eq(0).children().length; j++) {
                    $(rhead).children().find("tr").eq(0).children("th").eq(j).css("width", lbody.find("tbody").children("tr").eq(0).children("td").eq(j + start).css("width"));
                }
            }
        }


        $("#" + this.tableId + " thead tr:eq(1) .eb_finput").parent().remove();
    };

    this.placeFilterInText = function () {
        if (this.columnSearch.length > 0) {
            if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-filter"))
                $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-filter").addClass("fa-times");
        }
        else {
            if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-times"))
                $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-times").addClass("fa-filter");
        }
        $('.' + this.tableId + '_htext').val("");
        for (let i = 0; i < this.columnSearch.length; i++) {
            let param1 = this.columnSearch[i];
            let param2 = this.columnSearch[i + 1];
            var colum = param1.Column;
            let phonecolumns = this.EbObject.Columns.$values.filter(obj => obj.$type.indexOf("DVPhoneColumn") !== -1);
            phonecolumns.forEach(function (obj) {
                if (obj.MappingColumn.name === colum) {
                    colum = obj.name;
                    return false;
                }
            });
            let textid = '#' + this.tableId + '_' + colum + '_hdr_txt1';
            let type = $(textid).attr('data-coltyp');
            if (type === 'boolean') {
                if (param1.Value === "true")
                    $(textid).attr("checked", true);
                else if (param1.Value === "false")
                    $(textid).attr("checked", false);
                else
                    $(textid).attr("indeterminate", true);
            }
            else {
                if (param1.Operator !== '' && param1.Value !== '') {
                    if (param2 && param2.Column === param1.Column) {
                        $(textid).val(param1.Value);
                        $(".eb_fsel" + this.tableId + "[data-colum=" + colum + "]").trigger("click");
                        $(textid).siblings('input').val(param2.Value);
                        i++;
                    }
                    else {
                        $(textid).val(param1.Value);
                        $('#' + this.tableId + '_' + colum + '_hdr_sel').text(param1.Operator);
                    }
                }
            }
        }
    };

    this.CreateHeaderTooltip = function () {
        this.visColumn = this.EbObject.Columns.$values.filter(col => col.bVisible);
        $.each($('#' + this.tableId + '_wrapper .dataTables_scrollHead th.tdheight'), this.AddHeaderTooltip.bind(this));
        this.DrawTooltipForHeader();
    };

    this.AddHeaderTooltip = function (i, _th) {
        let hCol = this.visColumn[i];
        $(_th).attr("title", hCol.HeaderTooltipText || "");
    };

    this.DrawTooltipForHeader = function () {
        $('th.tdheight').tooltip({
            placement: 'bottom',
            container: 'body',
            html: true
        });
    };


    this.check4Scroll = function () {
        var scrollBody = $('#' + this.tableId + '_wrapper .dataTables_scrollBody');
        if (scrollBody[0].scrollHeight > scrollBody.height()) {
            scrollBody.children().css("width", "110%");
            scrollBody.siblings(".dataTables_scrollFoot").style("width", "98.65%", "important");
        }
        else {
            scrollBody.children().css("width", "100%");
            scrollBody.siblings(".dataTables_scrollFoot").style("width", "100%", "important");
        }

    };

    this.arrangeWindowHeight = function () {
        var filterId = "#filterdisplayrowtd_" + this.tableId;
        if (this.login === "uc") {
            if (this.IsTree || this.Source === "Calendar" || this.EbObject.IsDataFromApi) {
                $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 52px)", "important");
            }
            else if ($(filterId).children().length === 0 && !this.EbObject.IsPaging && !this.EbObject.AllowMultilineHeader)
                $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 25px)", "important");
            else {
                if ($(filterId).children().length === 0 && !this.EbObject.IsPaging && this.EbObject.AllowMultilineHeader) {//multilineonly
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 59px)", "important");
                }
                else if ($(filterId).children().length === 0 && this.EbObject.IsPaging && !this.EbObject.AllowMultilineHeader) {//pagingonly
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 68px)", "important");
                }
                else if ($(filterId).children().length !== 0 && !this.EbObject.IsPaging && !this.EbObject.AllowMultilineHeader) {//filteronly
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 66px)", "important");
                }
                else if ($(filterId).children().length === 0 && this.EbObject.IsPaging && this.EbObject.AllowMultilineHeader) {//paging & multiline
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 84px)", "important");
                }
                else if ($(filterId).children().length !== 0 && !this.EbObject.IsPaging && this.EbObject.AllowMultilineHeader) {//filter & multiline
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 82px)", "important");
                }
                else if ($(filterId).children().length !== 0 && this.EbObject.IsPaging && !this.EbObject.AllowMultilineHeader) {//filetr & paging
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 92px)", "important");
                }
                else {
                    $("#" + focusedId + " .dataTables_scroll").style("height", "calc(100vh - 107px)", "important");//filter && paging & multiline
                }
            }
            //this.stickBtn.$stickBtn.css("top", "46px");
        }
        else {
            $(".dv-body2").style("height", "calc( 100vh - 38px )", "important");
            if (this.tabNum !== 0) {
                $("#sub_window_" + this.tableId).style("height", "calc(100vh - 40px)", "important");
                if ($(filterId).children().length === 0 && !this.EbObject.IsPaging)
                    $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 40px)", "important");
                else {
                    if ($(filterId).children().length === 0)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 55px)", "important");
                    else if (!this.EbObject.IsPaging)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 58px)", "important");
                    else
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 90px)", "important");
                }
            }
            else {
                if (this.IsTree || this.Source === "Calendar" || this.EbObject.IsDataFromApi)
                    $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 32px)", "important");
                else if ($(filterId).children().length === 0 && !this.EbObject.IsPaging)
                    $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 42px)", "important");
                else {
                    if ($(filterId).children().length === 0)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 68px)", "important");
                    else if (!this.EbObject.IsPaging)
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 65px)", "important");
                    else
                        $("#sub_window_" + this.tableId + " .dataTables_scroll").style("height", "calc(100vh - 93px)", "important");
                }
            }
        }
    }

    this.copyLabelData = function (key, opt, event) {

    }

    this.ModifyingDVs = function (parentName, source) {
        $.each(dvcontainerObj.dvcol, function (key, obj) {
            if (parentName === obj.EbObject.Pippedfrom) {
                if (obj.EbObject.$type.indexOf("EbChartVisualization") !== -1 || obj.EbObject.$type.indexOf("EbGoogleMap") !== -1) {
                    dvcontainerObj.dvcol[key].EbObject.data = dvcontainerObj.currentObj.data;
                    dvcontainerObj.dvcol[key].drawGraphHelper(this.Api.data());
                    this.ModifyingDVs(dvcontainerObj.dvcol[key].EbObject.Name, "draw");
                }
                else {
                    if (source === "draw") {
                        dvcontainerObj.dvcol[key].modifyDVFlag = true;
                        dvcontainerObj.dvcol[key].Api.clear().rows.add(this.Api.data());
                        dvcontainerObj.dvcol[key].EbObject.data = dvcontainerObj.currentObj.data;
                        dvcontainerObj.dvcol[key].Api.columns.adjust().draw();
                        this.ModifyingDVs(dvcontainerObj.dvcol[key].EbObject.Name, "draw");
                    }
                }
            }
        }.bind(this));
    }

    this.drawCallBackFunc = function (settings) {
        if (this.Source === "EbDataTable") {
            //this.propGrid.setObject(this.EbObject, AllMetas["EbTableVisualization"]);
            if (this.ImageArray.length > 0) {
                $("#test12").remove();
                $("body").append("<div id='test12'></div>");
                this.FileViewer = $("#test12").ebFileViewer(this.ImageArray);
            }
        }
        $('tbody [data-toggle=toggle]').bootstrapToggle();
        if (this.EbObject.RowGroupCollection.$values.length > 0)
            this.doRowgrouping();
        if (this.login === "uc" && !this.modifyDVFlag && this.initCompleteflag) {
            //this.ModifyingDVs(dvcontainerObj.currentObj.Name, "draw");
        }
        if (this.isSecondTime) {
            //if (this.columnSearch.length > 0)
            this.filterDisplay();
            this.addFilterEventListeners();
            if (this.Source !== "Calendar" || this.EbObject.IsDataFromApi)
                this.placeFilterInText();
            //this.arrangefixedHedaerWidth();
            this.summarize2();
            if (this.Source === "EbDataTable" || this.Source === "PivotTable")
                this.arrangeWindowHeight();
        }
        $("#" + this.tableId + " .tdheight").css("height", this.EbObject.RowHeight + "px");
        if (Option.drawCallBack)
            Option.drawCallBack();
        if (this.Api === null)
            this.Api = $("#" + this.tableId).DataTable();
        this.Api.columns.adjust();
    };

    this.headerCallback = function (thead, data, start, end, display) {
        //$(thead).find('th').eq(0).html('Displaying ' + (end - start) + ' records');
    };

    this.selectCallbackFunc = function (e, dt, type, indexes) {
    };

    this.DTKeyFocusCallback = function (e, datatable, cell, originalEvent) {
        datatable.rows().deselect();
        let trindex = cell.index().row;
        datatable.row(trindex).select();
        if (Option.keyFocusCallbackFn)
            Option.keyFocusCallbackFn(e, datatable, cell, originalEvent);
    };

    this.clickCallbackFunc = function (e) {
    };

    this.dblclickCallbackFunc = function (e) {
        if (Option.fnDblclickCallback)
            Option.fnDblclickCallback(e);
    };

    this.DTclickTDCallbackFunc = function (e) {
        if (Option.fnClickTdCallback)
            Option.fnClickTdCallback(e);
    };

    this.rowclick = function (e, dt, type, indexes) {
        if (Option.rowclick)
            Option.rowclick(e, dt, type, indexes);
    };

    this.mouseenter = function (e, dt, type, indexes) {
        let trindex = $(e.target).closest("tr").index();
        let bgcolor = $(e.target).closest("tr").css("background-color");
        $(".DTFC_LeftBodyLiner tbody tr").eq(trindex).style("background-color", bgcolor, "important");
        $(".DTFC_RightBodyLiner tbody tr").eq(trindex).style("background-color", bgcolor, "important");
    };

    this.rowGroupHandler = function (e) {
        this.MainData = null;
        this.orderColl = [];
        let name = $(e.target).val().trim();
        if (!(name === "None")) {
            this.EbObject.DisableRowGrouping = false;
            $.each(this.EbObject.RowGroupCollection.$values, function (i, obj) {
                if (obj.Name === name) {
                    this.CurrentRowGroup = jQuery.extend({}, obj);
                    this.getColumnsSuccess(e);
                }
            }.bind(this));
        }
        else {
            this.EbObject.DisableRowGrouping = true;
            this.getColumnsSuccess();
        }
    };

    this.visibilityCheck = function () {
        this.RGIndex = [];
        this.EbObject.LeftFixedColumn = 0;
        this.EbObject.RightFixedColumn = 0;
        this.rowgroupCols = [];
        let visibleChanges = false;
        $.each(this.CurrentRowGroup.RowGrouping.$values, function (i, rgobj) {
            this.RGIndex.push(rgobj.data);
            this.rowgroupCols.unshift(JSON.parse('{ "sWidth":"10px","searchable": false, "orderable": false, "bVisible":true, "data":null, "defaultContent": ""}'));
        }.bind(this));

        if (this.rowgroupCols.length > 0 && this.CurrentRowGroup.$type.indexOf("MultipleLevelRowGroup") !== -1)
            this.rowgroupCols.unshift(JSON.parse('{ "sWidth":"10px", "searchable": false, "orderable": false, "bVisible":true, "name":"AllGroup", "data":null, "defaultContent": ""}'));

        $.each(this.EbObject.Columns.$values, function (i, colobj) {
            visibleChanges = false;
            $.each(this.CurrentRowGroup.RowGrouping.$values, function (i, rgobj) {
                if (colobj.name === rgobj.name) {
                    colobj.bVisible = false;
                    visibleChanges = true;
                }
            }.bind(this));

            $.each(this.EbObject.NotVisibleColumns.$values, function (i, nonvis) {
                if (colobj.name === nonvis.name) {
                    colobj.bVisible = false;
                    visibleChanges = true;
                }
            }.bind(this));

            if (!visibleChanges)
                colobj.bVisible = true;
            if (colobj.name === "id")
                colobj.bVisible = false;
        }.bind(this));

    };

    this.doRowgrouping = function () {
        if (this.Api === null)
            this.Api = $("#" + this.tableId).DataTable();
        var rows = this.Api.rows().nodes();
        var count = this.Api.columns()[0].length;
        if (this.Source === "EbDataTable") {
            $(rows).eq(0).before(`<tr class='group-All' id='group-All_${this.tableId}'></tr>`);
            $(`#group-All_${this.tableId}`).append(`<td  colspan="${count}"><select id="rowgroupDD_${this.tableId}" class="rowgroupselect"></select></td>`);
            $.each(this.EbObject.RowGroupCollection.$values, function (i, obj) {
                if (obj.RowGrouping.$values.length > 0) {
                    $(`#rowgroupDD_${this.tableId}`).append(`<option value="${obj.Name.trim()}">${obj.DisplayName}</option>`);
                }
            }.bind(this));
            $(`#rowgroupDD_${this.tableId}`).append(`<option value="None">None</option>`);
            $(`#rowgroupDD_${this.tableId}`).off("change").on("change", this.rowGroupHandler.bind(this));
        }
        if (this.CurrentRowGroup !== null) {
            $(`#group-All_${this.tableId}`).prepend(`<td><i class='fa fa-minus-square-o' style='cursor:pointer;'></i></td>`);
            $(`#rowgroupDD_${this.tableId} [value=${this.CurrentRowGroup.Name.trim()}]`).attr("selected", "selected");

            rows = this.Api.rows().nodes();
            $.each(this.Levels, function (i, obj) {
                if (obj.insertionType !== "After")
                    $(rows).eq(obj.rowIndex).before(obj.html);
                else
                    $(rows).eq(obj.rowIndex).after(obj.html);
            });
            var ct = $("#" + this.tableId + " .group[group=1]").length;
            $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` Groups (${ct}) - `);
        }
        else {
            $(`#rowgroupDD_${this.tableId} [value=None`).attr("selected", "selected");
            $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` Groups `);
        }
        $("#" + this.tableId + " tbody").off("click", "tr.group td:not('.rowgroupheadercheckboxtd')").on("click", "tr.group td:not('.rowgroupheadercheckboxtd')", this.collapseGroup);
        $("#" + this.tableId + " tbody").off("click", "tr.group-All").on("click", "tr.group-All", this.collapseAllGroup);
        $("." + this.tableId + "_rowgroupheadercheckbox").off("change").on("change", this.ModifyRowgroupCheckbox.bind(this));
    };

    this.singlelevelRowgrouping = function () {
        var rows = this.Api.rows().nodes();
        var rowsdata = this.Api.rows().data();
        var index = this.RGIndex;
        var count = this.Api.columns()[0].length;
        var lastrow = -1;
        var last = null;
        var colobj = {};
        var groupString = "";
        var groupArray = [];
        this.rowgroupFilter = [];
        $.each(this.NumericIndex, function (k, num) {
            if (!(num in colobj)) {
                colobj[num] = new Array();
            }
        });

        $.each(this.unformatedData, function (i, _dataArray) {
            groupString = "";
            groupArray = []
            $.each(index, function (j, dt) {
                groupArray.push((_dataArray[dt].trim() === "") ? "(Blank)" : _dataArray[dt].trim());
                groupString += (_dataArray[dt].trim() === "") ? "(Blank)" : _dataArray[dt].trim();
                if (typeof index[j + 1] !== "undefined")
                    groupString += ",";
            }.bind(this));

            if (last !== groupString) {
                if (last === null || Object.keys(colobj).length === 0)
                    $(rows).eq(i).before(this.getGroupRowSingle(count, groupArray));
                else {
                    var rowstring = this.getSubRow(colobj, groupString, count);
                    $(rows).eq(i).before(rowstring);
                    $(rows).eq(i).before(this.getGroupRowSingle(count, groupArray));
                }
                last = groupString;
                $.each(colobj, function (key, val) {
                    colobj[key] = [];
                    colobj[key].push(_dataArray[key]);
                });
            }
            else {
                $.each(colobj, function (key, val) {
                    colobj[key].push(_dataArray[key]);
                });
            }
            lastrow = i;
        }.bind(this));

        if (Object.keys(colobj).length !== 0 && ($(rows).eq(lastrow).hasClass("odd") || $(rows).eq(lastrow).hasClass("even"))) {
            var rowstring = this.getSubRow(colobj, groupString, count);
            $(rows).eq(lastrow).after(rowstring);
        }

        var ct = $(".group[group=0]").length;
        $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(` All Groups (${ct}) - `);
        this.getRowsCount(count, "single");
    }

    this.getGroupRowSingle = function (count, groupArray) {
        var str = "<tr class='group' group='0'><td> &nbsp;</td>";
        var tempstr = "";
        $.each(this.RGIndex, function (j, dt) {
            var tempobj = $.grep(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (obj) { return dt === obj.data });
            var type = tempobj[0].Type;
            //if (type === 5 || type === 6) {
            //    groupArray[j] = this.renderDateformat(groupArray[j], "/");
            //}
            if (tempobj[0].LinkRefId !== null)
                tempstr += tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupArray[j]}'><a href="#" oncontextmenu="return false" class="tablelink" data-colindex="${tempobj[0].data}" data-link="${tempobj[0].LinkRefId}" tabindex="0">${groupArray[j]}</a></b>`;
            else
                tempstr += tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupArray[j]}'>${groupArray[j]}</b>`;

            if (typeof this.RGIndex[j + 1] !== "undefined")
                tempstr += ",";
        }.bind(this));

        //$.each(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (k, obj) {
        str += "<td><i class='fa fa-minus-square-o' style='cursor:pointer;'></i></td><td colspan=" + count + ">" + tempstr + "</td></tr>";
        //});
        return str;
    }.bind(this);

    this.getGroupRow = function (count, groupString, rowgroup, dt) {
        var str = "<tr class='group' group='" + rowgroup + "'>";
        for (var i = 0; i <= rowgroup; i++)
            str += "<td> &nbsp;</td>";

        var tempobj = $.grep(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (obj) { return dt === obj.data });
        var type = tempobj[0].Type;
        //if (type === 5 || type === 6) {
        //    groupArray[j] = this.renderDateformat(groupArray[j], "/");
        //}
        let tempstr = "";
        if (tempobj[0].LinkRefId !== null)
            tempstr = tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupString}'><a href="#" oncontextmenu="return false" class="tablelink" data-colindex="${tempobj[0].data}" data-link="${tempobj[0].LinkRefId}" tabindex="0">${groupString}</a></b>`;
        else
            tempstr = tempobj[0].sTitle + `: <b data-rowgroup="true" data-colname='${tempobj[0].name}' data-coltype='${tempobj[0].Type}' data-data='${groupString}'>${groupString}</b>`;
        str += "<td><i class='fa fa-minus-square-o' style='cursor:pointer;'></i></td><td colspan=" + count + ">" + tempstr + "</td></tr>";
        return str;
    }.bind(this);

    this.getSubRow = function (colobj, groupString, count, rowgroup) {
        var i = 0;
        rowgroup = (typeof rowgroup === "undefined") ? 0 : rowgroup;
        var str = "<tr class='group-sum' group='" + rowgroup + "'>";
        $.each(this.rowgroupCols, function (k, obj) {
            str += "<td>&nbsp;</td>";
        });
        $.each(this.extraCol, function (k, obj) {
            if (obj.bVisible)
                str += "<td>&nbsp;</td>";
        });
        $.each(this.EbObject.Columns.$values, function (k, obj) {
            if (obj.bVisible) {
                if (Object.keys(colobj).contains(k.toString()) && obj.Aggregate) {
                    var val = colobj[k];
                    if (val.length === 1)
                        val.push("0");
                    str += "<td class='dt-body-right'>" + getSum(val).toFixed(obj.DecimalPlaces) + "</td>";// + "," + getAverage(val).toFixed(2)+
                }
                else
                    str += "<td>&nbsp;</td>";
            }
        });
        return str + "</tr>";
    };

    this.collapseAllGroup = function (e) {
        if (!$(e.target).is("select")) {
            var $elems = $(e.target).parents().closest(".group-All").nextAll("[role=row]");
            var $Groups = $(e.target).parents().closest(".group-All").nextAll(".group");
            var $target = $(e.target).closest("tr").find("i");

            if ($target.hasClass("fa-plus-square-o")) {
                $elems.show();
                $(".group").show();
                $(".group-sum").show();
                this.collapseRelated($target, "show");
                $Groups.children().find("I").removeAttr("class").attr("class", "fa fa-minus-square-o");
            }
            else {
                $elems.hide();
                this.collapseRelated($target, "hide");
                $Groups.children().find("I").removeAttr("class").attr("class", "fa fa-plus-square-o");
            }
            this.Api.columns.adjust();
        }
        if ($(e.target).parents(".containerrow").length === 0) {
            $(".containerrow").hide();
            $(".containerrow").prev().children().find("I").removeClass("fa-caret-up").addClass("fa-caret-down");
        }
    }.bind(this);

    this.collapseGroup = function (e) {
        var $group = $(e.target).parents().closest(".group");
        var groupnum = $group.attr("group");
        var $elems = $group.nextUntil("[group=" + groupnum + "]");

        if ($elems.css("display") === "none") {
            $elems.show();
            this.collapseRelated($group.find("i"), "show");
            $elems.filter(".group").children().find("I").removeAttr("class").attr("class", "fa fa-minus-square-o");
        }
        else {
            $elems.hide();
            this.collapseRelated($group.find("i"), "hide");
            $elems.filter(".group").children().find("I").removeAttr("class").attr("class", "fa fa-plus-square-o");
        }
        this.checkHeaderCollapse($group, groupnum);

        if ($(e.target).parents(".containerrow").length === 0) {
            $(".containerrow").hide();
            $(".containerrow").prev().children().find("I").removeClass("fa-caret-up").addClass("fa-caret-down");
        }
        this.Api.columns.adjust();
    }.bind(this);

    this.collapseRelated = function ($elem, type) {

        if (type === "show") {
            $elem.removeClass("fa-plus-square-o");
            $elem.addClass("fa-minus-square-o");
        }
        else {
            $elem.removeClass("fa-minus-square-o");
            $elem.addClass("fa-plus-square-o");
        }

    };

    this.checkHeaderCollapse = function ($group, groupnum) {
        var headergroup = parseInt(groupnum) - 1;
        var nextSiblings = $group.nextUntil("[group=" + headergroup + "]").filter(".group[group=" + groupnum + "]").next();
        var prevSiblings = $group.prevUntil("[group=" + headergroup + "]").filter(".group[group=" + groupnum + "]").next();
        var $ElemtoChange = $group.prevAll(".group[group=" + headergroup + "]").first().children().find("I");
        var nextproperty = nextSiblings.map(function () { return $(this).css("display"); }).get();
        var prevproperty = prevSiblings.map(function () { return $(this).css("display"); }).get();
        var property = nextproperty.concat(prevproperty);
        if (property.contains("none")) {
            var flag = property.every(function (value) {
                return value === property[0];
            });
            if (flag)
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-plus-square-o");
            else
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-minus-square-o");
        }
        else if (property.length === 0) {
            if ($group.nextUntil("[group=" + headergroup + "]").css("display") === "none")
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-plus-square-o");
            else
                $ElemtoChange.removeAttr("class").attr("class", "fa fa-minus-square-o");
        }
        else
            $ElemtoChange.removeAttr("class").attr("class", "fa fa-minus-square-o");
    };

    this.ModifyRowgroupCheckbox = function (e) {
        var $group = $(e.target).parents().closest(".group");
        var groupnum = $group.attr("group");
        var $elems = $group.nextUntil("[group=" + groupnum + "]");
        let checkbox = $(e.target).closest("." + this.tableId + "_rowgroupheadercheckbox");
        if (checkbox[0].checked) {
            $elems.find("." + this.tableId + "_select").prop('checked', true);
            $elems.filter(".group").find("." + this.tableId + "_rowgroupheadercheckbox").prop('checked', true);
            //$group.find(".rowgrouprowcount").html("&nbsp;" + $elems.filter(".odd,.even").length + " rows selected");
        }
        else {
            $elems.find("." + this.tableId + "_select").prop('checked', false);
            $elems.filter(".group").find("." + this.tableId + "_rowgroupheadercheckbox").prop('checked', false);
            $group.find(".rowgrouprowcount").empty();
        }
        $elems.find("." + this.tableId + "_select").trigger("change");
        $elems.filter(".group").find("." + this.tableId + "_rowgroupheadercheckbox").trigger("change");
    };

    this.multiplelevelRowgrouping = function () {
        var rows = this.Api.rows().nodes();
        var rowsdata = this.Api.rows().data();
        var index = this.RGIndex;
        var count = this.Api.columns()[0].length;
        var lastrow = -1;
        var last = null;
        var colobj = {};
        var groupString = "";
        var groupcount = 0;
        this.rowgroupFilter = [];
        $.each(this.NumericIndex, function (k, num) {
            if (!(num in colobj)) {
                colobj[num] = new Array();
            }
        });

        $.each(index, function (j, dt) {
            var last = null;
            var $parent = null;
            var $count = 0;
            //var tempobj = $.grep(this.EbObject.CurrentRowGroup.RowGrouping.$values, function (obj) { return dt === obj.data });//tempobj[0].sTitle + " : " +
            $.each(this.unformatedData, function (i, _dataArray) {

                var te = (_dataArray[dt] === null || _dataArray[dt].trim() === "") ? "(Blank)" : _dataArray[dt].trim();
                groupString = te;

                if (last !== groupString) {
                    if (last === null || Object.keys(colobj).length === 0) {
                        var groupstr = this.getGroupRow(count, groupString, j, dt);
                        $(rows).eq(i).before(groupstr);
                        $count++;
                        $parent = $(groupstr);
                    }
                    else {
                        $parent
                        var rowstring = this.getSubRow(colobj, groupString, count, j);
                        $(rows).eq(i - 1).after(rowstring);
                        $(rows).eq(i).before(this.getGroupRow(count, groupString, j, dt));
                    }
                    last = groupString;
                    $.each(colobj, function (key, val) {
                        colobj[key] = [];
                        colobj[key].push(_dataArray[key]);
                    });
                }
                else {
                    $.each(colobj, function (key, val) {
                        colobj[key].push(_dataArray[key]);
                    });
                    $count++;
                }
                lastrow = i;
            }.bind(this));

            if (Object.keys(colobj).length !== 0 && ($(rows).eq(lastrow).hasClass("odd") || $(rows).eq(lastrow).hasClass("even"))) {
                var rowstring = this.getSubRow(colobj, groupString, count, j);
                $(rows).eq(lastrow).after(rowstring);
            }

        }.bind(this));

        var ct = $(".group[group=0]").length;
        $(`#group-All_${this.tableId} td[colspan=${count}]`).prepend(`All Groups (${ct}) - `);
        this.getRowsCount(count, "multiple");
    }

    this.getRowsCount = function (count, type) {
        let rows = $("#" + this.tableId + " tbody tr.group[group=0]");
        var j = 0;
        this.recursiveRowCount(rows, j, count, type);
    }

    this.recursiveRowCount = function (rows, j, count, type) {
        $.each(rows, function (i, elem) {
            if (typeof (this.RGIndex[j + 1]) === "undefined")
                $(elem).children("td[colspan=" + count + "]").children("b").last().append(" (" + $(elem).nextUntil("[group=" + j + "]").length + ")");
            else {
                if (type === "single")
                    $(elem).children("td[colspan=" + count + "]").children("b").last().append(" (" + $(elem).nextUntil("[group=" + j + "]").length + ")");
                else
                    $(elem).children("td[colspan=" + count + "]").children("b").last().append(" (" + $(elem).nextUntil(".group[group=" + (j) + "]").filter(".group").length + ")");

            }
        }.bind(this));
        if (typeof (this.RGIndex[j + 1]) !== "undefined" && type !== "single") {
            var rowsarray = $("#" + this.tableId + " tbody tr.group[group=" + (j + 1) + "]");
            this.recursiveRowCount(rowsarray, (j + 1), count, type);
        }
    }

    this.doSerial = function () {
        var tempobj = $.grep(this.extraCol, function (obj) { return obj.name === "serial" });
        var index = this.Api.columns(tempobj[0].name + ':name').indexes()[0]
        this.Api.column(index).nodes().each(function (cell, i) { cell.innerHTML = i + 1; });
        this.Api.columns.adjust();
    };

    this.createFooter = function () {
        var ps = 0;
        var tid = this.tableId;
        var aggFlag = false;
        var lfoot = $('#' + this.tableId + '_wrapper .DTFC_LeftFootWrapper table');
        var rfoot = $('#' + this.tableId + '_wrapper .DTFC_RightFootWrapper table');
        var scrollfoot = $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner table');

        if (scrollfoot.length !== 0)
            var eb_footer_controls_scrollfoot = this.GetAggregateControls(ps, 1);

        if (this.EbObject.LeftFixedColumn + this.EbObject.RightFixedColumn > 0) {
            for (var j = 0; j < eb_footer_controls_scrollfoot.length; j++) {
                if (j < this.EbObject.LeftFixedColumn) {
                    scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_scrollfoot[j]);
                    scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).children().remove();
                }
                else {
                    if (j < eb_footer_controls_scrollfoot.length - this.EbObject.RightFixedColumn)
                        scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_scrollfoot[j]);
                    else {
                        scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_scrollfoot[j]);
                        scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).children().remove();
                    }
                }
            }
        }
        else {
            for (let j = 0; j < eb_footer_controls_scrollfoot.length; j++)
                scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).append(eb_footer_controls_scrollfoot[j]); //append or html[solves tv ctrl double footer] fn
        }
        if (lfoot.length !== 0 || rfoot.length !== 0) {
            var eb_footer_controls_lfoot = this.GetAggregateControls(ps, 50);
            if (lfoot.length !== 0) {
                for (let j = 0; j < this.EbObject.LeftFixedColumn; j++) {
                    $(lfoot).children().find("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_lfoot[j]);
                    if (j === 0)
                        $(lfoot).children().find("tr").eq(ps).children("th").eq(j).html("");
                    $(lfoot).children().find("tr").eq(ps).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).css("width"));
                    $(lfoot).children().find("tr").eq(ps).children("th").eq(j).css("height", scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j).css("height"));
                }
            }

            if (rfoot.length !== 0) {
                var start = eb_footer_controls_lfoot.length - this.EbObject.RightFixedColumn;
                for (let j = 0; (j + start) < eb_footer_controls_lfoot.length; j++) {
                    $(rfoot).children().find("tr").eq(ps).children("th").eq(j).html(eb_footer_controls_lfoot[j + start]);
                    $(rfoot).children().find("tr").eq(ps).children("th").eq(j).css("width", scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j + start).css("width"));
                    $(rfoot).children().find("tr").eq(ps).children("th").eq(j).css("height", scrollfoot.find("tfoot").children("tr").eq(ps).children("th").eq(j + start).css("height"));
                }
            }

            $(lfoot).children().find("tr").css("height", scrollfoot.find("tfoot").children("tr").css("height"));
            $(rfoot).children().find("tr").css("height", scrollfoot.find("tfoot").children("tr").css("height"));
        }
        if (this.eb_agginfo.length > 0) {
            var footer_select_id = this.tableId + "_ftr_sel" + ps;
            let _ls = "<div class='input-group-btn dropup'>" +
                "<button type='button' class='btn btn-default dropdown-toggle footerDD' data-toggle='dropdown' id='" + footer_select_id + "'>&sum;</button>" +
                " <ul class='dropdown-menu'>" +
                "  <li class='footerli'><a href ='#' class='eb_ftsel" + this.tableId + "'> &sum; </a><span class='footertext eb_ftsel" + this.tableId + "'>Sum</span></li>" +
                "  <li class='footerli'><a href ='#' class='eb_ftsel" + this.tableId + "'> x&#772; </a><span class='footertext eb_ftsel" + this.tableId + "'>Average</span></li>" +
                " </ul>" +
                " </div>";
            scrollfoot.find(".addedbyeb th").eq(0).html(_ls);
        }
        this.summarize2();
    };

    this.GetAggregateControls = function (footer_id, zidx) {
        var ScrollY = this.EbObject.scrollY;
        var ResArray = [];
        var tableId = this.tableId;
        //$.each(this.EbObject.Columns.$values, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        $.each(this.Api.settings().init().aoColumns, this.GetAggregateControls_inner.bind(this, ResArray, footer_id, zidx));
        return ResArray;
    };

    this.GetAggregateControls_inner = function (ResArray, footer_id, zidx, i, col) {
        var _ls;
        if (col.bVisible) {
            var temp = $.grep(this.eb_agginfo, function (agg) { return agg.colname === col.name });
            //(col.Type ==parseInt( gettypefromString("Int32")) || col.Type ==parseInt( gettypefromString("Decimal")) || col.Type ==parseInt( gettypefromString("Int64")) || col.Type ==parseInt( gettypefromString("Double"))) && col.name !== "serial"
            if (col.Aggregate || col.AggregateFun === 0 || col.AggregateFun === 1) {
                var footer_txt = this.tableId + "_" + col.name + "_ftr_txt" + footer_id;
                var style = "";
                if (col.Align.toString() === EbEnums.Align.Left)
                    style = "text-align: left;";
                else if (col.Align.toString() === EbEnums.Align.Right || col.Align.toString() === EbEnums.Align.Auto)
                    style = "text-align: right;";
                else
                    style = "text-align: center;";

                //_ls = `<input type='text' class='' id='${footer_txt}' disabled style='z-index:${zidx.toString()};${style}'/>`;
                _ls = `<div style='z-index:${zidx.toString()};text-align: center;'><p id='${footer_txt}' disabled style='${style} margin: 10px 0;'></p><div>`;
            }
            else
                _ls = "&nbsp;";

            ResArray.push(_ls);
        }
    };

    this.summarize2 = function () {
        let isUpdatable = true;
        if (Option.fnCanUpdateFooter)
            isUpdatable = Option.fnCanUpdateFooter();
        if (isUpdatable) {
            var api = this.Api;
            var tableId = this.tableId;
            let opScroll = $('.dataTables_scrollFootInner #' + tableId + '_ftr_sel0').text().trim();
            let opLF = $('.DTFC_LeftFootWrapper #' + tableId + '_ftr_sel0').text().trim();
            let opRF = $('.DTFC_RightFootWrapper #' + tableId + '_ftr_sel0').text().trim();
            $.each(this.eb_agginfo, function (index, agginfo) {
                if (agginfo.colname) {
                    let ftrtxtScroll = '.dataTables_scrollFootInner #' + tableId + '_' + agginfo.colname + '_ftr_txt0';
                    let ftrtxtLF = '.DTFC_LeftFootWrapper #' + tableId + '_' + agginfo.colname + '_ftr_txt0';
                    let ftrtxtRF = '.DTFC_RightFootWrapper #' + tableId + '_' + agginfo.colname + '_ftr_txt0';

                    var col = api.column(agginfo.colname + ':name');
                    var summary_val = 0;
                    if (opScroll === '' || opLF === '' || opRF === '') {
                        if (this.Source === "datagrid")
                            summary_val = col.data().sum().toFixed(agginfo.deci_val);
                        else
                            summary_val = (typeof this.summary[agginfo.data] !== "undefined") ? this.summary[agginfo.data][0] : 0;
                    }
                    if (opScroll === 'x' || opLF === 'x' || opRF === 'x') {
                        if (this.Source === "datagrid")
                            summary_val = col.data().average().toFixed(agginfo.deci_val);
                        else
                            summary_val = (typeof this.summary[agginfo.data] !== "undefined") ? this.summary[agginfo.data][1] : 0;
                    }
                    if (opScroll !== "")
                        $(ftrtxtScroll).text(summary_val);
                    if (opLF !== "")
                        $(ftrtxtLF).text(summary_val);
                    if (opRF !== "")
                        $(ftrtxtRF).text(summary_val);
                }
            }.bind(this));
        }
    };

    this.createFilterRowHeader = function () {
        var tableid = this.tableId;
        var order_info_ref = this.order_info;

        var fc_lh_tbl = $('#' + tableid + '_wrapper .DTFC_LeftHeadWrapper table');
        var fc_rh_tbl = $('#' + tableid + '_wrapper .DTFC_RightHeadWrapper table');

        if (fc_lh_tbl.length !== 0 || fc_rh_tbl.length !== 0) {
            this.GetFiltersFromSettingsTbl(50);
            if (fc_lh_tbl.length !== 0) {
                fc_lh_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
                for (let j = 0; j < this.EbObject.LeftFixedColumn; j++)
                    $(fc_lh_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4fc[j]));
            }
            if (fc_rh_tbl.length !== 0) {
                fc_rh_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
                for (let j = this.eb_filter_controls_4fc.length - this.EbObject.RightFixedColumn; j < this.eb_filter_controls_4fc.length; j++)
                    $(fc_rh_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4fc[j]));
            }
        }

        var sc_h_tbl = $('#' + tableid + '_wrapper .dataTables_scrollHeadInner table');
        if (sc_h_tbl !== null) {
            this.GetFiltersFromSettingsTbl(1);
            sc_h_tbl.find("thead").append($("<tr role='row' class='addedbyeb'/>"));
            if (this.EbObject.LeftFixedColumn + this.EbObject.RightFixedColumn > 0) {
                for (let j = 0; j < this.eb_filter_controls_4sb.length; j++) {
                    if (j < this.EbObject.LeftFixedColumn) {
                        $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                        $(sc_h_tbl.find("tr[class=addedbyeb] th:eq(" + j + ")")).children().not("span").remove();
                    }
                    else {
                        if (j < this.eb_filter_controls_4sb.length - this.EbObject.RightFixedColumn)
                            $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                        else {
                            $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
                            $(sc_h_tbl.find("tr[class=addedbyeb] th:eq(" + j + ")")).children().not("span").remove();
                        }
                    }
                }
            }
            else {
                for (let j = 0; j < this.eb_filter_controls_4sb.length; j++)
                    $(sc_h_tbl.find("tr[class=addedbyeb]")).append($(this.eb_filter_controls_4sb[j]));
            }
            sc_h_tbl.find("thead .addedbyeb").before($("<tr role='row' id='filterdisplayrow_" + this.tableId + "' class='filterdisplayrow'><td id='filterdisplayrowtd_" + this.tableId + "' colspan=" + this.columnCount + " style='padding: 2px!important;'></td></tr>"));
        }

        // $('#' + tableid + '_wrapper table thead tr[class=addedbyeb]').hide();

        //$('thead:eq(0) tr:eq(1) [type=checkbox]').prop('indeterminate', true);
        $(".addedbyeb [type=checkbox]").prop('indeterminate', true);
        $(".DTFC_Blocker").remove();
    };

    this.createColspanHeader = function () {

    };

    this.createFilterforTree = function () {
        var TRange = null;
        $(".dataTables_info").after(`<div id="${this.tableId}_filter" class="col-md-4 dataTables_filters">
        <div class="input-group">
            <input type="text" class="form-control" placeholder="Search">
            <div class="input-group-btn">
              <button class="btn btn-default" type="submit">
                <i class="glyphicon glyphicon-search"></i>
              </button>
            </div>
          </div>
       
        </div>`);
        $(`#${this.tableId}_filter input`).off("keyup").on("keyup", this.LocalSearch.bind(this));
        //<button class="btn previous_h"><i class="fa fa-angle-up" aria-hidden="true"></i></button>
        //<button class="btn next_h"><i class="fa fa-angle-down" aria-hidden="true"></i></button>
    };

    this.LocalSearch = function (e) {
        var text = $(e.target).val();
        //if (e.keyCode === 13 && text.length > 2) {
        //$(".match").each(function (i, span) {
        //    $(span).parent().text($(span).parent().text());
        //    $(span).remove();
        //});
        if (text !== "")
            this.searchAndHighlight(text, ".dataTables_scrollBody");
        else
            $(".dataTables_scrollBody").find("tr").show();
        this.Api.columns.adjust();

        //}
    };

    this.findString = function (str) {
        if (parseInt(navigator.appVersion) < 4) return;
        var strFound;
        if (window.find) {

            // CODE FOR BROWSERS THAT SUPPORT window.find

            strFound = self.find(str);
            if (!strFound) {
                strFound = self.find(str, 0, 1);
                while (self.find(str, 0, 1)) continue;
            }
        }
        else if (navigator.appName.indexOf("Microsoft") !== -1) {

            // EXPLORER-SPECIFIC CODE

            if (TRange !== null) {
                TRange.collapse(false);
                strFound = TRange.findText(str);
                if (strFound) TRange.select();
            }
            if (TRange === null || strFound === 0) {
                TRange = self.document.body.createTextRange();
                strFound = TRange.findText(str);
                if (strFound) TRange.select();
            }
        }
        else if (navigator.appName === "Opera") {
            alert("Opera browsers not supported, sorry...");
            return;
        }
        if (!strFound) alert("String '" + str + "' not found!");
        return;
    };

    this.searchAndHighlight = function (searchTerm, selector) {
        if (searchTerm) {
            var searchTermRegEx = new RegExp(searchTerm, "ig");
            var matches = $(selector).text().match(searchTermRegEx);
            if (matches !== null && matches.length > 0) {
                $('.highlighted').removeClass('highlighted'); //Remove old search highlights  

                //Remove the previous matches
                $span = $(selector).children('span');
                $span.replaceWith($span.html());

                if (searchTerm === "&") {
                    searchTerm = "&amp;";
                    searchTermRegEx = new RegExp(searchTerm, "ig");
                }
                var arr = $(selector).find("td").toArray().filter(obj => $(obj).text().toLowerCase().includes(searchTerm.toLowerCase()));
                //arr.forEach(function (obj, i) {
                //    let $target = $(obj);
                //    let $next = $target.children();
                //    while ($next.length) {
                //        $target = $next;
                //        $next = $next.children();
                //    }
                //    let x = $($target).text().match(searchTermRegEx);
                //    $($target).html($($target).html().replace(searchTermRegEx, "<span class='match'>" + x[0] + "</span>"));
                //}); 
                //$(selector).html($(selector).html().replace(searchTermRegEx, "<span class='match'>" + matches[0] + "</span>"));
                //$('.match:first').addClass('highlighted');

                //var i = 0;

                //$('.next_h').off('click').on('click', function () {

                //    i++;

                //    if (i >= $('.match').length) i = 0;

                //    $('.match').removeClass('highlighted');
                //    $('.match').eq(i).addClass('highlighted');
                //    if ($('.match').length) {
                //        $(selector).animate({
                //            scrollTop: $('.match').eq(i).position().top
                //        }, 300);
                //    }
                //});

                //$('.previous_h').off('click').on('click', function () {

                //    i--;

                //    if (i < 0) i = $('.match').length - 1;

                //    $('.match').removeClass('highlighted');
                //    $('.match').eq(i).addClass('highlighted');
                //    if ($('.match').length) {
                //        $(selector).animate({
                //            scrollTop: $('.match').eq(i).position().top
                //        }, 300);
                //    }
                //});

                //if ($('.highlighted:first').length) { //if match found, scroll to where the first one appears
                //    $(selector).scrollTop($('.highlighted:first').position().top);
                //}
                $(selector).find("tr").hide();
                arr.forEach(function (obj, i) {
                    $(obj).closest("tr").show();
                });
                return true;
            }
        }
        return false;
    };

    this.addFilterEventListeners = function () {
        $(".columnimage").lazy();
        $('#' + this.tableId + '_wrapper thead tr:eq(0)').off('click').on('click', 'th', this.orderingEvent.bind(this));
        $(".eb_fsel" + this.tableId).off("click").on("click", this.setLiValue.bind(this));
        $(".eb_ftsel" + this.tableId).off("click").on("click", this.fselect_func.bind(this));
        $.each($(this.Api.columns().header()).parent().siblings().children().toArray(), this.setFilterboxValue.bind(this));
        $("." + this.tableId + "_htext").off("keyup").on("keyup", this.call_filter);
        $(".eb_fbool" + this.tableId).off("change").on("change", this.toggleInFilter.bind(this));
        $(".eb_selall" + this.tableId).off("click").on("click", this.clickAlSlct.bind(this));
        $("." + this.tableId + "_select").off("change").on("change", this.updateAlSlct.bind(this));
        $(".eb_canvas" + this.tableId).off("click").on("click", this.renderMainGraph);
        $(".tablelink" + this.tableId).off("click").on("click", this.link2NewTable.bind(this));
        $(".tablelinkfromcolumn" + this.tableId).off("click").on("click", this.link2NewTable.bind(this));
        $("#" + this.tableId).off("click", ".tablelink4calendar").on("click", ".tablelink4calendar", this.linkFromCalendar.bind(this));
        //$(`tablelinkInline_${this.tableId}`).off("click").on("click", this.link2NewTableInline.bind(this));
        //$(".tablelink_" + this.tableId).off("mousedown").on("mousedown", this.link2NewTableInNewTab.bind(this));
        $(".closeTab").off("click").on("click", this.deleteTab.bind(this));


        //this.Api.off('key-focus').on('key-focus', function (e, datatable, cell) {
        //    datatable.rows().deselect();
        //    let trindex = cell.index().row;
        //    datatable.row(trindex).select();
        //    //$(".DTFC_LeftBodyLiner tbody tr").eq(trindex).addClass("selected");
        //    //$(".DTFC_RightBodyLiner tbody tr").eq(trindex).addClass("selected");
        //});

        //this.filterbtn.off("click").on("click", this.showOrHideFilter.bind(this));
        $("#clearfilterbtn_" + this.tableId).off("click").on("click", this.clearFilter.bind(this));
        //$("#" + this.tableId + "_btntotalpage").off("click").on("click", this.showOrHideAggrControl.bind(this));
        this.copybtn.off("click").on("click", this.CopyToClipboard.bind(this));
        this.printbtn.off("click").on("click", this.ExportToPrint.bind(this));
        //this.printAllbtn.off("click").on("click", this.printAll.bind(this));
        this.printSelectedbtn.off("click").on("click", this.printSelected.bind(this));
        $("#btnExcel" + this.tableId).off("click").on("click", this.ExportToExcel.bind(this));
        this.csvbtn.off("click").on("click", this.ExportToCsv.bind(this));
        this.pdfbtn.off("click").on("click", this.ExportToPdf.bind(this));
        //$("#btnToggleFD" + this.tableId).off("click").on("click", this.toggleFilterdialog.bind(this));
        $(".columnMarker" + this.tableId).off("click").on("click", this.link2NewTable.bind(this));
        $(".columnimage").one("load", function () {
            $(".columnimage").off("click").on("click", this.ViewImage.bind(this));
            $(".columnimage").on("error", this.OnErrorImage);
        }.bind(this));
        $('[data-toggle="tooltip"],[data-toggle-second="tooltip"]').tooltip({
            placement: 'bottom'
        });
        $('.status-time').tooltip({
            placement: 'left'
        });

        $('.columntooltip').popover({
            container: 'body',
            trigger: 'hover',
            placement: this.PopoverPlacement,
            html: true,
            content: function (e, i) {
                $(".popover").remove();
                //return atob($(this).attr("data-contents"));
                return decodeURIComponent(atob($(this).attr("data-contents")).split('').map(function (c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
            },
        });

        $('.btn-approval_popover').popover({
            container: 'body',
            trigger: 'click',
            placement: this.ApprovalPopoverPlacement,
            html: true,
            template: '<div class="popover approval-popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
            content: function (e, i) {
                return atob($(this).attr("data-contents"));
            },
        });

        $('.btn-approval_popover').on('click', function (e) {
            //$('.btn-approval_popover').not(this).popover("hide");
        });

        $('.btn-approval_popover').off('shown.bs.popover').on('shown.bs.popover', function (e) {
            $(".stage_actions").selectpicker();
            let $td = $(e.target).closest("td.tdheight");
            $(".btn-action_execute").off("click").on("click", this.ExecuteApproval.bind(this, $td, 'execute'));
            $(".btn-action_reset").off("click").on("click", this.ExecuteApproval.bind(this, $td, 'reset'));
        }.bind(this));

        $('.btn-approval_popover').on('hidden.bs.popover', function (e) {
            $(e.target).data("bs.popover").inState.click = false;
        }.bind(this));

        $('body').on('click', function (e) {
            $('[data-toggle=popover]').each(function () {
                // hide any open popovers when the anywhere else in the body is clicked
                if (!$(this).is(e.target) && $(this).has(e.target).length === 0 && $('.popover').has(e.target).length === 0) {
                    $(this).popover('hide');
                }
            });
        });

        if (this.Source !== "loginActivity") {
            $(".rating").rateYo({
                readOnly: true,
                starWidth: "24px"
            });
        }

        $("[data-coltyp=date]").datepicker({
            dateFormat: this.datePattern.replace(new RegExp("M", 'g'), "m").replace(new RegExp("yy", 'g'), "y"),
            beforeShow: function (elem, obj) {
                $(".ui-datepicker").addClass("datecolumn-picker");
            },
            onSelect: function (d, i) {
                if (d !== i.lastVal)
                    this.call_filter({ keyCode: 10 });
            }.bind(this)
        });
        $("[data-coltyp=date]").on("click", function () {
            $(this).datepicker("show");
        });
        //$("#switch" + this.tableId).off("click").on("click", this.SwitchToChart.bind(this));
        //this.Api.columns.adjust();
    };

    this.ViewImage = function (e) {
        let data = $(e.target).attr("src").replace("/images/", "").replace("small/", "").replace("medium/", "").replace(".jpg", "");
        this.FileViewer.showimage(data);
    };

    this.OnErrorImage = function () {
        $(this).attr('src', '/images/image.png').off("click");
    };

    this.PopoverPlacement = function (context, source) {
        var position = $(source).offset();

        if (position.left > 1000)
            return "left";
        else {
            return "right";
        }
    };

    this.ApprovalPopoverPlacement = function (context, source) {
        var position = $(source).offset();
        let w = $(window).width();
        if (position.left + 600 > w)
            return "left";
        else
            return "right";
    };

    this.GenerateButtons = function () {
        if (this.Source === "PivotTable") {
            let $print = $("<button id='print" + this.tableId + "' class='btn commonControl print' onclick='window.print();'><i class='fa fa-print' aria-hidden='true'></i></button>");
            $('print' + this.tableId).remove();
            $("#obj_icons").append($print);
        }
        else {
            this.submitId = "btnGo" + this.tableId;
            this.$submit = $("<button id='" + this.submitId + "' class='btn commonControl'><i class='fa fa-play' aria-hidden='true'></i></button>");
            if (this.Source === "WebForm") {
                $("#buttondiv_" + this.tableId).empty();
                this.$submit = $("<div id='" + this.submitId + "' class='btn commonControl'><i class='fa fa-refresh' aria-hidden='true'></i></div>");
                $("#buttondiv_" + this.tableId).append(this.$submit);
            }
            else {
                $(".toolicons").show();
                let search = $('#obj_icons .toolb-srchbx-wrpr').detach();
                $('#obj_icons').empty().append(search);
                $("#obj_icons").append(this.$submit);
            }
            this.$submit.click(this.getColumnsSuccess.bind(this));

            if (window.location.href.indexOf("hairocraft") !== -1 && this.login === "uc" && this.dvName.indexOf("leaddetails") !== -1)
                $("#obj_icons").prepend(`<button class='btn' data-toggle='tooltip' title='NewCustomer' onclick='window.open("/leadmanagement","_blank");' ><i class="fa fa-user-plus"></i></button>`);

            if (this.Source === "EbDataTable") {
                if (this.EbObject.FormLinks.$values.length > 0) {
                    this.EbObject.FormLinks.$values = this.EbObject.FormLinks.$values.filter((thing, index, self) =>
                        index === self.findIndex((t) => (
                            t.DisplayName === thing.DisplayName && t.Refid === thing.Refid
                        ))
                    );
                    this.CreateNewFormLinks();
                }
                this.CreatePrintDocsLinks();
                $("#objname").text(this.EbObject.DisplayName);
                if ($("#" + this.tableId).children().length > 0) {
                    if (this.FD) {
                        this.filterid = "filter" + this.tableId;
                        this.$filter = $("<button id='" + this.filterid + "' class='btn commonControl'><i class='fa fa-filter' aria-hidden='true'></i></button>");
                        $("#obj_icons").append(this.$filter);
                        this.$filter.click(this.CloseParamDiv.bind(this));
                    }
                    if (this.login === "uc") {
                        $("#obj_icons").append(`<div id='${this.tableId}_fileBtns' style='display: inline-block;'><div class='btn-group'></div></div>`);
                        $.each(this.permission, function (i, obj) {
                            if (obj === "Excel")
                                $("#" + this.tableId + "_fileBtns .btn-group").append("<button id ='btnExcel" + this.tableId + "' class='btn'  name = 'filebtn' data-toggle='tooltip' title = 'Excel' > <i class='fa fa-file-excel-o' aria-hidden='true'></i></button >");
                        }.bind(this));
                        dvcontainerObj.modifyNavigation();
                    }
                }
                //this.CreatePgButton();
                this.excelbtn = $("#btnExcel" + this.tableId);
            }
            else {
                $(".display-none").remove();
            }

            if (this.IsTree) {
                this.CreateContexmenu4Tree();
            }
            if (this.isSecondTime) {
                this.addFilterEventListeners();
            }
            $("#" + this.tableId + " tbody").off("click", ".groupform").on("click", ".groupform", this.collapseTreeGroup);
            this.Contexmenu4SmsColumn();
        }
    };

    this.CreatePgButton = function () {
        $("#obj_icons").append(`<button class="btn filter_menu" id="ppt-grid">
                                    <i class="fa fa-cog" aria-expanded="false"></i>
                                </button>`);
        $(".stickBtn").hide();
        this.PropertyDiv = $("#pp_inner");
        $("#ppt-grid").off("click").on("click", this.togglePG.bind(this));
        $("#pp_inner").find(".pgpin").remove();
        $("#pp_inner .pgHead").append(`<div class="icon-cont  pull-right pgpin" id="${this.tabNum}_pg-close">
                <i class="fa fa-thumb-tack" style="transform: rotate(90deg);"></i></div>`);
        $(`#${this.tabNum}_pg-close`).off("click").on("click", this.togglePG.bind(this));
    };

    this.Contexmenu4SmsColumn = function () {
        $.contextMenu({
            selector: ".smsbutton",
            trigger: 'left',
            build: function ($trigger, e) {
                $("body").find("td").removeClass("focus");
                $("body").find("[role=row]").removeClass("selected");
                $trigger.closest("[role=row]").addClass("selected");
                return {
                    items: {
                        "SENDSMS": { name: "Send SMS", icon: "fa-mobile", callback: this.OpenSMSModal.bind(this) }
                    }
                };
            }.bind(this)
        });
    };

    this.OpenSMSModal = function (key, opt, event) {
        let colname = $(opt.$trigger).attr("data-colname");
        this.phonecolumn = this.EbObject.Columns.$values.filter(obj => obj.name === colname)[0];
        this.AppendSMSModal($(opt.$trigger));
        this.AppendSMSTemplates($(opt.$trigger));
        $("#smsmodal").modal("show");
    };

    this.AppendSMSModal = function ($elem) {
        $("#smsmodal").remove();
        let modal1 = `<div class="modal fade" tabindex="-1" role="dialog" id='smsmodal'>
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">SMS Template</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body" id='sms-modal-body'>
        <table class='table'>
            <tbody>
                <tr><td><div class='smslabel'>Template :</div></td><td class='smstemplate-select-cont'></td>
                    <td><div class='smslabel'>To :</div></td>
                    <td class='sms-number-cont'>
                        <input class="form-control" type='text' id='sms-number' placeholder='phone number here..'>
                    </td>
                </tr>
                <tr><td colspan='4' class='sms-textarea-cont'><textarea id='sms-textarea' class="form-control" placeholder='SMS text here..'></textarea></td></tr>
            </tbody>
        </table>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" id='sendbtn'><i class="fa fa-paper-plane" aria-hidden="true"></i><span id='sendbtn-text'>Send</span></button>
      </div>
    </div>
  </div>
</div>`;

        $("body").prepend(modal1);
        $("#sendbtn").prop("disabled", true);
        $("#sendbtn").off("click").on("click", this.SendSMS.bind(this, $elem));
    };

    this.AppendSMSTemplates = function ($elem) {
        let template = `<select class="selectpicker smstemplate-select">`;
        //template += `<option value=''>--- Select SMS Template ---</option>`;
        $.each(this.phonecolumn.Templates.$values, function (i, obj) {
            template += `<option value='${obj.ObjRefId}'>${obj.ObjDisplayName}</option>`;
        });
        template += `<option value=''>Custom Template</option>`;
        template += `</select>`;
        $(".smstemplate-select-cont").append(template);
        $(".smstemplate-select").selectpicker();
        $('#sms-modal-body .selectpicker').on('changed.bs.select', this.ClickOnTemplate.bind(this, $elem));
        $('#sms-modal-body .selectpicker').val(this.phonecolumn.Templates.$values[0].ObjRefId).change();
    };

    this.ClickOnTemplate = function ($elem, e, clickedIndex, isSelected, previousValue) {
        let refid = $(".smstemplate-select option:selected").val();
        var idx = this.Api.row($elem.parents().closest("td")).index();
        this.rowData = this.unformatedData[idx];
        let filters = this.getFilterValues().concat(this.FilterfromRow());
        $("#sendbtn").prop("disabled", false);
        if (refid) {
            $.ajax({
                type: "POST",
                url: "../DV/GetSMSPreview",
                data: { RefId: refid, Params: filters },
                success: this.AppendSMSPreview.bind(this)
            });
        }
        else
            this.AppendSMSPreview();
    };
    this.AppendSMSPreview = function (result) {
        if (result) {
            result = JSON.parse(result);
            $("#sms-number").val(result.FilledSmsTemplate.SmsTo).prop("disabled", true);
            $("#sms-textarea").val(atob(result.FilledSmsTemplate.SmsTemplate.Body)).prop("disabled", true);
        }
        else {
            $("#sms-number").val("").prop("disabled", false);
            $("#sms-textarea").val("").prop("disabled", false);
        }
    };

    this.SendSMS = function ($elem) {
        if (this.MakeSMSValidation()) {
            $("#smsmodal").modal("hide");
            $("#eb_common_loader").EbLoader("show");
            $.ajax({
                type: "POST",
                url: "../DV/SendSMS",
                data: { To: $("#sms-number").val(), Body: $("#sms-textarea").val() },
                success: this.SendSMSSuccess.bind(this)
            });
        }
    };

    this.MakeSMSValidation = function () {
        if ($("#sms-number").val() && $("#sms-textarea").val())
            return true;
        else {
            EbMessage("show", { Message: "Phone number or text is Empty", Background: "#e40707" });
            return false;
        }
    };

    this.SendSMSSuccess = function () {
        $("#eb_common_loader").EbLoader("hide");
        EbPopBox("show", { Message: "Message sent", Title: "Success" });
    };

    this.CreateContexmenu4Tree = function () {
        $.contextMenu({
            selector: ".groupform", className: 'treeview',
            build: function ($trigger, e) {
                $("body").find("td").removeClass("focus");
                $("body").find("[role=row]").removeClass("selected");
                $trigger.closest("[role=row]").addClass("selected");
                if (this.GroupFormLink !== null) {
                    if ($(e.currentTarget).children().hasClass("levelzero")) {
                        return {
                            items: {
                                "NewGroup": { name: "New Group", icon: "fa-plus-square", callback: this.FormNewGroup.bind(this) },
                                "NewItem": { name: "New Item", icon: "fa-plus-square", callback: this.FormNewItem.bind(this) },
                                "EditGroup": { name: "View Group", icon: "fa-pencil-square-o", callback: this.FormEditGroup.bind(this) }
                            }
                        };
                    }
                    else {
                        return {
                            items: {
                                "NewGroup": { name: "New Group", icon: "fa-plus-square", callback: this.FormNewGroup.bind(this) },
                                "NewItem": { name: "New Item", icon: "fa-plus-square", callback: this.FormNewItem.bind(this) },
                                "EditGroup": { name: "View Group", icon: "fa-pencil-square-o", callback: this.FormEditGroup.bind(this) },
                                "Move": { name: "Move Group", icon: "fa-arrows", callback: this.MoveGroupOrItem.bind(this) }
                            }
                        };
                    }
                }
                else if (this.Source === "locationTree") {
                    return {
                        items: {
                            "NewGroup": { name: "New", icon: "fa-plus-square", callback: this.OpenLocationModal.bind(this) },
                            "EditGroup": { name: "Edit", icon: "fa-pencil-square-o", callback: this.OpenLocationModal.bind(this) },
                            "Move": { name: "Move", icon: "fa-arrows", callback: this.MoveGroupOrItem.bind(this) }
                        }
                    };
                }
                else {
                    if ($(e.currentTarget).hasClass("levelzero")) {
                        return {};
                    }
                    else {
                        return {
                            items: {
                                "Move": { name: "Move Group", icon: "fa-arrows", callback: this.MoveGroupOrItem.bind(this) }
                            }
                        };
                    }
                }
            }.bind(this)

        });

        $.contextMenu({
            selector: ".itemform",
            build: function ($trigger, e) {
                $("body").find("td").removeClass("focus");
                $("body").find("[role=row]").removeClass("selected");
                $trigger.closest("[role=row]").addClass("selected");
                if (this.ItemFormLink !== null) {
                    return {
                        items: {
                            "EditItem": { name: "View Item", icon: "fa-pencil-square-o", callback: this.FormEditItem.bind(this) },
                            "Move": { name: "Move Item", icon: "fa-arrows", callback: this.MoveGroupOrItem.bind(this) }
                        }
                    };
                }
                else if (this.Source === "locationTree") {
                    return {
                        items: {
                            "EditItem": { name: "Edit", icon: "fa-pencil-square-o", callback: this.OpenLocationModal.bind(this) },
                            "Move": { name: "Move", icon: "fa-arrows", callback: this.MoveGroupOrItem.bind(this) }
                        }
                    };
                }
                else {
                    return {
                        items: {
                            "Move": { name: "Move Item", icon: "fa-arrows", callback: this.MoveGroupOrItem.bind(this) }
                        }
                    };
                }
            }.bind(this)

        });
    };

    this.OpenLocationModal = function (key, opt, event) {
        let id_index = this.EbObject.Columns.$values.filter(obj => obj.name === "id")[0].data;

        let index = opt.$trigger.parent().closest("tr").index();
        let rowData = this.unformatedData[index];

        $('#add_location_modal').modal("show");
        if (key === "EditGroup" || key === "EditItem") {
            let longname_index = this.EbObject.Columns.$values.filter(obj => obj.name === "longname")[0].data;
            let shortname_index = this.EbObject.Columns.$values.filter(obj => obj.name === "shortname")[0].data;
            let parent_id_index = this.EbObject.Columns.$values.filter(obj => obj.name === "parent_id")[0].data;
            let image_index = this.EbObject.Columns.$values.filter(obj => obj.name === "image")[0].data;
            let types_index = this.EbObject.Columns.$values.filter(obj => obj.name === "eb_location_types_id")[0].data;
            let meta_index = this.EbObject.Columns.$values.filter(obj => obj.name === "meta_json")[0].data;

            $("#add_location_modal").find("input[type='text']").val("");
            $("#add_location").text("Update");
            $("input[name='_LocId']").val(rowData[id_index]);
            $("input[name='_longname']").val(rowData[longname_index]);
            $("input[name='_shortname']").val(rowData[shortname_index]);
            $("#_parentId").val(rowData[parent_id_index]);
            $(`input[name='_Logo']`).val(rowData[image_index]);
            $("#loc_type").val(rowData[types_index]);
            let meta = JSON.parse(rowData[meta_index]);
            for (var item in meta) {
                $(`#add_location_modal input[name=n${item}]`).val(meta[item]);
            }
        }
        else if (key === "NewGroup") {
            $("#add_location").text("Add");
            $("#_parentId").val(rowData[id_index]);
            $("input[name='_LocId']").val("");
            $(`input[name='_Logo']`).val("");
            $("#loc_type").val("");
            $("#add_location_modal").find("input[type='text']").val("");
        }
    };

    this.CreateContextmenu4ObjectSelector = function () {
        $.contextMenu('destroy', ".dataclass");
        if (this.ObjectLinks.length > 1) {
            let _items = {};
            $.each(this.ObjectLinks, function (i, obj) {
                _items[obj.ObjName] = { name: obj.ObjDisplayName, callback: this.CalendarLinkClick.bind(this) };
            }.bind(this));
            $.contextMenu({
                selector: ".dataclass",
                build: function ($trigger, e) {
                    $("body").find("td").removeClass("focus");
                    $("body").find("[role=row]").removeClass("selected");
                    $trigger.closest("[role=row]").addClass("selected");
                    return {
                        items: _items
                    };
                }.bind(this)
            });
        }
    };

    this.CalendarLinkClick = function (key, idx, event) {
        let MapObj = this.ObjectLinks.filter(obj => obj.ObjName === key)[0];
        let rowdata;
        if (event !== undefined) {
            // var idx = this.Api.row(opt.$trigger.parent().parent()).index();
            rowdata = window.atob(idx.$trigger.children("span").attr("hidden-row")).split(",");
        }
        else {
            rowdata = this.unformatedData[idx];
        }
        if (MapObj.ObjRefId.split("-")[2] === "0") {
            var filter = this.GetFilterforCalendarToForm(MapObj, rowdata);
            if (MapObj.FormMode === 1) {
                if (filter[0].Value === "") {
                    MapObj.FormMode = 2;
                    filter = [];
                }
            }
            if (parseInt(EbEnums.LinkTypeEnum.Popout) === MapObj.LinkType) {
                this.WebFormlink(MapObj.ObjRefId, btoa(unescape(encodeURIComponent(JSON.stringify(filter)))), MapObj.FormMode);
            }
            else {
                CallWebFormCollectionRender({
                    _source: 'tv',
                    _refId: MapObj.ObjRefId,
                    _params: btoa(unescape(encodeURIComponent(JSON.stringify(filter)))),
                    _mode: MapObj.FormMode,
                    _locId: ebcontext.locations.CurrentLoc
                });
                //$("#iFrameFormPopupModal").modal("show");
                //let url = `../WebForm/Index?_r=${MapObj.ObjRefId}&_p=${btoa(unescape(encodeURIComponent(JSON.stringify(filter))))}&_m=1${MapObj.FormMode}&_l=${ebcontext.locations.CurrentLoc}`;
                //$("#iFrameFormPopup").attr("src", url);
            }
        }
    };

    this.GetFilterforCalendarToForm = function (MapObj, rowdata) {
        let filters = [];
        if (MapObj.FormMode === 1) {
            var col = MapObj.FormId.$values;
            $.each(col, function (i, col) {
                filters.push(new fltr_obj(col.Type, col.name, rowdata[col.OIndex]));
            }.bind(this));
        }
        else if (MapObj.FormMode === 2) {
            var cols = MapObj.FormParameters.$values;
            $.each(cols, function (i, col) {
                if (rowdata[col.data] !== "")
                    filters.push(new fltr_obj(col.Type, col.FormControl.Name, rowdata[col.OIndex]));
            }.bind(this));
        }
        return filters;
    };

    this.CreateNewFormLinks = function () {
        $("#obj_icons").append(`<div class="dropdown" style="display:inline-block;" id="NewFormdd${this.tableId}">
                    <button class="btn" type="button" id="NewFormButton${this.tableId}" data-toggle="dropdown" title='Newform'>
                        <i class="fa fa-plus" aria-hidden="true"></i>
                    </button>
                    <div class="dropdown-menu newform-menu">
                        <ul class="drp_ul"></ul>
                    </div>
                    </div>`);
        let _locale = (ebcontext.languages != undefined) ? ebcontext.languages.getCurrentLocale() : 0;
        $.each(this.EbObject.FormLinks.$values, function (i, obj) {
            let url = `../Webform/Index?_r=${obj.Refid}&_m=2&_l=${ebcontext.locations.CurrentLoc}&_lo=${_locale}`;
            $(`#NewFormdd${this.tableId} .drp_ul`).append(`<li class="drp_item"><a class="dropdown-item" href="${url}" target="_blank">${obj.DisplayName}</a></li>`);
        }.bind(this));
    };

    this.CreatePrintDocsLinks = function () {
        if (this.EbObject.PrintDocs && this.EbObject.PrintDocs.$values.length > 0) {
            $("#obj_icons").append(`<div class="dropdown" style="display:inline-block;" id="PrintDocsdd${this.tableId}">
                    <button class="btn" type="button" id="PrintDocsButton${this.tableId}" data-toggle="dropdown" title='Print'>
                        <i class="fa fa-print" aria-hidden="true"></i>
                    </button>
                    <div class="dropdown-menu newform-menu">
                        <ul class="drp_ul"></ul>
                    </div>
                    </div>`);

            $.each(this.EbObject.PrintDocs.$values, function (i, obj) {
                let tle = obj.Title || obj.ObjDisplayName;
                $(`#PrintDocsdd${this.tableId} .drp_ul`).append(`<li class="drp_item" data-token="${obj.ObjRefId}" data-params="${obj.UseParams}" style="padding: 5px 15px; font-size: 14px;">${tle}</li>`);
            }.bind(this));

            $(`#PrintDocsdd${this.tableId}`).off(".drp_ul li").on("click", ".drp_ul li", this.printDocument.bind(this));
        }
    };

    this.printDocument = function (e) {
        if (!ebcontext.webform) {
            ebcontext.webform = { showLoader: this.showEbLoader, hideLoader: this.hideEbLoader };
        }

        let rptRefid = $(e.currentTarget).attr('data-token');
        let useParams = $(e.currentTarget).attr('data-params');

        if (useParams == 'true') {
            let params = btoa(JSON.stringify(this.filterValues));
            let url = "/ReportRender/Renderlink?refid=" + rptRefid + "&_params=" + params;
            ebcontext.webform.showLoader();
            $("#iFramePdf4dv").attr("src", url);
            return;
        }

        let rowIds = [];
        let chkdInps = $(`input[name=${this.tableId}_id]:checked`);

        if (chkdInps && chkdInps.length > 0) {
            $(`#PrintDocsButton${this.tableId}`).prop("disabled", true);
            EbMessage("show", { Message: 'Generating PDF... Please wait in this tab or visit Downloads page after a while..', AutoHide: true, Background: '#00aa55', Delay: 15000 });
            ebcontext.webform.showLoader();

            for (let i = 0; i < chkdInps.length; i++) {
                rowIds.push($(chkdInps[i]).val());
            }
            let SubscriptionId = window.ebcontext.subscription_id;
            this.ss = new EbServerEvents({ ServerEventUrl: window.ebcontext.se_url, Channels: ["PdfDownload"] });
            this.ss.onPdfDownloadSuccess = function (url) {
                $("#iFramePdf4dv").attr("src", url);
                $(`#PrintDocsButton${this.tableId}`).prop("disabled", false);
                event.stopPropagation();
            }.bind(this);


            $.ajax({
                type: "GET",
                url: "/WebForm/GetPdfReportMulti?refId=" + rptRefid + "&rowId=" + rowIds.join(',') + "&_sub=" + SubscriptionId
            });

        }
        else {
            alert('Nothing selected');
        }
    };

    this.FormNewGroup = function (key, opt, event) {
        let index = opt.$trigger.parent().closest("tr").index();
        this.rowData = this.unformatedData[index];
        let filterparams = btoa(JSON.stringify(this.formatToMutipleParameters(this.treeColumn.GroupFormParameters.$values)));

        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.GroupFormLink, _params: filterparams, _mode: 2, _locId: ebcontext.locations.CurrentLoc });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../WebForm/Index?_r=${this.GroupFormLink}&_p=${filterparams}&_m=12&_l=${ebcontext.locations.CurrentLoc}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            this.WebFormlink(this.GroupFormLink, filterparams, "2");
        }
    };

    this.FormNewItem = function (key, opt, event) {
        let index = opt.$trigger.parent().closest("tr").index();
        this.rowData = this.unformatedData[index];
        let filterparams = btoa(JSON.stringify(this.formatToMutipleParameters(this.treeColumn.ItemFormParameters.$values)));
        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.ItemFormLink, _params: filterparams, _mode: 2, _locId: ebcontext.locations.CurrentLoc });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../WebForm/Index?_r=${this.ItemFormLink}&_p=${filterparams}&_m=12&_l=${ebcontext.locations.CurrentLoc}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            this.WebFormlink(this.ItemFormLink, filterparams, "2");
        }
    };

    this.FormEditGroup = function (key, opt, event) {
        let index = opt.$trigger.parent().closest("tr").index();
        this.rowData = this.unformatedData[index];
        let filterparams = btoa(JSON.stringify(this.formatToParameters(this.treeColumn.GroupFormId.$values)));
        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.GroupFormLink, _params: filterparams, _mode: 1, _locId: ebcontext.locations.CurrentLoc });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../WebForm/Index?_r=${this.GroupFormLink}&_p=${filterparams}&_m=11&_l=${ebcontext.locations.CurrentLoc}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            this.WebFormlink(this.GroupFormLink, filterparams, "1");
        }
    };

    this.FormEditItem = function (key, opt, event) {
        let index = opt.$trigger.parent().closest("tr").index();
        this.rowData = this.unformatedData[index];
        let filterparams = btoa(JSON.stringify(this.formatToParameters(this.treeColumn.ItemFormId.$values)));
        if (parseInt(EbEnums.LinkTypeEnum.Popup) === this.treeColumn.LinkType) {
            CallWebFormCollectionRender({ _source: 'tv', _refId: this.ItemFormLink, _params: filterparams, _mode: 1, _locId: ebcontext.locations.CurrentLoc });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../WebForm/Index?_r=${this.ItemFormLink}&_p=${filterparams}&_m=11&_l=${ebcontext.locations.CurrentLoc}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            this.WebFormlink(this.ItemFormLink, filterparams, "1");
        }
    };

    this.formatToParameters = function (cols) {
        var filters = [];
        $.each(cols, function (i, col) {
            if (this.rowData[col.data] !== "")
                filters.push(new fltr_obj(col.Type, col.name, this.rowData[col.data]));
        }.bind(this));
        return filters;
    };

    this.formatToMutipleParameters = function (cols) {
        var filters = [];
        $.each(cols, function (i, col) {
            if (this.rowData[col.data] !== "")
                filters.push(new fltr_obj(col.Type, col.FormControl.Name, this.rowData[col.data]));
        }.bind(this));
        return filters;
    };

    this.collapseTreeGroup = function (e) {
        let el = (e.target).closest("td");
        let curRow = $(el).parents().closest("[role=row]");
        var level = parseInt($(curRow).attr("data-lvl"));
        var isShow = ($(el).children("i").hasClass("fa-minus-square-o")) ? false : true;
        let count = this.RowCount;
        let rows = {};
        for (var i = level; i >= 0; i--) {
            let temp = curRow.nextUntil("[data-lvl=" + i + "]");
            if (temp.length < count) {
                count = temp.length;
                rows = temp;
            }
        }
        if (isShow) {
            rows.show();
            $(el).children("i").removeClass("fa-plus-square-o").addClass("fa-minus-square-o");
            rows.children().find("i.fa-plus-square-o").removeClass("fa-plus-square-o").addClass("fa-minus-square-o");
        }
        else {
            rows.hide();
            $(el).children("i").removeClass("fa-minus-square-o").addClass("fa-plus-square-o");
        }
    }.bind(this);

    this.AppendTreeModal = function () {
        $("#treemodal").remove();
        let modal1 = `<div class="modal fade" id="treemodal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
    <div class="modal-dialog">
        <div class="treemodal-container">
            <h4 class="treemodal-header">Move <span id="itemorgroup"></span></h4>
            <div class="tree_item_cont">
                <label>From </label>
                <span id="movefrom"></span>
            </div>
            <div class="tree_item_cont">
                <label>To</label>
                <button class="btn treemodalul">Select Group
                <span class="caret"></span></button>
            </div>
            <div class="pull-right">
                <button class="btn" id="treemodal_submit">Move</button>
                <button class="btn" id="treemodal_cancel">Cancel</button>
            </div>
        </div>
    </div>
</div>`;

        $("body").prepend(modal1);
    };

    this.MoveGroupOrItem = function (key, opt, event) {
        this.AppendTreeModal();
        let rowindex = this.Api.row(opt.$trigger.parent().closest("[role=row]")).index();
        this.movefromtext = this.unformatedData[rowindex][this.treeColumn.data];
        if (opt.selector === ".itemform")
            $("#itemorgroup").text("Item : " + this.movefromtext);
        else
            $("#itemorgroup").text("Group : " + this.movefromtext);
        this.IdColumnIndex = this.EbObject.Columns.$values.filter(function (obj) { return obj.name === "id"; })[0].data;
        this.movefromId = this.unformatedData[rowindex][this.IdColumnIndex];
        this.Items = {};
        this.createTreeItems___(this.treeData, this.Items);
        this.Items = this.Items.items;
        this.InitTreemodalContextmenu();
        $("#treemodal").modal("show");
        $("#treemodal_submit").off("click").on("click", this.MoveOKClick.bind(this));
        $("#treemodal_cancel").off("click").on("click", this.MoveCancelClick.bind(this));
    };

    this.createTreeItems___ = function (initems, outitems) {
        $.each(initems, function (_in, _out, i, item) {
            let Exist = item.item.filter(function (obj) { return obj === this.movefromtext; }.bind(this));
            if (Exist.length === 0) {
                if (item.isGroup) {
                    this.ulid = item.item[this.treeColumn.data];
                    if (!_out.hasOwnProperty("items"))
                        _out.items = {};
                    _out.items[this.ulid] = { "name": this.ulid, "data-pid": item.item[this.IdColumnIndex] };
                    this.createTreeItems___(item.children, _out.items[this.ulid]);
                }
            }
            else {
                $("#movefrom").text(outitems.name);
            }
        }.bind(this, initems, outitems));
    };

    this.InitTreemodalContextmenu = function () {
        $.contextMenu('destroy', '.treemodalul');
        $.contextMenu({
            selector: '.treemodalul',
            callback: this.MoveDDClick.bind(this),
            className: 'contextmenu-custom__highlight',
            items: this.Items,
            trigger: "left",
            autoHide: true,
            events: {
                show: function (options) {
                    this.clickCounter = 0;
                    return true;
                }.bind(this)
            }
        });
        this.clickCounter = 0;
        $(".contextmenu-custom__highlight .context-menu-submenu").off("click").on("click", this.MoveDDClick.bind(this));
    };

    this.getClickedItem = function (key) {
        $.each(this.Items, function (i, objOuter) {
            if (objOuter.name === key) {
                this.moveToPid = objOuter["data-pid"];
                return false;
            }
            else {
                if (objOuter.hasOwnProperty("items"))
                    this.getRecursivelyGetClickedItem(key, objOuter);
            }
        }.bind(this));
    };

    this.getRecursivelyGetClickedItem = function (key, objOuter) {
        $.each(objOuter.items, function (i, objInner) {
            if (objInner.name === key) {
                this.moveToPid = objInner["data-pid"];
                return false;
            }
            else {
                if (objInner.hasOwnProperty("items"))
                    this.getRecursivelyGetClickedItem(key, objInner);
            }
        }.bind(this));
    };

    this.MoveDDClick = function (key, options) {
        if (this.clickCounter === 0) {
            if (options === undefined)
                key = $(key.currentTarget).children("span").text();
            let path = $(".contextmenu-custom__highlight .context-menu-visible").children().closest("span").map(function () {
                return $(this).text();
            }).get().join(' > ');
            $("#treemodal .treemodalul").text(path).append('<span class="caret"></span></button>');
            this.getClickedItem(key);
            $(".contextmenu-custom__highlight").hide();
            $(".treemodalul").removeClass("context-menu-active");
            $("#context-menu-layer").remove();
            this.clickCounter++;
        }
    };

    this.MoveOKClick = function () {
        if (this.tableName !== null && this.moveToPid !== null && this.movefromId !== null) {
            let sql = `UPDATE ${this.tableName} SET ${this.treeColumn.ParentColumn.$values[0].name}= ${this.moveToPid}
                        WHERE id=${this.movefromId} `;
            $.ajax({
                type: "POST",
                url: "../DV/ExecuteTreeUpdate",
                data: { sql: sql },
                success: this.UpdateSuccess.bind(this)
            });
        }
        else {
            alert("Select One Group.....");
        }
    };

    this.MoveCancelClick = function () {
        this.clickCounter = 0;
        $("#treemodal").modal("hide");
    };

    this.UpdateSuccess = function () {
        this.$submit.trigger("click");
        $("#treemodal").modal("hide");
        this.clickCounter = 0;
    };

    this.setFilterboxValue = function (i, obj) {
        $(obj).children('div').children('.eb_finput').on("keydown", function (event) {
            if (event.keyCode === $.ui.keyCode.TAB &&
                $(this).autocomplete("instance").menu.active) {
                event.preventDefault();
            }
        });
        var name = $(obj).children('span').text();
        var tempobj = $.grep(this.EbObject.Columns.$values, function (col) { return col.name === name; });
        if (tempobj.length > 0) {
            var idx = tempobj[0].data;
            if (tempobj[0].$type && tempobj[0].$type.indexOf("DVPhoneColumn") !== -1)
                idx = tempobj[0].MappingColumn.data;
        }
        var data = arrayColumn(this.unformatedData, idx);
        data = data.filter(val => val !== null && val !== undefined);
        data = data.filter(function (elem, pos) {
            return data.indexOf(elem) === pos;
        });
        if ($(obj).children('div').children('.eb_finput').attr("data-coltyp") === "string") {
            this.setFilterboxValueInner(obj, data);
        }
        else {
            if ($(obj).children('div').length === 0) {
                var $lctrl = $("#" + this.tableId + "_wrapper .DTFC_LeftHeadWrapper table tr[class=addedbyeb] th:eq(" + i + ")").find(".eb_finput");
                var $rctrl = $("#" + this.tableId + "_wrapper .DTFC_RightHeadWrapper table tr[class=addedbyeb] th:eq(" + i + ")").find(".eb_finput");
                if ($lctrl.length > 0) {
                    this.setfiletrvalueFixedcolumns($lctrl, data);
                }
                if ($rctrl.length > 0) {
                    this.setfiletrvalueFixedcolumns($rctrl, data);
                }
            }

        }
    };

    this.setFilterboxValueInner = function (obj, data) {
        $(obj).children('div').children('.eb_finput').autocomplete({
            source: function (request, response) {
                response($.ui.autocomplete.filter(
                    $.unique(data), extractLast(request.term)));
            }.bind(this),
            focus: function () {
                return false;
            },
            select: function (event, ui) {
                let inp = event.target;
                var terms = splitval($(inp).val());
                terms.pop();
                terms.push(ui.item.value);
                terms.push("");
                $(inp).val(terms.join(" | "));
                if (!this.EbObject.DisableAutoSearch) {
                    var e = $.Event("keyup", { which: 13, keyCode: 13, target: inp });
                    $(inp).trigger(e);
                }
                return false;
            }.bind(this),
            search: function (event, ui) {
            }
        });
    }

    this.setfiletrvalueFixedcolumns = function ($ctrl, data) {
        if ($ctrl.attr("data-coltyp") === "string") {
            $ctrl.autocomplete({
                source: function (request, response) {
                    response($.ui.autocomplete.filter(
                        $.unique(data), extractLast(request.term)));
                }.bind(this),
                focus: function () {
                    return false;
                },
                select: function (event, ui) {
                    var terms = splitval(this.value);
                    terms.pop();
                    terms.push(ui.item.value);
                    terms.push("");
                    this.value = terms.join(" | ");
                    return false;
                },
                search: function (event, ui) {
                }
            });
        }
    };

    this.orderingEvent = function (e) {
        //var col = $(e.target).children('span').text();
        var col = $(e.target).text();
        var tempobj = $.grep(this.Api.settings().init().aoColumns, function (obj) { return obj.sTitle === col; });
        var cls = $(e.target).attr('class');
        if (col !== '' && col !== "#") {
            if (tempobj[0].$type.indexOf("DVPhoneColumn") !== -1)
                this.order_info.col = tempobj[0].MappingColumn.name;
            else
                this.order_info.col = tempobj[0].name;
            this.order_info.dir = (cls.indexOf('sorting_asc') > -1) ? 1 : 0;
            //this.orderColl = $.grep(this.orderColl, function (obj) { return obj.Column !== this.order_info.col }.bind(this));
            //if (this.EbObject.rowGrouping.$values.length === 0)
            //    this.orderColl = [];
            this.orderColl = [];
            this.orderColl.push(new order_obj(this.order_info.col, this.order_info.dir));
        }
    };

    this.GetFiltersFromSettingsTbl = function (zidx) {
        this.zindex = zidx;
        if (this.zindex === 50)
            this.eb_filter_controls_4fc = [];
        else if (this.zindex === 1)
            this.eb_filter_controls_4sb = [];

        //$.each(this.EbObject.Columns.$values, this.GetFiltersFromSettingsTbl_inner.bind(this));
        $.each(this.Api.settings().init().aoColumns, this.GetFiltersFromSettingsTbl_inner.bind(this));
    };

    this.GetFiltersFromSettingsTbl_inner = function (i, col) {
        var _ls = "";

        if (col.bVisible === true) {
            var span = "<span hidden>" + col.name + "</span>";
            //var span = "";

            var htext_class = this.tableId + "_htext";

            var data_colum = "data-colum='" + col.name + "'";
            var data_table = "data-table='" + this.tableId + "'";

            var header_select = this.tableId + "_" + col.name + "_hdr_sel";
            var header_text1 = this.tableId + "_" + col.name + "_hdr_txt1";
            var header_text2 = this.tableId + "_" + col.name + "_hdr_txt2";

            _ls += "<th>";
            if (col.name === "serial") {
                _ls += (span + "<a class='btn btn-sm center-block'  id='clearfilterbtn_" + this.tableId + "' data-table='@tableId' data-toggle='tooltip' title='Clear Filter' style='height:100%'><i class='fa fa-filter' aria-hidden='true' style='color:black'></i></a>");
            }
            else if (col.$type && col.$type.indexOf("DVPhoneColumn") !== -1) {
                data_colum = "data-colum='" + col.MappingColumn.name + "'";
                _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
            }
            else if (col.IsCustomColumn) {
                _ls += span;
            }
            else {
                if (col.RenderType === parseInt(gettypefromString("Int32")) || col.RenderType === parseInt(gettypefromString("Decimal")) || col.RenderType === parseInt(gettypefromString("Int64")) || col.RenderType == parseInt(gettypefromString("Double")) || col.RenderType == parseInt(gettypefromString("Numeric"))) {
                    if (parseInt(EbEnums.ControlType.Text) === col.filterControl)
                        _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else if (parseInt(EbEnums.ControlType.Date) === col.filterControl)
                        _ls += (span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else
                        _ls += (span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                }
                else if (col.RenderType === parseInt(gettypefromString("String"))) {
                    //if (this.dtsettings.filterParams === null || this.dtsettings.filterParams === undefined)
                    if (parseInt(EbEnums.ControlType.Numeric) === col.filterControl)
                        _ls += (span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else if (parseInt(EbEnums.ControlType.Date) === col.filterControl)
                        _ls += (span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else
                        _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    //else
                    //   _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, this.dtsettings.filterParams));
                }
                else if (col.RenderType === parseInt(gettypefromString("DateTime")) || col.RenderType === parseInt(gettypefromString("Date"))) {
                    if (parseInt(EbEnums.ControlType.Numeric) === col.filterControl)
                        _ls += (span + this.getFilterForNumeric(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else if (parseInt(EbEnums.ControlType.Text) === col.filterControl)
                        _ls += (span + this.getFilterForString(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                    else
                        _ls += (span + this.getFilterForDateTime(header_text1, header_select, data_table, htext_class, data_colum, header_text2, this.zindex, col.DefaultOperator));
                }
                else if (col.RenderType === parseInt(gettypefromString("Boolean")) && col.name !== "checkbox")
                    _ls += (span + this.getFilterForBoolean(col.name, this.tableId, this.zindex));
                else
                    _ls += (span);
            }

            _ls += ("</th>");

            ((this.zindex === 50) ? this.eb_filter_controls_4fc : this.eb_filter_controls_4sb).push(_ls);
        }
    };

    this.getFilterForNumeric = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx, DefOp) {
        var coltype = "data-coltyp='number'";
        var drptext = "";
        var op = String.empty;
        switch (DefOp.toString()) {
            case EbEnums.NumericOperators.Equals: op = '='; break;
            case EbEnums.NumericOperators.LessThan: op = '<'; break;
            case EbEnums.NumericOperators.GreaterThan: op = '>'; break;
            case EbEnums.NumericOperators.LessThanOrEqual: op = '<='; break;
            case EbEnums.NumericOperators.GreaterThanOrEqual: op = '>='; break;
            case EbEnums.NumericOperators.Between: op = 'B'; break;
            default: op = '=';
        }
        drptext = "<div class='input-group input-group-sm'>" +
            "<div class='input-group-btn'>" +
            " <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'> " + op + " </button>" +
            " <ul class='dropdown-menu'>" +//  style='z-index:" + zidx.toString() + "'
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> = </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Equal to</span></li>" +
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> < </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Less than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> > </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Greater than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> <= </a><span class='filtertext eb_fsel" + this.tableId + "'> Less than or Equal</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> >= </a><span class='filtertext eb_fsel" + this.tableId + "'> Greater than or Equal</span></li>" +
            "<li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> B </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Between</span></li>" +
            " </ul>" +
            " </div>" +
            " <input type='number' data-toggle='tooltip' class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            //" <span class='input-group-btn'></span>" +
            //" <input type='number' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return drptext;
    };

    this.getFilterForDateTime = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx, DefOp) {
        var op = String.empty;
        switch (DefOp.toString()) {
            case EbEnums.NumericOperators.Equals: op = '='; break;
            case EbEnums.NumericOperators.LessThan: op = '<'; break;
            case EbEnums.NumericOperators.GreaterThan: op = '>'; break;
            case EbEnums.NumericOperators.LessThanOrEqual: op = '<='; break;
            case EbEnums.NumericOperators.GreaterThanOrEqual: op = '>='; break;
            case EbEnums.NumericOperators.Between: op = 'B'; break;
            default: op = '=';
        }
        var coltype = "data-coltyp='date'";
        var filter = "<div class='input-group input-group-sm'>" +
            "<div class='input-group-btn'>" +
            " <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'> " + op + " </button>" +
            "<ul class='dropdown-menu'>" +//  style='z-index:" + zidx.toString() + "'
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> = </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Equal to</span></li>" +
            " <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> < </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Less than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> > </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Greater than</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> <= </a><span class='filtertext eb_fsel" + this.tableId + "'> Less than or Equal</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> >= </a><span class='filtertext eb_fsel" + this.tableId + "'> Greater than or Equal</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> B </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 6px;'> Between</span></li>" +
            " </ul>" +
            " </div>" +
            " <input type='text' placeholder='&#xf073;' data-toggle='tooltip' class='no-spin form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            //" <span class='input-group-btn'></span>" +
            //" <input type='date' class='form-control eb_finput " + htext_class + "' id='" + header_text2 + "' style='visibility: hidden' " + data_table + data_colum + coltype + ">" +
            " </div> ";

        return filter;

    };

    this.getFilterForString = function (header_text1, header_select, data_table, htext_class, data_colum, header_text2, zidx, DefOp) {
        var op = String.empty;
        switch (DefOp.toString()) {
            case EbEnums.StringOperators.Equals: op = '='; break;
            case EbEnums.StringOperators.Startwith: op = 'x*'; break;
            case EbEnums.StringOperators.EndsWith: op = '*x'; break;
            case EbEnums.StringOperators.Between: op = '*x*'; break;
            case EbEnums.StringOperators.Contains: op = '*x*'; break;
            default: op = '=';
        }
        var coltype = " data-coltyp='string'";
        var drptext = "";
        drptext = "<div class='input-group input-group-sm'>" +
            "<div class='input-group-btn'>" +// style='z-index:" + zidx.toString() + "'
            " <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown' id='" + header_select + "'>" + op + "</button>" +
            " <ul class='dropdown-menu'>" +

            "   <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> x* </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 5px;'> Starts with</span></li>" +
            "  <li class='filterli'><a href ='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> *x </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 5px;'> Ends with</span></li>" +
            "  <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> *x* </a><span class='filtertext eb_fsel" + this.tableId + "' > Contains</span></li>" +
            " <li class='filterli'><a href='#' class='eb_fsel" + this.tableId + "' " + data_table + data_colum + "> = </a><span class='filtertext eb_fsel" + this.tableId + "' style='margin-left: 9px;'> Exact match</span></li>" +
            " </ul>" +
            " </div>" +
            " <input type='text' data-toggle='tooltip'  class='form-control eb_finput " + htext_class + "' id='" + header_text1 + "' " + data_table + data_colum + coltype + ">" +
            " </div> ";
        return drptext;
    };

    this.getFilterForBoolean = function (colum, tableId, zidx) {
        var filter = "";
        var id = tableId + "_" + colum + "_hdr_txt1";
        var cls = tableId + "_hchk";
        filter = "<input type='checkbox' id='" + id + "' data-toggle='tooltip' title='' data-colum='" + colum + "' data-coltyp='boolean' data-table='" + tableId + "' class='" + cls + " " + tableId + "_htext eb_fbool" + this.tableId + "' style='margin-left: 50%;'></center>";
        return filter;
    };

    this.clearFilter = function () {
        var flag = false;
        var tableid = this.tableId;
        $('.' + this.tableId + '_htext').each(function (i) {

            if ($(this).hasClass(tableid + '_hchk')) {
                if (!($(this).is(':indeterminate'))) {
                    flag = true;
                    $(this).prop("indeterminate", true);
                }
            }
            else {
                if ($(this).val() !== '') {
                    flag = true;
                    $(this).val('');
                }
            }
        });
        if (flag || this.filterFlag) {
            this.columnSearch = [];
            this.Api.ajax.reload();
            this.filterFlag = false;
            $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-times").addClass("fa-filter");
            $(".tooltip").remove();
        }
    };

    this.setLiValue = function (e) {
        let elemnt = ($(e.target).is("a")) ? $(e.target) : $(e.target).siblings("a");
        var selText = $(elemnt).text();
        var table = $(elemnt).attr('data-table');
        var flag = false;
        var colum = $(elemnt).attr('data-colum');
        var ctype = $(elemnt).parents('.input-group').find("input").attr('data-coltyp');
        var dateclas = (ctype === "date") ? "no-spin" : "";
        $(elemnt).parents('.input-group-btn').find('.dropdown-toggle').html(selText);
        if (selText.trim() === 'B') {
            if ($(elemnt).parents('.input-group').find("input").length == 1) {
                if (ctype === "date") {
                    $(elemnt).parents('.input-group').append("<input type='text' placeholder='&#xf073;' class='" + dateclas + " between-inp form-control eb_finput " + this.tableId + "_htext' id='" + this.tableId + "_" + colum + "_hdr_txt2' data-coltyp='" + ctype + "'>");
                    $("#" + this.tableId + "_" + colum + "_hdr_txt2").datepicker({
                        dateFormat: this.datePattern.replace(new RegExp("M", 'g'), "m").replace(new RegExp("yy", 'g'), "y"),
                        beforeShow: function (elem, obj) {
                            $(".ui-datepicker").addClass("datecolumn-picker");
                        },
                        onSelect: function (d, i) {
                            if (d !== i.lastVal)
                                this.call_filter({ keyCode: 10 });
                        }.bind(this)
                    });
                    $("#" + this.tableId + "_" + colum + "_hdr_txt2").on("click", function () {
                        $(this).datepicker("show");
                    });
                }
                else {
                    $(e.target).parents('.input-group').append("<input type='number' class='" + dateclas + " between-inp form-control eb_finput " + this.tableId + "_htext' id='" + this.tableId + "_" + colum + "_hdr_txt2' data-coltyp='" + ctype + "'>");
                }
                $("#" + this.tableId + "_" + colum + "_hdr_txt1").addClass("between-inp");
                $("#" + this.tableId + "_" + colum + "_hdr_txt2").on("keyup", this.call_filter);

            }
        }
        else if (selText.trim() !== 'B') {
            if ($(elemnt).parents('.input-group').find("input").length == 2) {
                $(elemnt).parents('.input-group').find("input").eq(1).remove();
                $("#" + this.tableId + "_" + colum + "_hdr_txt1").removeClass("between-inp");
            }
        }

        this.Api.columns.adjust();
        e.preventDefault();
    };

    this.call_filter = function (e) {
        if (e.keyCode === 13) {
            var flag = true;
            if ($(e.target).siblings(".eb_finput").length === 1) {
                if ($(e.target).val() === "") {
                    $(e.target).css("border-color", "red");
                    flag = false;
                }
                else
                    $(e.target).css("border-color", "#ccc");
                if ($(e.target).siblings(".eb_finput").val() === "") {
                    $(e.target).siblings(".eb_finput").css("border-color", "red");
                    flag = false;
                }
                else
                    $(e.target).siblings(".eb_finput").css("border-color", "#ccc");
            }
            else {
                if ($(e.target).val().trim() == "") {
                    flag = false;
                    $(e.target).css("border-color", "red");
                }
                else
                    $(e.target).css("border-color", "#ccc");
            }
            if ($(e.target).data('ui-autocomplete') != undefined)
                $(e.target).autocomplete('close');

            if (flag) {
                this.reloadDataTable();
            }
        }
        else if (!this.EbObject.DisableAutoSearch) {
            $("[data-coltyp=date]").datepicker("hide");
            if (typeof (e.key) === "undefined") {
                this.reloadDataTable();
            }
            else {
                let nam = $(e.target).attr('data-colum');
                let obj = this.columnSearch.find(e => e.Column === nam);
                if ((obj && obj.Value != $(e.target).val().trim()) || !obj) {
                    clearTimeout(this.realoadDtTimer);
                    this.realoadDtTimer = setTimeout(function (e) {
                        let ac = $(e.target).data('ui-autocomplete');
                        if ((ac && $(ac.menu.activeMenu[0]).is(':visible')) || !ac)
                            return;
                        this.reloadDataTable(e);
                    }.bind(this, e), 1500);
                }
            }
        }

    }.bind(this);

    this.reloadDataTable = function (e) {
        let filter = this.repopulate_filter_arr();
        if (JSON.stringify(filter) != JSON.stringify(this.columnSearch)) {
            this.columnSearch = filter;
            $('#' + this.tableId).DataTable().ajax.reload();
            if ($('#clearfilterbtn_' + this.tableId).children("i").hasClass("fa-filter"))
                $('#clearfilterbtn_' + this.tableId).children("i").removeClass("fa-filter").addClass("fa-times");
        }
    };

    this.dblclickDateColumn = function () {
        this.type = "text";
        this.select();
    };

    this.pasteDateColumn = function (e) {
        var data = e.originalEvent.clipboardData.getData('Text');
        var dt = data.split("/");
        this.value = [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("-");
        e.preventDefault();
    };

    this.focusoutDateColumn = function () {
        var data = $(event.target)[0].value;
        var dt = data.split("/");
        if (dt.length === 1)
            dt = data.split("-");
        if (dt[0].length <= 2)
            data = [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("-");
        else
            data = [dt[0].trim(), dt[1].trim(), dt[2].trim()].join("-");
        $(event.target)[0].value = formatDate(data);
        $(event.target)[0].type = "date";
        if (this.Api)
            this.Api.columns.adjust();
    };

    this.changeDateOrder = function (data) {
        var dt = data.split("/");
        var dtp = this.datePattern.split("/");
        if (dt.length === 1)
            dt = data.split("-");
        if (dtp.length === 1)
            dtp = this.datePattern.split("-");

        if (dt[0].length <= 2)
            return [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("-");
        else
            return [dt[0].trim(), dt[1].trim(), dt[2].trim()].join("-");
    };

    this.retainDateOrder = function (data) {
        var dt = data.split("-");
        return [dt[2].trim(), dt[1].trim(), dt[0].trim()].join("/");
    };

    this.toggleInFilter = function (e) {
        var table = $(e.target).attr('data-table');
        this.call_filter({ keyCode: 10 });
        //this.Api.ajax.reload();
    };

    this.togglePG = function (e) {
        $(".ppcont").toggle('drop', { direction: 'right' }, 150);
        if ($(".ppcont").is(":visible"))
            $(".filterCont").hide();
        e.stopPropagation();
    };

    this.fselect_func = function (e) {
        let element = ($(e.target).is("a")) ? $(e.target) : $(e.target).siblings("a");
        var opScroll = $(element).text().trim();
        $(element).parents('.input-group-btn').find('.dropdown-toggle').html(opScroll);
        $.each(this.eb_agginfo, function (index, agginfo) {
            if (agginfo.colname) {
                ftrtxtScroll = '.dataTables_scrollFootInner #' + this.tableId + '_' + agginfo.colname + '_ftr_txt0';
                ftrtxtLF = '.DTFC_LeftFootWrapper #' + this.tableId + '_' + agginfo.colname + '_ftr_txt0';
                ftrtxtRF = '.DTFC_RightFootWrapper #' + this.tableId + '_' + agginfo.colname + '_ftr_txt0';

                var col = this.Api.column(agginfo.colname + ':name');
                var summary_val = 0;
                if (opScroll === '') {
                    if (this.Source === "datagrid")
                        summary_val = col.data().sum().toFixed(agginfo.deci_val);
                    else
                        summary_val = (typeof this.summary[agginfo.data] !== "undefined") ? this.summary[agginfo.data][0] : 0;
                }
                if (opScroll === 'x') {
                    if (this.Source === "datagrid")
                        summary_val = col.data().average().toFixed(agginfo.deci_val);
                    else
                        summary_val = (typeof this.summary[agginfo.data] !== "undefined") ? this.summary[agginfo.data][1] : 0;
                }
                if (opScroll !== "")
                    $(ftrtxtScroll).text(summary_val);
            }
        }.bind(this));
        e.preventDefault();
    };

    this.clickAlSlct = function (e) {
        //var tableid = $(e.target).attr('data-table');
        if (e.target.checked)
            $('#' + this.tableId + '_wrapper tbody [type=checkbox]:not(:checked)').trigger('click');
        else
            $('#' + this.tableId + '_wrapper tbody [type=checkbox]:checked').trigger('click');

        e.stopPropagation();
    };

    this.renderCheckBoxCol = function (data2, type, row, meta) {
        if (this.FlagPresentId) {
            this.hiddenIndex = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.name.toLocaleLowerCase() === this.hiddenFieldName.toLocaleLowerCase(); }.bind(this))[0].data;
            this.rowId = meta.row; //do not remove - for updateAlSlct
            if (row[this.hiddenIndex])
                return "<input type='checkbox' class='" + this.tableId + "_select' name='" + this.tableId + "_id' value='" + row[this.hiddenIndex].toString() + "'/>";
            else
                return "<input type='checkbox' class='" + this.tableId + "_select'/>";
        }
        else
            return "<input type='checkbox' class='" + this.tableId + "_select'/>";
    };

    this.updateAlSlct = function (e) {
        var idx = this.Api.row($(e.target).parent().parent()).index();
        let $group = $(e.target).closest("tr").prevAll(".group").eq(0);
        if (e.target.checked) {
            this.Api.rows(idx).select();
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", true);
        }
        else {
            this.Api.rows(idx).deselect();
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", true);
        }
        $group.find('.' + this.tableId + '_rowgroupheadercheckbox').prop("indeterminate", true);

        var CheckedCount = $('.' + this.tableId + '_select:checked').length;
        var UncheckedCount = this.Api.rows().count() - CheckedCount;
        if (CheckedCount === this.Api.rows().count()) {
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", false);
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop('checked', true);
        }
        else if (UncheckedCount === this.Api.rows().count()) {
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop("indeterminate", false);
            $('#' + this.tableId + '_wrapper table:eq(0) thead tr:eq(0) [type=checkbox]').prop('checked', false);
        }
        if ($group.length === 1) {
            let groupnum = $group.attr("group");
            for (let i = parseInt(groupnum); i >= 1; i--) {
                let $elems = $group.nextUntil("[group=" + i + "]").filter(".odd,.even");
                let checkCount = $elems.find('.' + this.tableId + '_select:checked').length;
                $group.find(".rowgrouprowcount").empty();
                if (checkCount > 0)
                    $group.find(".rowgrouprowcount").html("&nbsp;" + checkCount + " rows selected");
                if ($elems.length === checkCount) {
                    $group.find('.' + this.tableId + '_rowgroupheadercheckbox').prop("indeterminate", false);
                    $group.find('.' + this.tableId + '_rowgroupheadercheckbox').prop("checked", true);
                }
                else {
                    $group.find('.' + this.tableId + '_rowgroupheadercheckbox').prop("indeterminate", false);
                    $group.find('.' + this.tableId + '_rowgroupheadercheckbox').prop("checked", false);
                }
                $group = $group.prevAll(".group[group=" + (i - 1) + "]").eq(0);
            }
        }
        let rowdata = this.unformatedData[idx];
        if (Option.CheckboxClickCallback)
            Option.CheckboxClickCallback(e, rowdata);
    };

    this.showOrHideAggrControl = function (e) {
        $('#' + this.tableId + '_wrapper .dataTables_scrollFootInner tfoot tr:eq(0)').toggle();
        $("#" + this.tableId + "_wrapper .DTFC_LeftFootWrapper tfoot tr:eq(0)").toggle();
        $("#" + this.tableId + "_wrapper .DTFC_RightFootWrapper tfoot tr:eq(0)").toggle();
        this.Api.columns.adjust();
    };

    this.linkFromCalendar = function (e) {
        this.popup = true;
        var rows = this.Api.rows(idx).nodes();
        this.linkDV = this.ObjectLinks[0].ObjRefId; //$(e.target).closest("a").attr("data-link");
        colindex = parseInt($(e.target).closest("a").attr("idx"));
        var idx = this.Api.row($(e.target).parents().closest("td")).index();
        let col = this.columns[colindex];

        if (parseInt(this.linkDV.split("-")[2]) !== EbObjectTypes.WebForm) {
            $(".tableviewpopupmodal").remove();
            $("body").append(`
            <div class="modal fade tableviewpopupmodal" id="popupmodalContainer${this.tableId}" role="dialog" >
                <div class="modal-dialog" style="width: 95%; height: 95%;">
                    <div class="modal-content" style="height: 100%; overflow-y: auto;">
                        <div class="modal-header">
                                <div id ="popupheader${this.tableId}">
                                     <button type="button" class="close" data-dismiss="modal">&times;</button> 
                                </div>                           
                        </div>
                            <div id="tblpopup"></div>
                        <div class="modal-body"> <div id='content_popupmodal${this.tableId}'><table class='table display table-bordered compact' id="popupmodal${this.tableId}"></table></div></div>
                    </div>
                </div>
            </div>
            `);

            $(`#popupmodalContainer${this.tableId}`).modal('show');
            $(`#tblpopup`).EbLoader("show", { maskItem: { Id: "body" } });
            if (typeof (idx) !== "undefined")
                this.rowData = this.unformatedData[idx];
            else {//incomplete...
                this.rowData = [];
            }
            this.filterValues = this.getFilterValues();
            let rowfilter = this.getfilterFromRowdata().find(ele => ele.Name === "id");
            this.filterValues[this.filterValues.findIndex(ele => ele.Name === "id")].Value = rowfilter.Value;
            this.filterValues[0].Value = col.StartDT;
            this.filterValues[1].Value = col.EndDT;
            let source = "Calendar";

            this.call2newDv(rows, idx, colindex, source);
        }
        else {
            this.filterValuesforForm = this.getfilterFromRowdata();
            CallWebFormCollectionRender({
                _source: 'tv',
                _refId: this.linkDV,
                _params: btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))),
                _mode: 1,
                _locId: ebcontext.locations.CurrentLoc
            });
        }
    };

    this.link2NewTable = function (e) {
        this.rowgroupFilter = [];
        var rows = this.Api.rows(idx).nodes();
        var cData;
        var colindex = -1;
        this.isContextual = true;
        if ($(e.target).closest("a").attr("data-latlong") !== undefined)
            cData = $(e.target).closest("a").attr("data-latlong");
        else if ($(e.target).closest("a").attr("data-inline") !== undefined) {
            cData = $(e.target).closest("a").attr("data-data");
            this.inline = true;
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        else if ($(e.target).closest("a").attr("data-popup") !== undefined) {
            cData = $(e.target).closest("a").attr("data-data");
            this.popup = true;
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        else if ($(e.target).closest("a").attr("data-linkfromcolumn") !== undefined) {
            cData = $(e.target).text();
            this.linkfromcolumn = true;
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        else {
            cData = $(e.target).text();
            colindex = parseInt($(e.target).closest("a").attr("data-colindex"));
        }
        this.linkDV = $(e.target).closest("a").attr("data-link");
        this.linkDVColumn = $(e.target).closest("a").attr("data-column");
        var idx = this.Api.row($(e.target).closest("tr")).index();
        if (typeof (idx) !== "undefined")
            this.rowData = this.unformatedData[idx];
        else {//incomplete...
            this.rowData = [];
        }
        var x = this.getStaticParameter(colindex);
        this.filterValuesforForm = [];
        if (parseInt(this.linkDV.split("-")[2]) !== EbObjectTypes.WebForm)
            this.filterValues = this.getFilterValues().concat(this.getfilterFromRowdata()).concat(x);
        else if (this.linkfromcolumn)
            this.filterValuesforForm = this.getFilterForLinkfromColumn();
        else
            this.filterValuesforForm = this.getfilterFromRowdata();

        if ($(e.target).parent("b").attr("data-rowgroup") !== undefined) {

            this.getRowGroupFilter($(e.target).parent("b"));
            if (this.CurrentRowGroup.$type.indexOf("SingleLevelRowGroup") !== -1) {
                $.each($(e.target).parent("b").siblings("b"), function (i, elem) {
                    this.getRowGroupFilter($(elem));
                }.bind(this));
            }
            else {
                var $elem = $(e.target).parents().closest(".group");
                let count = $elem.attr("group");
                for (var i = count - 1; i >= 0; i--) {
                    $elem = $(e.target).parents().closest(".group").prevAll().closest(".group[group=" + i + "]").last();
                    this.getRowGroupFilter($elem.children().find("b"));
                }
            }

            this.filterValues = this.filterValues.concat(this.rowgroupFilter);
        }

        if (this.inline) {
            this.inline = false;
            if ($(rows).eq(idx).next().attr("id") !== "containerrow" + colindex) {
                this.drawInlinedv(rows, e, idx, colindex);
            }
            else {
                this.OpenInlineDv(rows, e, idx, colindex);
            }
        }
        else if (this.popup) {
            this.popup = false;
            CallWebFormCollectionRender({
                _source: 'tv',
                _refId: this.linkDV,
                _params: btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))),
                _mode: this.dvformMode,
                _locId: ebcontext.locations.CurrentLoc
            });
            //$("#iFrameFormPopupModal").modal("show");
            //let url = `../WebForm/Index?_r=${this.linkDV}&_p=${btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm))))}&_m=1${this.dvformMode}&_l=${ebcontext.locations.CurrentLoc}`;
            //$("#iFrameFormPopup").attr("src", url);
        }
        else {
            if (this.login === "uc")
                dvcontainerObj.drawdvFromTable(btoa(unescape(encodeURIComponent(JSON.stringify(this.rowData)))), btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues)))), btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))), cData.toString(), this.dvformMode);//, JSON.stringify(this.filterValues)
            else
                this.OpeninNewTab(idx, cData);
        }
        //this.filterValues = [];
    };

    this.link2NewTableFromColumn = function (e) {
        this.linkDV = $(e.target).closest("a").attr("data-link");
        let Paramvalue = $(e.target).closest("a").attr("data-id");
        this.filterValuesforForm = [];
        this.filterValuesforForm.push(new fltr_obj(11, "id", Paramvalue));
        this.dvformMode = 1;
        if (this.login === "uc")
            dvcontainerObj.drawdvFromTable(btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValuesforForm)))), cData.toString(), this.dvformMode);//, JSON.stringify(this.filterValues)
        else
            this.OpeninNewTab(this.Api.row($(e.target).parents().closest("td")).index(), $(e.target).text());
    };

    this.drawInlinedv = function (rows, e, idx, colindex) {
        this.showEbLoader();
        $(e.target).parents().closest("td").siblings().children(".tablelink").children("i").removeClass("fa-caret-up").addClass("fa-caret-down");
        this.call2newDv(rows, idx, colindex);
        $(e.target).closest("I").removeClass("fa-caret-down").addClass("fa-caret-up");
    };

    this.OpenInlineDv = function (rows, e, idx, colindex) {
        if ($(e.target).closest("I").hasClass("fa-caret-up")) {
            $(e.target).closest("I").removeClass("fa-caret-up").addClass("fa-caret-down");
            $(rows).eq(idx).next().hide();
        }
        else {
            $(e.target).closest("I").removeClass("fa-caret-down").addClass("fa-caret-up");
            $(rows).eq(idx).next().show();
        }
        this.Api.columns.adjust();
    };

    this.ExecuteApproval = function ($td, action, e) {
        //$("#eb_common_loader").EbLoader("show");
        if ($(e.target).attr('action-clicked') == 'true') {// to avoid multi click
            console.warn('multi click blocked');
            return;
        }
        $(e.target).attr('action-clicked', 'true');
        let val, comments;
        if (action === 'reset') {
            comments = $(e.target).closest("#resetstage").find(".comment-text").val();
            if (!comments.trim()) {
                EbMessage("show", { Message: "Comments required to complete the review", Background: "#e40707", AutoHide: true, Delay: 3000 });
                $(e.target).attr('action-clicked', 'false');
                return;
            }
            val = $(e.target).attr("data-json");
            val = JSON.parse(atob(val));
        }
        else {
            comments = $(e.target).closest("#action").find(".comment-text").val();
            let req = $(e.target).closest("#action").find(".selectpicker :selected").attr('req');
            if (!comments.trim() && req === 'y') {
                EbMessage("show", { Message: "Comments required to complete the review", Background: "#e40707", AutoHide: true, Delay: 3000 });
                $(e.target).attr('action-clicked', 'false');
                return;
            }
            val = $(e.target).closest("#action").find(".selectpicker").val();
            val = JSON.parse(atob(val));
        }
        if ($td.find('.btn-approval_popover:visible').length === 0)
            return;
        $td.find('.btn-approval_popover').popover('hide');
        $td.find('.btn-approval_popover').popover('destroy');
        $td.find('.btn-approval_popover i').removeClass('fa-history').removeClass('fa-pencil').addClass('fa-spinner fa-pulse');

        let Columns = [];
        Columns.push(new fltr_obj(16, "stage_unique_id", val.Stage_unique_id.toString()));
        Columns.push(new fltr_obj(16, "action_unique_id", val.Action_unique_id.toString()));
        Columns.push(new fltr_obj(7, "eb_my_actions_id", val.My_action_id.toString()));
        Columns.push(new fltr_obj(16, "comments", comments));
        $.ajax({
            type: "POST",
            url: "../dv/PostWebformData",
            data: { Params: Columns, RefId: val.Form_ref_id, RowId: val.Form_data_id, CurrentLoc: ebcontext.locations.CurrentLoc },
            success: this.cccccc.bind(this, $td),
            error: function ($td, xhr, error) {
                console.log(xhr); console.log(error);
                console.debug(xhr); console.debug(error);
                this.cccccc.bind(this, $td, { messaage: 'Something went wrong ### error' })();
            }.bind(this, $td),
        });
    };

    this.cccccc = function ($td, resp) {
        if (!(resp._data)) {
            let msg = resp.messaage;
            console.error(msg);
            $td.find('.btn-approval_popover').attr('title', msg.includes(' ### ') ? msg.split(' ### ')[0] : msg);
            $td.find('.btn-approval_popover i').removeClass('fa-spinner fa-pulse').addClass('fa-exclamation-circle').attr('style', 'color: red !important;');
            //return;
        }
        else {
            $td.html(resp._data);
            //if ($td.find(".status-label").text() === "Review Completed")
            //    EbMessage("show", { Message: "Review Completed", Background: "#00AD6E" });
            var cell = this.Api.cell($td);
            cell.data($td.html());
        }

        let $popoverBtn = $td.find('.btn-approval_popover');

        $popoverBtn.popover({
            container: 'body',
            trigger: 'click',
            placement: this.ApprovalPopoverPlacement,
            html: true,
            template: '<div class="popover approval-popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
            content: function (e, i) {
                return atob($(this).attr("data-contents"));
            },
        });

        $popoverBtn.off('shown.bs.popover').on('shown.bs.popover', function (e) {
            $(".stage_actions").selectpicker();
            let $td = $(e.target).closest("td.tdheight");
            $(".btn-action_execute").off("click").on("click", this.ExecuteApproval.bind(this, $td, 'execute'));
            $(".btn-action_reset").off("click").on("click", this.ExecuteApproval.bind(this, $td, 'reset'));
        }.bind(this));

        $popoverBtn.off('hidden.bs.popover').on('hidden.bs.popover', function (e) {
            $(e.target).data("bs.popover").inState.click = false;
        }.bind(this));

        //$("#eb_common_loader").EbLoader("hide");
    };

    this.getRowGroupFilter = function ($elem) {
        let name = $elem.attr("data-colname");
        let type = parseInt($elem.attr("data-coltype"));
        let val = $elem.attr("data-data");
        if (type === 5 || type === 6)
            val = val.split("/").join('-');
        this.rowgroupFilter.push(new fltr_obj(type, name, val));
    };

    this.call2newDv = function (rows, idx, colindex, source) {
        $.ajax({
            type: "POST",
            url: "../DV/getdv",
            data: { refid: this.linkDV },
            success: this.GetData4InlineDv.bind(this, rows, idx, colindex, source),
            error: function (req, status, xhr) {
            }
        });
    };

    this.GetData4InlineDv = function (rows, idx, colindex, source, result) {
        var Dvobj = JSON.parse(result).DsObj;
        var param = this.Params4InlineTable(Dvobj, idx, source);
        $.ajax({
            type: "POST",
            url: "../DV/getData",
            data: param,
            success: this.LoadInlineDv.bind(this, rows, idx, Dvobj, colindex, source),
            error: function (req, status, xhr) {
            }
        });
    };

    this.LoadInlineDv = function (rows, idx, Dvobj, colindex, source, result) {
        if (this.popup) {
            $("#popupheader" + this.tableId).append(`
               <div class="popup-header-name">
                    ${Dvobj.DisplayName}
               </div>
               <div>
                   Range :  ${moment(new Date(this.filterValues[0].Value)).format('DD-MMM-YYYY') + " - " + moment(new Date(this.filterValues[1].Value)).format('DD-MMM-YYYY')}
               </div>
            `);

            this.RenderTableviewAsPopup(Dvobj, result);
        }
        else {
            let colspan = Dvobj.Columns.$values.length;
            let str = "";
            $.each(this.rowgroupCols, function (k, obj) {
                str += "<td>&nbsp;</td>";
            });
            $.each(this.extraCol, function (k, obj) {
                if (obj.bVisible)
                    str += "<td>&nbsp;</td>";
            });

            $(rows).eq(idx).next(".containerrow").remove();
            if (Dvobj.$type.indexOf("EbTableVisualization") !== -1) {
                $(rows).eq(idx).after("<tr class='containerrow' id='containerrow" + colindex + "'>" + str + "<td colspan='" + colspan + "'><div class='inlinetable '><div class='close' type='button' title='Close'>x</div><div class='Obj_title' id='objName" + idx + "'>" + Dvobj.DisplayName + "</div><div id='content_tbl" + idx + "'><table id='tbl" + idx + "' class='table display table-bordered compact'></table></div></td></tr></div>");

                var o = new Object();
                o.tableId = "tbl" + idx;
                o.showFilterRow = false;
                o.showSerialColumn = true;
                o.showCheckboxColumn = false;
                o.Source = "inline";
                o.scrollHeight = "200px";
                o.dvObject = Dvobj;
                o.data = result;
                o.keys = false;
                o.IsPaging = false;
                o.filterValues = btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))));
                this.datatable = new EbCommonDataTable(o);
                if (this.EbObject.DisableRowGrouping || this.EbObject.RowGroupCollection.$values.length === 0)
                    $(".inlinetable").css("width", $(window).width() - 115);
                else
                    $(".inlinetable").css("width", $(window).width() - 175);
                this.datatable.Api.columns.adjust();
            }
            else {
                $(rows).eq(idx).after("<tr class='containerrow' id='containerrow" + colindex + "'>" + str + "<td colspan='" + colspan + "'><div class='inlinetable'><div class='close' type='button' title='Close'>x</div><div class='Obj_title' id='objName" + idx + "'>" + Dvobj.DisplayName + "</div><div id='canvasDivchart" + idx + "' ></div></td></tr></div>");
                o = new Object();
                o.tableId = "chart" + idx;
                o.dvObject = Dvobj;
                o.data = result.data;
                this.chartApi = new EbBasicChart(o);
                $(".inlinetable").css("height", "380px");
                $("#canvasDivchart" + idx).css("width", $(window).width() - 100);
                $("#canvasDivchart" + idx).css("height", "inherit");
            }
            $(".containerrow .close").off("click").on("click", function (e) {
                $(e.target).parents().closest(".containerrow").prev().children().find("I").removeClass("fa-caret-up").addClass("fa-caret-down");
                $(e.target).parents().closest(".containerrow").remove();
                this.Api.columns.adjust();
            }.bind(this));
        }
        if (source === "Calendar")
            $("#tblpopup").EbLoader("hide");
        else
            this.hideEbLoader();

        this.Api.columns.adjust();
    };

    this.RenderTableviewAsPopup = function (Dvobj, result) {
        var o = new Object();
        o.tableId = `popupmodal${this.tableId}`;
        o.showFilterRow = false;
        o.showSerialColumn = true;
        o.showCheckboxColumn = false;
        o.Source = "popup";
        //o.scrollHeight = "200px";
        o.dvObject = Dvobj;
        o.data = result;
        o.keys = false;
        o.IsPaging = false;
        o.filterValues = btoa(unescape(encodeURIComponent(JSON.stringify(this.filterValues))));
        this.datatable = new EbCommonDataTable(o);
        this.popup = false;
        this.datatable.Api.columns.adjust();
    };

    this.Params4InlineTable = function (Dvobj, idx, source) {
        var dq = new Object();
        dq.RefId = Dvobj.DataSourceRefId;
        dq.TFilters = [];
        dq.Params = this.filterValues;
        dq.Start = 0;
        dq.Length = 500;
        dq.DataVizObjString = JSON.stringify(Dvobj);
        if (source === "Calendar")
            dq.TableId = `popupmodal${this.tableId}`;
        else
            dq.TableId = "tbl" + idx;
        if (Dvobj.RowGroupCollection.$values.length > 0)
            dq.CurrentRowGroup = JSON.stringify(Dvobj.RowGroupCollection.$values[0]);
        dq.OrderBy = this.getOrderByInfoforInline(Dvobj);
        dq.Source = source;
        return dq;
    };

    this.getOrderByInfoforInline = function (Dvobj) {
        var tempArray = [];
        if (Dvobj.RowGroupCollection.$values.length > 0) {
            let rwog = Dvobj.RowGroupCollection.$values[0];
            if (rwog.RowGrouping.$values.length > 0) {
                for (let i = 0; i < rwog.RowGrouping.$values.length; i++)
                    tempArray.push(new order_obj(rwog.RowGrouping.$values[i].name, rwog.RowGrouping.$values[i].Direction));
            }
            if (rwog.OrderBy.$values.length > 0) {
                for (let i = 0; i < rwog.OrderBy.$values.length; i++)
                    tempArray.push(new order_obj(rwog.OrderBy.$values[i].name, rwog.OrderBy.$values[i].Direction));
            }
        }

        if (tempArray.length === 0) {
            $.each(Dvobj.OrderBy.$values, function (i, obj) {
                if (tempArray.filter(e => e.Column === obj.name).length === 0)
                    tempArray.push(new order_obj(obj.name, obj.Direction));
            });
        }

        return tempArray;

    };

    this.getStaticParameter = function (index) {
        var temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.data == index });
        var array = [];
        if (temp[0].StaticParameters.$values.length > 0) {
            $.each(temp[0].StaticParameters.$values, function (i, obj) {
                array.push(new fltr_obj(obj.Type, obj.Name, obj.Value));
            });
        }
        return array;
    };

    this.deleteTab = function (e) {
        var tabContentId = $(e.target).parent().attr("href");
        $(e.target).parent().parent().remove(); //remove li of tab
        $('#table_tabs a:last').tab('show'); // Select first tab
        $(tabContentId).remove();
    };

    this.CopyToClipboard = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-copy').click();
    };

    this.ExportToPrint = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-print')[0].click();
    };


    this.ExportToExcel = function (e) {
        //$('#' + this.tableId + '_wrapper').find('.buttons-excel').click();
        EbMessage("show", { Message: 'Generating Excel... Please wait in this tab or visit <b><a href="/Downloads" target="_blank" style="color: white; text-decoration: underline;">Downloads</a></b> page after a while..', AutoHide: true, Background: '#00aa55', Delay: 15000 });
        this.excelbtn.prop("disabled", true);
        this.RemoveColumnRef();

        var ob = new Object();
        ob.DataVizObjString = JSON.stringify(this.EbObject);
        ob.Params = this.filterValues;
        ob.TFilters = this.columnSearch;
        ob.SubscriptionId = window.ebcontext.subscription_id;

        this.ss = new EbServerEvents({ ServerEventUrl: window.ebcontext.se_url, Channels: ["ExportToExcel"] });
        this.ss.onExcelExportSuccess = function (url) {
            window.location.href = url;
            this.excelbtn.prop("disabled", false);
            event.stopPropagation();
        }.bind(this);
        $.ajax({
            type: "POST",
            url: "../DV/exportToexcel",
            data: { req: ob }
        });
    };

    this.ExportToCsv = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-csv').click();
    };

    this.ExportToPdf = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-pdf').click();
    };

    this.printSelected = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-print')[1].click();
    };

    this.printAll = function (e) {
        $('#' + this.tableId + '_wrapper').find('.buttons-print')[0].click();
    };

    this.SwitchToChart = function () {
        $('#' + this.tableId).parents().find(".sub-windows").hide();
        this.stickBtn.hide();
        let chartobj = new EbObjects["EbChartVisualization"]("Container_" + Date.now());
        chartobj.Columns = JSON.parse(JSON.stringify(this.EbObject.Columns));
        chartobj.DSColumns = JSON.parse(JSON.stringify(this.EbObject.DSColumns));
        chartobj.DataSourceRefId = this.EbObject.DataSourceRefId;
        chartobj.Pippedfrom = this.EbObject.Name;
        let chartapi = eb_chart(chartobj.DataSourceRefId, null, null, chartobj, null, this.tabNum, this.ssurl, this.login, this.counter, this.MainData, btoa(JSON.stringify(this.rowData)), btoa(JSON.stringify(this.filterValues)), this.cellData, this.propGrid);
    };

    this.collapseFilter = function () {
        this.filterBox.toggle();
        if (this.filterBox.css("display") == "none") {
            $("#btnCollapse" + this.tableId).children().remove();
            $("#btnCollapse" + this.tableId).append("<i class='fa fa-chevron-down' aria-hidden='true'></i>");
        }
        else {
            $("#btnCollapse" + this.tableId).children().remove();
            $("#btnCollapse" + this.tableId).append("<i class='fa fa-chevron-up' aria-hidden='true'></i>");
        }
    };


    this.updateRenderFunc = function () {
        $.each(this.EbObject.Columns.$values, this.updateRenderFunc_Inner.bind(this));
    };

    this.updateRenderFunc_Inner = function (i, col) {
        //this.EbObject.Columns.$values[i].sClass = "";
        //this.EbObject.Columns.$values[i].className = "";
        if (col.$type.indexOf("DVButtonColumn") === -1 && col.$type.indexOf("DVApprovalColumn") === -1 && col.$type.indexOf("DVActionColumn") === -1) {
            if (col.RenderType === parseInt(gettypefromString("Int32")) || col.RenderType === parseInt(gettypefromString("Decimal")) || col.RenderType === parseInt(gettypefromString("Int64")) || col.RenderType === parseInt(gettypefromString("Numeric"))) {

                if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                    this.EbObject.Columns.$values[i].className += " tdheight dt-right";
            }
            else if (col.RenderType === parseInt(gettypefromString("Boolean"))) {
                if (this.EbObject.Columns.$values[i].name === "eb_void" || this.EbObject.Columns.$values[i].name === "eb_lock") {
                    this.EbObject.Columns.$values[i].render = (this.EbObject.Columns.$values[i].name === "eb_lock") ? this.renderLockCol.bind(this) : this.renderEbVoidCol.bind(this);
                    this.EbObject.Columns.$values[i].mRender = (this.EbObject.Columns.$values[i].name === "eb_lock") ? this.renderLockCol.bind(this) : this.renderEbVoidCol.bind(this);
                }
                else {
                    if (this.EbObject.Columns.$values[i].RenderAs.toString() === EbEnums.BooleanRenderType.IsEditable) {
                        this.EbObject.Columns.$values[i].render = this.renderEditableCol.bind(this);
                        this.EbObject.Columns.$values[i].mRender = this.renderEditableCol.bind(this);
                    }
                    else if (this.EbObject.Columns.$values[i].RenderAs.toString() === EbEnums.BooleanRenderType.Icon) {
                        this.EbObject.Columns.$values[i].render = this.renderIconCol.bind(this);
                        this.EbObject.Columns.$values[i].mRender = this.renderIconCol.bind(this);
                    }
                    else {
                        this.EbObject.Columns.$values[i].render = function (data, type, row, meta) { return data; };
                        this.EbObject.Columns.$values[i].mRender = function (data, type, row, meta) { return data; };
                    }
                }
                if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                    this.EbObject.Columns.$values[i].className += " tdheight text-center";
            }
            else if (col.RenderType === parseInt(gettypefromString("String")) || col.RenderType == parseInt(gettypefromString("Double"))) {
                if (this.EbObject.Columns.$values[i].RenderAs.toString() === EbEnums.StringRenderType.Chart) {
                    this.EbObject.Columns.$values[i].render = this.lineGraphDiv.bind(this);
                    this.EbObject.Columns.$values[i].mRender = this.lineGraphDiv.bind(this);
                }
                //else if (this.EbObject.Columns.$values[i].RenderAs.toString() === EbEnums.StringRenderType.Image) {
                //    this.EbObject.Columns.$values[i].render = this.renderFBImage.bind(this, this.EbObject.Columns.$values[i]);
                //    this.EbObject.Columns.$values[i].mRender = this.renderFBImage.bind(this, this.EbObject.Columns.$values[i]);
                //}
                else if (this.EbObject.Columns.$values[i].RenderAs.toString() === EbEnums.StringRenderType.Icon) {
                    this.EbObject.Columns.$values[i].render = this.renderIconCol.bind(this);
                    this.EbObject.Columns.$values[i].mRender = this.renderIconCol.bind(this);
                }

                if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                    this.EbObject.Columns.$values[i].className += " tdheight dt-left";
            }
            else if (col.RenderType === parseInt(gettypefromString("Date")) || col.RenderType == parseInt(gettypefromString("DateTime"))) {
                if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Auto)
                    this.EbObject.Columns.$values[i].className += " tdheight dt-left";
            }
        }

        if (col.name === "eb_created_by" || col.name === "eb_lastmodified_by")
            col.className += " dt-left";
        if (col.Font !== null && col.Font !== undefined) {
            var style = document.createElement('style');
            style.type = 'text/css';
            var array = [this.tableId, col.name, col.Font.FontName, col.Font.Size, col.Font.color.replace("#", "")];
            if ($("." + array.join("_")).length === 0) {
                style.innerHTML = "." + array.join("_") + "{font-family: " + col.Font.FontName + "!important; font-size: " + col.Font.Size + "px!important; color: " + col.Font.color + "!important; }";
                document.getElementsByTagName('body')[0].appendChild(style);
            }
            this.EbObject.Columns.$values[i].className = array.join("_");
            this.EbObject.Columns.$values[i].sClass = array.join("_");
        }

        if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Left)
            this.EbObject.Columns.$values[i].className += " tdheight dt-left";
        else if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Right)
            this.EbObject.Columns.$values[i].className += " tdheight dt-right";
        else if (this.EbObject.Columns.$values[i].Align.toString() === EbEnums.Align.Center)
            this.EbObject.Columns.$values[i].className += " tdheight text-center";

        this.EbObject.Columns.$values[i].sClass = this.EbObject.Columns.$values[i].className;
    };

    this.renderProgressCol = function (deci, data, type, row, meta) {
        return "<div class='progress'><div class='progress-bar' role='progressbar' aria-valuenow='" + parseFloat(data.toString()).toFixed(deci) + "' aria-valuemin='0' aria-valuemax='100' style='width:" + data.toString() + "%'>" + parseFloat(data.toString()).toFixed(deci) + "</div></div>";
    };

    this.renderToDecimalPlace = function (data, type, row, meta) {
        return parseFloat(data).toFixed();
    };

    this.renderEditableCol = function (data) {
        return (data === true) ? "<input type='checkbox' data-toggle='toggle' data-size='mini' checked>" : "<input type='checkbox' data-toggle='toggle' data-size='mini'>";
    };

    this.renderIconCol = function (data, type, row, meta) {
        if (meta.settings.aoColumns[meta.col].TrueValue.toLowerCase() === data.toLowerCase())
            return "<i class='fa fa-check' aria-hidden='true'  style='color:green'></i>";
        else if (meta.settings.aoColumns[meta.col].FalseValue.toLowerCase() === data.toLowerCase())
            return "<i class='fa fa-times' aria-hidden='true' style='color:red'></i>";
        else
            return data;
    };

    this.renderEbVoidCol = function (data) {
        return (data === 'true' || data === true || data === 'T') ? "<i class='fa fa-ban' aria-hidden='true'></i>" : "";
    };

    this.renderLockCol = function (data) {
        return (data === 'true' || data === true || data === 'T') ? "<i class='fa fa-lock' aria-hidden='true'></i>" : "";
    };

    this.renderlink4NewTable = function (data, type, row, meta) {
        if (meta.settings.aoColumns[meta.col].LinkType.toString() === EbEnums.LinkTypeEnum.Popout)
            return "<a href='#' oncontextmenu='return false' class ='tablelink' data-link='" + meta.settings.aoColumns[meta.col].LinkRefId + "'>" + data + "</a>";
        else if (meta.settings.aoColumns[meta.col].LinkType.toString() === EbEnums.LinkTypeEnum.Inline)
            return data + `<a href='#' oncontextmenu='return false' class ='tablelink' data-link='${meta.settings.aoColumns[meta.col].LinkRefId}' data-inline="true" data-data='${data}'> <i class="fa fa-plus"></i></a>`;
        else
            return "<a href='#' oncontextmenu='return false' class ='tablelink' data-link='" + meta.settings.aoColumns[meta.col].LinkRefId + "'>" + data + "</a>" + ` &nbsp; <a href='#' oncontextmenu='return false' class ='tablelink' data-link='${meta.settings.aoColumns[meta.col].LinkRefId}' data-inline="true" data-data='${data}'> <i class="fa fa-plus"></i></a>`;
    };

    this.renderlinkandDecimal = function (deci, data) {
        return "<a href='#' oncontextmenu='return false' class ='tablelink' data-link='" + this.linkDV + "'>" + parseFloat(data).toFixed(deci) + "</a>";
    };

    this.colorRow = function (nRow, aData, iDisplayIndex, iDisplayIndexFull) {
        $.each(this.EbObject.Columns.$values, function (i, value) {
            if (value.name === 'sys_row_color') {
                HEX = Number(aData[value.data]).toString(16);
                var t = (HEX.toString().length < 6) ? ("0" + HEX.toString()) : HEX;
                $(nRow).css('background-color', '#' + t);
            }

            if (value.name === 'eb_void') {
                var tr = aData[value.data];
                if (tr === 'true' || tr === true || tr === 'T') {
                    $(nRow).css('color', '#ab0000');
                    $(nRow).attr('eb-void', 'T');
                }
            }
        });
    };

    this.lineGraphDiv = function (data, type, row, meta) {
        if (!data)
            return "";
        else
            return "<canvas id='eb_cvs" + meta.row + "' class='eb_canvas" + this.tableId + "' style='width:120px; height:40px; cursor:pointer;' data-graph='" + data + "' data-toggle='modal'></canvas><script>renderLineGraphs(" + meta.row + "); $('#eb_cvs" + meta.row + "').mousemove(function(e){ GPointPopup(e); });</script>";
    };

    this.RenderGraphModal = function () {
        $(document.body).append("<div class='modal fade' id='graphmodal' role='dialog'>"
            + "<div class='modal-dialog modal-lg'>"
            + " <div class='modal-content'>"
            + "<div class='modal-header'>"
            + "<button type = 'button' class='close' data-dismiss='modal'>&times;</button>"
            + "<h4 class='modal-title'><center>Graph</center></h4>"
            + "</div>"
            + "<div class='modal-body'>"
            + "<div class='dygraph-Wrapper'>"
            + "<div id='graphdiv' style='width:100%;height:500px;'></div>"
            + "</div>  "
            + "</div>"
            + "</div>"
            + "</div>"
            + "</div>");
        $(document).on('show.bs.modal', '.modal', function (event) {
            var zIndex = 1040 + (10 * $('.modal:visible').length);
            $(this).css('z-index', zIndex);
            setTimeout(function () {
                $('.modal-backdrop').not('.modal-stack').css('z-index', zIndex - 1).addClass('modal-stack');
            }, 0);
        });
    };

    this.renderMainGraph = function (e) {
        $("#graphmodal").modal('show');

        setTimeout(function () {
            var gcsv = csv($(e.target).attr("data-graph").toString());
            new Dygraph(
                document.getElementById('graphdiv'),
                gcsv,
                {
                    showRangeSelector: true,
                    interactionModel: Dygraph.defaultInteractionModel,
                    includeZero: true,
                    stackedGraph: true,
                    axes: {
                        y: {
                            valueFormatter: function (y) {
                                return y;
                            },
                            axisLabelFormatter: function (y) {
                                y = y.toString();
                                if (y.slice(-3) === '000')
                                    return y.slice(0, -3) + 'K';
                                else
                                    return y;
                            },
                        },
                        logscale: true
                    }
                }
            );
        }, 500);
    };

    this.ModifyDvname = function () {
        this.EbObject.Name = $("#dvnametxt").val();
        $("label.dvname").text(this.EbObject.Name);
    };

    this.ModifyTableHeight = function () {
        this.EbObject.scrollY = $("#TableHeighttxt").val();
        this.EbObject.scrollY = (this.EbObject.scrollY < 100) ? "300" : this.EbObject.scrollY;
    };

    this.renderMarker = function (data) {
        if (data !== ",")
            return `<a href='#' class ='columnMarker_${this.tableId}' data-latlong='${data}'><i class='fa fa-map-marker fa-2x' style='color:red;'></i></a>`;
        else
            return null;
    };

    this.renderFBImage = function (col, data) {
        //if (typeof (data) === "string")
        //    return `<img class='img-thumbnail' src='http://graph.facebook.com/${data}/picture?type=square' style="height: 20px;width: 25px;"/>`;
        //else
        //    return `<img class='img-thumbnail' src='http://graph.facebook.com/12345678/picture?type=square' style="height: 20px;width: 25px;"/>`;
        let _height = col.ImageHeight === 0 ? "auto" : col.ImageHeight + "px";
        let _width = col.ImageWidth === 0 ? "auto" : col.ImageWidth + "px";
        let _quality = getKeyByVal(EbEnums.ImageQuality, col.ImageQuality.toString()).toLowerCase();
        if (data !== "")
            return `<img class='img-thumbnail columnimage' src='/images/${_quality}/${data}.jpg' style="height: ${_height};width: ${_width};"/>`;
        else
            return `<img class='img-thumbnail' src='/images/image.png' style="height: ${_height};width: ${_width};"/>`;
    };

    this.renderDataAsLabel = function (data) {
        return `<label class='labeldata'>${data}</label>`;
    };

    this.renderDateformat = function (data, sym) {
        if (typeof data !== "object" && typeof data !== "undefined") {
            var date = new Date(parseInt(data.substr(6)));
            var month = date.getMonth() + 1;
            var dt = date.getDate();
            if (sym === "-")
                return (dt.toString().length > 1 ? dt : "0" + dt) + "-" + (month.toString().length > 1 ? month : "0" + month) + "-" + date.getFullYear();
            else
                return (dt.toString().length > 1 ? dt : "0" + dt) + "/" + (month.toString().length > 1 ? month : "0" + month) + "/" + date.getFullYear();
        }
        else
            return "";
    };

    this.CreateRelationString = function () { };

    this.ValidateCalcExpression = function (obj) {
        $.ajax({
            url: "../RB/ValidateCalcExpression",
            type: "POST",
            cache: false,
            data: {
                refid: this.EbObject.DataSourceRefId,
                expression: atob(obj.ValueExpression)
            },
            success: function (result) {

            }.bind(this)
        });
    };

    this.Eb_DataTable_StyleFn = function () {
        let Tile = this.EbObject;
        let TileId = "content_" + this.tableId;
        if (Tile.IsGradient) {
            let direction = this.GradientDirection(Tile.Direction);
            let bg = "linear-gradient(" + direction + "," + Tile.GradientColor1 + "," + Tile.GradientColor2 + ")";
            $(`#${TileId}`).css("background-image", bg);
        }
        else {
            $(`#${TileId}`).css("background", Tile.BackColor);
        }

        //Tile border
        $(`#${TileId}`).css("border-radius", Tile.BorderRadius == 0 ? 4 + "px" : Tile.BorderRadius + "px");
        $(`#${TileId}`).css("border", `solid 1px ${Tile.BorderColor}`);

        //Tile Text Font 
        $(`#${TileId} tr`).css("color", `${Tile.FontColor}`);
        $(`#${TileId} th`).css({ "color": `${Tile.FontColor} !important;` });
        $(`#${TileId} td`).css({ "color": `${Tile.FontColor} !important;` });
        $(`#${TileId} a`).css("color", `${Tile.LinkColor} !important;`).css("font-size: 14px;");

        $(`#${TileId} td`).css("border-bottom", "1px solid #2b2b2b;!important");
    };

    this.GradientDirection = function (val) {
        gradient = [];
        gradient[0] = "to right";
        gradient[1] = "to left";
        gradient[2] = "to bottom";
        gradient[3] = "to bottom right";
        gradient[4] = "to bottom left";
        gradient[5] = "to top right";
        gradient[6] = "to top left";

        return gradient[val];
    };

    this.showEbLoader = function () {
        if (this.Source != "WebForm")
            $("#eb_common_loader").EbLoader("show");
    };

    this.hideEbLoader = function () {
        if (this.Source != "WebForm")
            $("#eb_common_loader").EbLoader("hide");
    };

    if (this.Source === "EbDataTable" || this.Source === "PivotTable")
        this.start4EbDataTable();
    else
        this.start4Other();
};

const arrayColumn = (arr, n) => arr.map(x => x[n]);

function splitval(val) {
    return val.split(/\|\s*/);
}

function extractLast(term) {
    return splitval(term).pop();
}

if (!String.prototype.splice) {
    String.prototype.splice = function (start, delCount, newSubStr) {
        return this.slice(0, start) + newSubStr + this.slice(start + Math.abs(delCount));
    };
};

Array.prototype.max = function () {
    return Math.max.apply(null, this);
};

Array.prototype.min = function () {
    return Math.min.apply(null, this);
};

var displayFilter = function (col, title, oper, val, Loper) {
    this.name = col;
    this.title = title;
    this.operator = oper;
    this.value = val;
    this.logicOp = Loper;
};

function returnOperator(op) {
    if (op === "x*")
        return "startwith";
    else if (op === "*x")
        return "endswith";
    else if (op === "*x*")
        return "contains";
    else if (op === "=")
        return "=";
    else
        return op;
}

function imgError(image) {
    image.onerror = "";
    image.src = "/images/proimg.jpg";
    return true;
}

(function ($) {
    if ($.fn.style) {
        return;
    }

    // Escape regex chars with \
    var escape = function (text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };

    // For those who need them (< IE 9), add support for CSS functions
    var isStyleFuncSupported = !!CSSStyleDeclaration.prototype.getPropertyValue;
    if (!isStyleFuncSupported) {
        CSSStyleDeclaration.prototype.getPropertyValue = function (a) {
            return this.getAttribute(a);
        };
        CSSStyleDeclaration.prototype.setProperty = function (styleName, value, _priority) {
            this.setAttribute(styleName, value);
            let priority = typeof _priority != 'undefined' ? _priority : '';
            if (priority != '') {
                // Add priority manually
                var rule = new RegExp(escape(styleName) + '\\s*:\\s*' + escape(value) +
                    '(\\s*;)?', 'gmi');
                this.cssText =
                    this.cssText.replace(rule, styleName + ': ' + value + ' !' + priority + ';');
            }
        };
        CSSStyleDeclaration.prototype.removeProperty = function (a) {
            return this.removeAttribute(a);
        };
        CSSStyleDeclaration.prototype.getPropertyPriority = function (styleName) {
            var rule = new RegExp(escape(styleName) + '\\s*:\\s*[^\\s]*\\s*!important(\\s*;)?',
                'gmi');
            return rule.test(this.cssText) ? 'important' : '';
        }
    }

    // The style function
    $.fn.style = function (styleName, value, priority) {
        // DOM node
        var node = this.get(0);
        // Ensure we have a DOM node
        if (typeof node === 'undefined') {
            return this;
        }
        // CSSStyleDeclaration
        var style = this.get(0).style;
        // Getter/Setter
        if (typeof styleName !== 'undefined') {
            if (typeof value !== 'undefined') {
                // Set style property
                priority = typeof priority !== 'undefined' ? priority : '';
                style.setProperty(styleName, value, priority);
                return this;
            } else {
                // Get style property
                return style.getPropertyValue(styleName);
            }
        } else {
            // Get CSSStyleDeclaration
            return style;
        }
    };
})(jQuery);

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.1.3
 *
 * Copyright 2016 Nick Downie
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
	1: [function (require, module, exports) {

	}, {}], 2: [function (require, module, exports) {
		/* MIT license */
		var colorNames = require('color-name');

		module.exports = {
			getRgba: getRgba,
			getHsla: getHsla,
			getRgb: getRgb,
			getHsl: getHsl,
			getHwb: getHwb,
			getAlpha: getAlpha,

			hexString: hexString,
			rgbString: rgbString,
			rgbaString: rgbaString,
			percentString: percentString,
			percentaString: percentaString,
			hslString: hslString,
			hslaString: hslaString,
			hwbString: hwbString,
			keyword: keyword
		}

		function getRgba(string) {
			if (!string) {
				return;
			}
			var abbr = /^#([a-fA-F0-9]{3})$/,
				hex = /^#([a-fA-F0-9]{6})$/,
				rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
				per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
				keyword = /(\w+)/;

			var rgb = [0, 0, 0],
				a = 1,
				match = string.match(abbr);
			if (match) {
				match = match[1];
				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = parseInt(match[i] + match[i], 16);
				}
			}
			else if (match = string.match(hex)) {
				match = match[1];
				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
				}
			}
			else if (match = string.match(rgba)) {
				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = parseInt(match[i + 1]);
				}
				a = parseFloat(match[4]);
			}
			else if (match = string.match(per)) {
				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
				}
				a = parseFloat(match[4]);
			}
			else if (match = string.match(keyword)) {
				if (match[1] == "transparent") {
					return [0, 0, 0, 0];
				}
				rgb = colorNames[match[1]];
				if (!rgb) {
					return;
				}
			}

			for (var i = 0; i < rgb.length; i++) {
				rgb[i] = scale(rgb[i], 0, 255);
			}
			if (!a && a != 0) {
				a = 1;
			}
			else {
				a = scale(a, 0, 1);
			}
			rgb[3] = a;
			return rgb;
		}

		function getHsla(string) {
			if (!string) {
				return;
			}
			var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
			var match = string.match(hsl);
			if (match) {
				var alpha = parseFloat(match[4]);
				var h = scale(parseInt(match[1]), 0, 360),
					s = scale(parseFloat(match[2]), 0, 100),
					l = scale(parseFloat(match[3]), 0, 100),
					a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
				return [h, s, l, a];
			}
		}

		function getHwb(string) {
			if (!string) {
				return;
			}
			var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
			var match = string.match(hwb);
			if (match) {
				var alpha = parseFloat(match[4]);
				var h = scale(parseInt(match[1]), 0, 360),
					w = scale(parseFloat(match[2]), 0, 100),
					b = scale(parseFloat(match[3]), 0, 100),
					a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
				return [h, w, b, a];
			}
		}

		function getRgb(string) {
			var rgba = getRgba(string);
			return rgba && rgba.slice(0, 3);
		}

		function getHsl(string) {
			var hsla = getHsla(string);
			return hsla && hsla.slice(0, 3);
		}

		function getAlpha(string) {
			var vals = getRgba(string);
			if (vals) {
				return vals[3];
			}
			else if (vals = getHsla(string)) {
				return vals[3];
			}
			else if (vals = getHwb(string)) {
				return vals[3];
			}
		}

		// generators
		function hexString(rgb) {
			return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
				+ hexDouble(rgb[2]);
		}

		function rgbString(rgba, alpha) {
			if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
				return rgbaString(rgba, alpha);
			}
			return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
		}

		function rgbaString(rgba, alpha) {
			if (alpha === undefined) {
				alpha = (rgba[3] !== undefined ? rgba[3] : 1);
			}
			return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
				+ ", " + alpha + ")";
		}

		function percentString(rgba, alpha) {
			if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
				return percentaString(rgba, alpha);
			}
			var r = Math.round(rgba[0] / 255 * 100),
				g = Math.round(rgba[1] / 255 * 100),
				b = Math.round(rgba[2] / 255 * 100);

			return "rgb(" + r + "%, " + g + "%, " + b + "%)";
		}

		function percentaString(rgba, alpha) {
			var r = Math.round(rgba[0] / 255 * 100),
				g = Math.round(rgba[1] / 255 * 100),
				b = Math.round(rgba[2] / 255 * 100);
			return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
		}

		function hslString(hsla, alpha) {
			if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
				return hslaString(hsla, alpha);
			}
			return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
		}

		function hslaString(hsla, alpha) {
			if (alpha === undefined) {
				alpha = (hsla[3] !== undefined ? hsla[3] : 1);
			}
			return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
				+ alpha + ")";
		}

		// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
		// (hwb have alpha optional & 1 is default value)
		function hwbString(hwb, alpha) {
			if (alpha === undefined) {
				alpha = (hwb[3] !== undefined ? hwb[3] : 1);
			}
			return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
				+ (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
		}

		function keyword(rgb) {
			return reverseNames[rgb.slice(0, 3)];
		}

		// helpers
		function scale(num, min, max) {
			return Math.min(Math.max(min, num), max);
		}

		function hexDouble(num) {
			var str = num.toString(16).toUpperCase();
			return (str.length < 2) ? "0" + str : str;
		}


		//create a list of reverse color names
		var reverseNames = {};
		for (var name in colorNames) {
			reverseNames[colorNames[name]] = name;
		}

	}, { "color-name": 6 }], 3: [function (require, module, exports) {
		/* MIT license */

		var convert = require("color-convert"),
			string = require("chartjs-color-string");

		var Color = function (obj) {
			if (obj instanceof Color) return obj;
			if (!(this instanceof Color)) return new Color(obj);

			this.values = {
				rgb: [0, 0, 0],
				hsl: [0, 0, 0],
				hsv: [0, 0, 0],
				hwb: [0, 0, 0],
				cmyk: [0, 0, 0, 0],
				alpha: 1
			}

			// parse Color() argument
			if (typeof obj == "string") {
				var vals = string.getRgba(obj);
				if (vals) {
					this.setValues("rgb", vals);
				} else if (vals = string.getHsla(obj)) {
					this.setValues("hsl", vals);
				} else if (vals = string.getHwb(obj)) {
					this.setValues("hwb", vals);
				} else {
					throw new Error("Unable to parse color from string \"" + obj + "\"");
				}
			} else if (typeof obj == "object") {
				var vals = obj;
				if (vals["r"] !== undefined || vals["red"] !== undefined) {
					this.setValues("rgb", vals)
				} else if (vals["l"] !== undefined || vals["lightness"] !== undefined) {
					this.setValues("hsl", vals)
				} else if (vals["v"] !== undefined || vals["value"] !== undefined) {
					this.setValues("hsv", vals)
				} else if (vals["w"] !== undefined || vals["whiteness"] !== undefined) {
					this.setValues("hwb", vals)
				} else if (vals["c"] !== undefined || vals["cyan"] !== undefined) {
					this.setValues("cmyk", vals)
				} else {
					throw new Error("Unable to parse color from object " + JSON.stringify(obj));
				}
			}
		}

		Color.prototype = {
			rgb: function (vals) {
				return this.setSpace("rgb", arguments);
			},
			hsl: function (vals) {
				return this.setSpace("hsl", arguments);
			},
			hsv: function (vals) {
				return this.setSpace("hsv", arguments);
			},
			hwb: function (vals) {
				return this.setSpace("hwb", arguments);
			},
			cmyk: function (vals) {
				return this.setSpace("cmyk", arguments);
			},

			rgbArray: function () {
				return this.values.rgb;
			},
			hslArray: function () {
				return this.values.hsl;
			},
			hsvArray: function () {
				return this.values.hsv;
			},
			hwbArray: function () {
				if (this.values.alpha !== 1) {
					return this.values.hwb.concat([this.values.alpha])
				}
				return this.values.hwb;
			},
			cmykArray: function () {
				return this.values.cmyk;
			},
			rgbaArray: function () {
				var rgb = this.values.rgb;
				return rgb.concat([this.values.alpha]);
			},
			hslaArray: function () {
				var hsl = this.values.hsl;
				return hsl.concat([this.values.alpha]);
			},
			alpha: function (val) {
				if (val === undefined) {
					return this.values.alpha;
				}
				this.setValues("alpha", val);
				return this;
			},

			red: function (val) {
				return this.setChannel("rgb", 0, val);
			},
			green: function (val) {
				return this.setChannel("rgb", 1, val);
			},
			blue: function (val) {
				return this.setChannel("rgb", 2, val);
			},
			hue: function (val) {
				return this.setChannel("hsl", 0, val);
			},
			saturation: function (val) {
				return this.setChannel("hsl", 1, val);
			},
			lightness: function (val) {
				return this.setChannel("hsl", 2, val);
			},
			saturationv: function (val) {
				return this.setChannel("hsv", 1, val);
			},
			whiteness: function (val) {
				return this.setChannel("hwb", 1, val);
			},
			blackness: function (val) {
				return this.setChannel("hwb", 2, val);
			},
			value: function (val) {
				return this.setChannel("hsv", 2, val);
			},
			cyan: function (val) {
				return this.setChannel("cmyk", 0, val);
			},
			magenta: function (val) {
				return this.setChannel("cmyk", 1, val);
			},
			yellow: function (val) {
				return this.setChannel("cmyk", 2, val);
			},
			black: function (val) {
				return this.setChannel("cmyk", 3, val);
			},

			hexString: function () {
				return string.hexString(this.values.rgb);
			},
			rgbString: function () {
				return string.rgbString(this.values.rgb, this.values.alpha);
			},
			rgbaString: function () {
				return string.rgbaString(this.values.rgb, this.values.alpha);
			},
			percentString: function () {
				return string.percentString(this.values.rgb, this.values.alpha);
			},
			hslString: function () {
				return string.hslString(this.values.hsl, this.values.alpha);
			},
			hslaString: function () {
				return string.hslaString(this.values.hsl, this.values.alpha);
			},
			hwbString: function () {
				return string.hwbString(this.values.hwb, this.values.alpha);
			},
			keyword: function () {
				return string.keyword(this.values.rgb, this.values.alpha);
			},

			rgbNumber: function () {
				return (this.values.rgb[0] << 16) | (this.values.rgb[1] << 8) | this.values.rgb[2];
			},

			luminosity: function () {
				// http://www.w3.org/TR/WCAG20/#relativeluminancedef
				var rgb = this.values.rgb;
				var lum = [];
				for (var i = 0; i < rgb.length; i++) {
					var chan = rgb[i] / 255;
					lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4)
				}
				return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
			},

			contrast: function (color2) {
				// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
				var lum1 = this.luminosity();
				var lum2 = color2.luminosity();
				if (lum1 > lum2) {
					return (lum1 + 0.05) / (lum2 + 0.05)
				};
				return (lum2 + 0.05) / (lum1 + 0.05);
			},

			level: function (color2) {
				var contrastRatio = this.contrast(color2);
				return (contrastRatio >= 7.1) ? 'AAA' : (contrastRatio >= 4.5) ? 'AA' : '';
			},

			dark: function () {
				// YIQ equation from http://24ways.org/2010/calculating-color-contrast
				var rgb = this.values.rgb,
					yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
				return yiq < 128;
			},

			light: function () {
				return !this.dark();
			},

			negate: function () {
				var rgb = []
				for (var i = 0; i < 3; i++) {
					rgb[i] = 255 - this.values.rgb[i];
				}
				this.setValues("rgb", rgb);
				return this;
			},

			lighten: function (ratio) {
				this.values.hsl[2] += this.values.hsl[2] * ratio;
				this.setValues("hsl", this.values.hsl);
				return this;
			},

			darken: function (ratio) {
				this.values.hsl[2] -= this.values.hsl[2] * ratio;
				this.setValues("hsl", this.values.hsl);
				return this;
			},

			saturate: function (ratio) {
				this.values.hsl[1] += this.values.hsl[1] * ratio;
				this.setValues("hsl", this.values.hsl);
				return this;
			},

			desaturate: function (ratio) {
				this.values.hsl[1] -= this.values.hsl[1] * ratio;
				this.setValues("hsl", this.values.hsl);
				return this;
			},

			whiten: function (ratio) {
				this.values.hwb[1] += this.values.hwb[1] * ratio;
				this.setValues("hwb", this.values.hwb);
				return this;
			},

			blacken: function (ratio) {
				this.values.hwb[2] += this.values.hwb[2] * ratio;
				this.setValues("hwb", this.values.hwb);
				return this;
			},

			greyscale: function () {
				var rgb = this.values.rgb;
				// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
				var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
				this.setValues("rgb", [val, val, val]);
				return this;
			},

			clearer: function (ratio) {
				this.setValues("alpha", this.values.alpha - (this.values.alpha * ratio));
				return this;
			},

			opaquer: function (ratio) {
				this.setValues("alpha", this.values.alpha + (this.values.alpha * ratio));
				return this;
			},

			rotate: function (degrees) {
				var hue = this.values.hsl[0];
				hue = (hue + degrees) % 360;
				hue = hue < 0 ? 360 + hue : hue;
				this.values.hsl[0] = hue;
				this.setValues("hsl", this.values.hsl);
				return this;
			},

			mix: function (color2, weight) {
				weight = 1 - (weight == null ? 0.5 : weight);

				// algorithm from Sass's mix(). Ratio of first color in mix is
				// determined by the alphas of both colors and the weight
				var t1 = weight * 2 - 1,
					d = this.alpha() - color2.alpha();

				var weight1 = (((t1 * d == -1) ? t1 : (t1 + d) / (1 + t1 * d)) + 1) / 2;
				var weight2 = 1 - weight1;

				var rgb = this.rgbArray();
				var rgb2 = color2.rgbArray();

				for (var i = 0; i < rgb.length; i++) {
					rgb[i] = rgb[i] * weight1 + rgb2[i] * weight2;
				}
				this.setValues("rgb", rgb);

				var alpha = this.alpha() * weight + color2.alpha() * (1 - weight);
				this.setValues("alpha", alpha);

				return this;
			},

			toJSON: function () {
				return this.rgb();
			},

			clone: function () {
				return new Color(this.rgb());
			}
		}


		Color.prototype.getValues = function (space) {
			var vals = {};
			for (var i = 0; i < space.length; i++) {
				vals[space.charAt(i)] = this.values[space][i];
			}
			if (this.values.alpha != 1) {
				vals["a"] = this.values.alpha;
			}
			// {r: 255, g: 255, b: 255, a: 0.4}
			return vals;
		}

		Color.prototype.setValues = function (space, vals) {
			var spaces = {
				"rgb": ["red", "green", "blue"],
				"hsl": ["hue", "saturation", "lightness"],
				"hsv": ["hue", "saturation", "value"],
				"hwb": ["hue", "whiteness", "blackness"],
				"cmyk": ["cyan", "magenta", "yellow", "black"]
			};

			var maxes = {
				"rgb": [255, 255, 255],
				"hsl": [360, 100, 100],
				"hsv": [360, 100, 100],
				"hwb": [360, 100, 100],
				"cmyk": [100, 100, 100, 100]
			};

			var alpha = 1;
			if (space == "alpha") {
				alpha = vals;
			} else if (vals.length) {
				// [10, 10, 10]
				this.values[space] = vals.slice(0, space.length);
				alpha = vals[space.length];
			} else if (vals[space.charAt(0)] !== undefined) {
				// {r: 10, g: 10, b: 10}
				for (var i = 0; i < space.length; i++) {
					this.values[space][i] = vals[space.charAt(i)];
				}
				alpha = vals.a;
			} else if (vals[spaces[space][0]] !== undefined) {
				// {red: 10, green: 10, blue: 10}
				var chans = spaces[space];
				for (var i = 0; i < space.length; i++) {
					this.values[space][i] = vals[chans[i]];
				}
				alpha = vals.alpha;
			}
			this.values.alpha = Math.max(0, Math.min(1, (alpha !== undefined ? alpha : this.values.alpha)));
			if (space == "alpha") {
				return;
			}

			// cap values of the space prior converting all values
			for (var i = 0; i < space.length; i++) {
				var capped = Math.max(0, Math.min(maxes[space][i], this.values[space][i]));
				this.values[space][i] = Math.round(capped);
			}

			// convert to all the other color spaces
			for (var sname in spaces) {
				if (sname != space) {
					this.values[sname] = convert[space][sname](this.values[space])
				}

				// cap values
				for (var i = 0; i < sname.length; i++) {
					var capped = Math.max(0, Math.min(maxes[sname][i], this.values[sname][i]));
					this.values[sname][i] = Math.round(capped);
				}
			}
			return true;
		}

		Color.prototype.setSpace = function (space, args) {
			var vals = args[0];
			if (vals === undefined) {
				// color.rgb()
				return this.getValues(space);
			}
			// color.rgb(10, 10, 10)
			if (typeof vals == "number") {
				vals = Array.prototype.slice.call(args);
			}
			this.setValues(space, vals);
			return this;
		}

		Color.prototype.setChannel = function (space, index, val) {
			if (val === undefined) {
				// color.red()
				return this.values[space][index];
			}
			// color.red(100)
			this.values[space][index] = val;
			this.setValues(space, this.values[space]);
			return this;
		}

		window.Color = module.exports = Color

	}, { "chartjs-color-string": 2, "color-convert": 5 }], 4: [function (require, module, exports) {
		/* MIT license */

		module.exports = {
			rgb2hsl: rgb2hsl,
			rgb2hsv: rgb2hsv,
			rgb2hwb: rgb2hwb,
			rgb2cmyk: rgb2cmyk,
			rgb2keyword: rgb2keyword,
			rgb2xyz: rgb2xyz,
			rgb2lab: rgb2lab,
			rgb2lch: rgb2lch,

			hsl2rgb: hsl2rgb,
			hsl2hsv: hsl2hsv,
			hsl2hwb: hsl2hwb,
			hsl2cmyk: hsl2cmyk,
			hsl2keyword: hsl2keyword,

			hsv2rgb: hsv2rgb,
			hsv2hsl: hsv2hsl,
			hsv2hwb: hsv2hwb,
			hsv2cmyk: hsv2cmyk,
			hsv2keyword: hsv2keyword,

			hwb2rgb: hwb2rgb,
			hwb2hsl: hwb2hsl,
			hwb2hsv: hwb2hsv,
			hwb2cmyk: hwb2cmyk,
			hwb2keyword: hwb2keyword,

			cmyk2rgb: cmyk2rgb,
			cmyk2hsl: cmyk2hsl,
			cmyk2hsv: cmyk2hsv,
			cmyk2hwb: cmyk2hwb,
			cmyk2keyword: cmyk2keyword,

			keyword2rgb: keyword2rgb,
			keyword2hsl: keyword2hsl,
			keyword2hsv: keyword2hsv,
			keyword2hwb: keyword2hwb,
			keyword2cmyk: keyword2cmyk,
			keyword2lab: keyword2lab,
			keyword2xyz: keyword2xyz,

			xyz2rgb: xyz2rgb,
			xyz2lab: xyz2lab,
			xyz2lch: xyz2lch,

			lab2xyz: lab2xyz,
			lab2rgb: lab2rgb,
			lab2lch: lab2lch,

			lch2lab: lch2lab,
			lch2xyz: lch2xyz,
			lch2rgb: lch2rgb
		}


		function rgb2hsl(rgb) {
			var r = rgb[0] / 255,
				g = rgb[1] / 255,
				b = rgb[2] / 255,
				min = Math.min(r, g, b),
				max = Math.max(r, g, b),
				delta = max - min,
				h, s, l;

			if (max == min)
				h = 0;
			else if (r == max)
				h = (g - b) / delta;
			else if (g == max)
				h = 2 + (b - r) / delta;
			else if (b == max)
				h = 4 + (r - g) / delta;

			h = Math.min(h * 60, 360);

			if (h < 0)
				h += 360;

			l = (min + max) / 2;

			if (max == min)
				s = 0;
			else if (l <= 0.5)
				s = delta / (max + min);
			else
				s = delta / (2 - max - min);

			return [h, s * 100, l * 100];
		}

		function rgb2hsv(rgb) {
			var r = rgb[0],
				g = rgb[1],
				b = rgb[2],
				min = Math.min(r, g, b),
				max = Math.max(r, g, b),
				delta = max - min,
				h, s, v;

			if (max == 0)
				s = 0;
			else
				s = (delta / max * 1000) / 10;

			if (max == min)
				h = 0;
			else if (r == max)
				h = (g - b) / delta;
			else if (g == max)
				h = 2 + (b - r) / delta;
			else if (b == max)
				h = 4 + (r - g) / delta;

			h = Math.min(h * 60, 360);

			if (h < 0)
				h += 360;

			v = ((max / 255) * 1000) / 10;

			return [h, s, v];
		}

		function rgb2hwb(rgb) {
			var r = rgb[0],
				g = rgb[1],
				b = rgb[2],
				h = rgb2hsl(rgb)[0],
				w = 1 / 255 * Math.min(r, Math.min(g, b)),
				b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

			return [h, w * 100, b * 100];
		}

		function rgb2cmyk(rgb) {
			var r = rgb[0] / 255,
				g = rgb[1] / 255,
				b = rgb[2] / 255,
				c, m, y, k;

			k = Math.min(1 - r, 1 - g, 1 - b);
			c = (1 - r - k) / (1 - k) || 0;
			m = (1 - g - k) / (1 - k) || 0;
			y = (1 - b - k) / (1 - k) || 0;
			return [c * 100, m * 100, y * 100, k * 100];
		}

		function rgb2keyword(rgb) {
			return reverseKeywords[JSON.stringify(rgb)];
		}

		function rgb2xyz(rgb) {
			var r = rgb[0] / 255,
				g = rgb[1] / 255,
				b = rgb[2] / 255;

			// assume sRGB
			r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
			g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
			b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

			var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
			var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
			var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

			return [x * 100, y * 100, z * 100];
		}

		function rgb2lab(rgb) {
			var xyz = rgb2xyz(rgb),
				x = xyz[0],
				y = xyz[1],
				z = xyz[2],
				l, a, b;

			x /= 95.047;
			y /= 100;
			z /= 108.883;

			x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
			y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
			z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

			l = (116 * y) - 16;
			a = 500 * (x - y);
			b = 200 * (y - z);

			return [l, a, b];
		}

		function rgb2lch(args) {
			return lab2lch(rgb2lab(args));
		}

		function hsl2rgb(hsl) {
			var h = hsl[0] / 360,
				s = hsl[1] / 100,
				l = hsl[2] / 100,
				t1, t2, t3, rgb, val;

			if (s == 0) {
				val = l * 255;
				return [val, val, val];
			}

			if (l < 0.5)
				t2 = l * (1 + s);
			else
				t2 = l + s - l * s;
			t1 = 2 * l - t2;

			rgb = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				t3 = h + 1 / 3 * - (i - 1);
				t3 < 0 && t3++;
				t3 > 1 && t3--;

				if (6 * t3 < 1)
					val = t1 + (t2 - t1) * 6 * t3;
				else if (2 * t3 < 1)
					val = t2;
				else if (3 * t3 < 2)
					val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
				else
					val = t1;

				rgb[i] = val * 255;
			}

			return rgb;
		}

		function hsl2hsv(hsl) {
			var h = hsl[0],
				s = hsl[1] / 100,
				l = hsl[2] / 100,
				sv, v;

			if (l === 0) {
				// no need to do calc on black
				// also avoids divide by 0 error
				return [0, 0, 0];
			}

			l *= 2;
			s *= (l <= 1) ? l : 2 - l;
			v = (l + s) / 2;
			sv = (2 * s) / (l + s);
			return [h, sv * 100, v * 100];
		}

		function hsl2hwb(args) {
			return rgb2hwb(hsl2rgb(args));
		}

		function hsl2cmyk(args) {
			return rgb2cmyk(hsl2rgb(args));
		}

		function hsl2keyword(args) {
			return rgb2keyword(hsl2rgb(args));
		}


		function hsv2rgb(hsv) {
			var h = hsv[0] / 60,
				s = hsv[1] / 100,
				v = hsv[2] / 100,
				hi = Math.floor(h) % 6;

			var f = h - Math.floor(h),
				p = 255 * v * (1 - s),
				q = 255 * v * (1 - (s * f)),
				t = 255 * v * (1 - (s * (1 - f))),
				v = 255 * v;

			switch (hi) {
				case 0:
					return [v, t, p];
				case 1:
					return [q, v, p];
				case 2:
					return [p, v, t];
				case 3:
					return [p, q, v];
				case 4:
					return [t, p, v];
				case 5:
					return [v, p, q];
			}
		}

		function hsv2hsl(hsv) {
			var h = hsv[0],
				s = hsv[1] / 100,
				v = hsv[2] / 100,
				sl, l;

			l = (2 - s) * v;
			sl = s * v;
			sl /= (l <= 1) ? l : 2 - l;
			sl = sl || 0;
			l /= 2;
			return [h, sl * 100, l * 100];
		}

		function hsv2hwb(args) {
			return rgb2hwb(hsv2rgb(args))
		}

		function hsv2cmyk(args) {
			return rgb2cmyk(hsv2rgb(args));
		}

		function hsv2keyword(args) {
			return rgb2keyword(hsv2rgb(args));
		}

		// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
		function hwb2rgb(hwb) {
			var h = hwb[0] / 360,
				wh = hwb[1] / 100,
				bl = hwb[2] / 100,
				ratio = wh + bl,
				i, v, f, n;

			// wh + bl cant be > 1
			if (ratio > 1) {
				wh /= ratio;
				bl /= ratio;
			}

			i = Math.floor(6 * h);
			v = 1 - bl;
			f = 6 * h - i;
			if ((i & 0x01) != 0) {
				f = 1 - f;
			}
			n = wh + f * (v - wh);  // linear interpolation

			switch (i) {
				default:
				case 6:
				case 0: r = v; g = n; b = wh; break;
				case 1: r = n; g = v; b = wh; break;
				case 2: r = wh; g = v; b = n; break;
				case 3: r = wh; g = n; b = v; break;
				case 4: r = n; g = wh; b = v; break;
				case 5: r = v; g = wh; b = n; break;
			}

			return [r * 255, g * 255, b * 255];
		}

		function hwb2hsl(args) {
			return rgb2hsl(hwb2rgb(args));
		}

		function hwb2hsv(args) {
			return rgb2hsv(hwb2rgb(args));
		}

		function hwb2cmyk(args) {
			return rgb2cmyk(hwb2rgb(args));
		}

		function hwb2keyword(args) {
			return rgb2keyword(hwb2rgb(args));
		}

		function cmyk2rgb(cmyk) {
			var c = cmyk[0] / 100,
				m = cmyk[1] / 100,
				y = cmyk[2] / 100,
				k = cmyk[3] / 100,
				r, g, b;

			r = 1 - Math.min(1, c * (1 - k) + k);
			g = 1 - Math.min(1, m * (1 - k) + k);
			b = 1 - Math.min(1, y * (1 - k) + k);
			return [r * 255, g * 255, b * 255];
		}

		function cmyk2hsl(args) {
			return rgb2hsl(cmyk2rgb(args));
		}

		function cmyk2hsv(args) {
			return rgb2hsv(cmyk2rgb(args));
		}

		function cmyk2hwb(args) {
			return rgb2hwb(cmyk2rgb(args));
		}

		function cmyk2keyword(args) {
			return rgb2keyword(cmyk2rgb(args));
		}


		function xyz2rgb(xyz) {
			var x = xyz[0] / 100,
				y = xyz[1] / 100,
				z = xyz[2] / 100,
				r, g, b;

			r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
			g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
			b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

			// assume sRGB
			r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
				: r = (r * 12.92);

			g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
				: g = (g * 12.92);

			b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
				: b = (b * 12.92);

			r = Math.min(Math.max(0, r), 1);
			g = Math.min(Math.max(0, g), 1);
			b = Math.min(Math.max(0, b), 1);

			return [r * 255, g * 255, b * 255];
		}

		function xyz2lab(xyz) {
			var x = xyz[0],
				y = xyz[1],
				z = xyz[2],
				l, a, b;

			x /= 95.047;
			y /= 100;
			z /= 108.883;

			x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
			y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
			z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

			l = (116 * y) - 16;
			a = 500 * (x - y);
			b = 200 * (y - z);

			return [l, a, b];
		}

		function xyz2lch(args) {
			return lab2lch(xyz2lab(args));
		}

		function lab2xyz(lab) {
			var l = lab[0],
				a = lab[1],
				b = lab[2],
				x, y, z, y2;

			if (l <= 8) {
				y = (l * 100) / 903.3;
				y2 = (7.787 * (y / 100)) + (16 / 116);
			} else {
				y = 100 * Math.pow((l + 16) / 116, 3);
				y2 = Math.pow(y / 100, 1 / 3);
			}

			x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

			z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

			return [x, y, z];
		}

		function lab2lch(lab) {
			var l = lab[0],
				a = lab[1],
				b = lab[2],
				hr, h, c;

			hr = Math.atan2(b, a);
			h = hr * 360 / 2 / Math.PI;
			if (h < 0) {
				h += 360;
			}
			c = Math.sqrt(a * a + b * b);
			return [l, c, h];
		}

		function lab2rgb(args) {
			return xyz2rgb(lab2xyz(args));
		}

		function lch2lab(lch) {
			var l = lch[0],
				c = lch[1],
				h = lch[2],
				a, b, hr;

			hr = h / 360 * 2 * Math.PI;
			a = c * Math.cos(hr);
			b = c * Math.sin(hr);
			return [l, a, b];
		}

		function lch2xyz(args) {
			return lab2xyz(lch2lab(args));
		}

		function lch2rgb(args) {
			return lab2rgb(lch2lab(args));
		}

		function keyword2rgb(keyword) {
			return cssKeywords[keyword];
		}

		function keyword2hsl(args) {
			return rgb2hsl(keyword2rgb(args));
		}

		function keyword2hsv(args) {
			return rgb2hsv(keyword2rgb(args));
		}

		function keyword2hwb(args) {
			return rgb2hwb(keyword2rgb(args));
		}

		function keyword2cmyk(args) {
			return rgb2cmyk(keyword2rgb(args));
		}

		function keyword2lab(args) {
			return rgb2lab(keyword2rgb(args));
		}

		function keyword2xyz(args) {
			return rgb2xyz(keyword2rgb(args));
		}

		var cssKeywords = {
			aliceblue: [240, 248, 255],
			antiquewhite: [250, 235, 215],
			aqua: [0, 255, 255],
			aquamarine: [127, 255, 212],
			azure: [240, 255, 255],
			beige: [245, 245, 220],
			bisque: [255, 228, 196],
			black: [0, 0, 0],
			blanchedalmond: [255, 235, 205],
			blue: [0, 0, 255],
			blueviolet: [138, 43, 226],
			brown: [165, 42, 42],
			burlywood: [222, 184, 135],
			cadetblue: [95, 158, 160],
			chartreuse: [127, 255, 0],
			chocolate: [210, 105, 30],
			coral: [255, 127, 80],
			cornflowerblue: [100, 149, 237],
			cornsilk: [255, 248, 220],
			crimson: [220, 20, 60],
			cyan: [0, 255, 255],
			darkblue: [0, 0, 139],
			darkcyan: [0, 139, 139],
			darkgoldenrod: [184, 134, 11],
			darkgray: [169, 169, 169],
			darkgreen: [0, 100, 0],
			darkgrey: [169, 169, 169],
			darkkhaki: [189, 183, 107],
			darkmagenta: [139, 0, 139],
			darkolivegreen: [85, 107, 47],
			darkorange: [255, 140, 0],
			darkorchid: [153, 50, 204],
			darkred: [139, 0, 0],
			darksalmon: [233, 150, 122],
			darkseagreen: [143, 188, 143],
			darkslateblue: [72, 61, 139],
			darkslategray: [47, 79, 79],
			darkslategrey: [47, 79, 79],
			darkturquoise: [0, 206, 209],
			darkviolet: [148, 0, 211],
			deeppink: [255, 20, 147],
			deepskyblue: [0, 191, 255],
			dimgray: [105, 105, 105],
			dimgrey: [105, 105, 105],
			dodgerblue: [30, 144, 255],
			firebrick: [178, 34, 34],
			floralwhite: [255, 250, 240],
			forestgreen: [34, 139, 34],
			fuchsia: [255, 0, 255],
			gainsboro: [220, 220, 220],
			ghostwhite: [248, 248, 255],
			gold: [255, 215, 0],
			goldenrod: [218, 165, 32],
			gray: [128, 128, 128],
			green: [0, 128, 0],
			greenyellow: [173, 255, 47],
			grey: [128, 128, 128],
			honeydew: [240, 255, 240],
			hotpink: [255, 105, 180],
			indianred: [205, 92, 92],
			indigo: [75, 0, 130],
			ivory: [255, 255, 240],
			khaki: [240, 230, 140],
			lavender: [230, 230, 250],
			lavenderblush: [255, 240, 245],
			lawngreen: [124, 252, 0],
			lemonchiffon: [255, 250, 205],
			lightblue: [173, 216, 230],
			lightcoral: [240, 128, 128],
			lightcyan: [224, 255, 255],
			lightgoldenrodyellow: [250, 250, 210],
			lightgray: [211, 211, 211],
			lightgreen: [144, 238, 144],
			lightgrey: [211, 211, 211],
			lightpink: [255, 182, 193],
			lightsalmon: [255, 160, 122],
			lightseagreen: [32, 178, 170],
			lightskyblue: [135, 206, 250],
			lightslategray: [119, 136, 153],
			lightslategrey: [119, 136, 153],
			lightsteelblue: [176, 196, 222],
			lightyellow: [255, 255, 224],
			lime: [0, 255, 0],
			limegreen: [50, 205, 50],
			linen: [250, 240, 230],
			magenta: [255, 0, 255],
			maroon: [128, 0, 0],
			mediumaquamarine: [102, 205, 170],
			mediumblue: [0, 0, 205],
			mediumorchid: [186, 85, 211],
			mediumpurple: [147, 112, 219],
			mediumseagreen: [60, 179, 113],
			mediumslateblue: [123, 104, 238],
			mediumspringgreen: [0, 250, 154],
			mediumturquoise: [72, 209, 204],
			mediumvioletred: [199, 21, 133],
			midnightblue: [25, 25, 112],
			mintcream: [245, 255, 250],
			mistyrose: [255, 228, 225],
			moccasin: [255, 228, 181],
			navajowhite: [255, 222, 173],
			navy: [0, 0, 128],
			oldlace: [253, 245, 230],
			olive: [128, 128, 0],
			olivedrab: [107, 142, 35],
			orange: [255, 165, 0],
			orangered: [255, 69, 0],
			orchid: [218, 112, 214],
			palegoldenrod: [238, 232, 170],
			palegreen: [152, 251, 152],
			paleturquoise: [175, 238, 238],
			palevioletred: [219, 112, 147],
			papayawhip: [255, 239, 213],
			peachpuff: [255, 218, 185],
			peru: [205, 133, 63],
			pink: [255, 192, 203],
			plum: [221, 160, 221],
			powderblue: [176, 224, 230],
			purple: [128, 0, 128],
			rebeccapurple: [102, 51, 153],
			red: [255, 0, 0],
			rosybrown: [188, 143, 143],
			royalblue: [65, 105, 225],
			saddlebrown: [139, 69, 19],
			salmon: [250, 128, 114],
			sandybrown: [244, 164, 96],
			seagreen: [46, 139, 87],
			seashell: [255, 245, 238],
			sienna: [160, 82, 45],
			silver: [192, 192, 192],
			skyblue: [135, 206, 235],
			slateblue: [106, 90, 205],
			slategray: [112, 128, 144],
			slategrey: [112, 128, 144],
			snow: [255, 250, 250],
			springgreen: [0, 255, 127],
			steelblue: [70, 130, 180],
			tan: [210, 180, 140],
			teal: [0, 128, 128],
			thistle: [216, 191, 216],
			tomato: [255, 99, 71],
			turquoise: [64, 224, 208],
			violet: [238, 130, 238],
			wheat: [245, 222, 179],
			white: [255, 255, 255],
			whitesmoke: [245, 245, 245],
			yellow: [255, 255, 0],
			yellowgreen: [154, 205, 50]
		};

		var reverseKeywords = {};
		for (var key in cssKeywords) {
			reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
		}

	}, {}], 5: [function (require, module, exports) {
		var conversions = require("./conversions");

		var convert = function () {
			return new Converter();
		}

		for (var func in conversions) {
			// export Raw versions
			convert[func + "Raw"] = (function (func) {
				// accept array or plain args
				return function (arg) {
					if (typeof arg == "number")
						arg = Array.prototype.slice.call(arguments);
					return conversions[func](arg);
				}
			})(func);

			var pair = /(\w+)2(\w+)/.exec(func),
				from = pair[1],
				to = pair[2];

			// export rgb2hsl and ["rgb"]["hsl"]
			convert[from] = convert[from] || {};

			convert[from][to] = convert[func] = (function (func) {
				return function (arg) {
					if (typeof arg == "number")
						arg = Array.prototype.slice.call(arguments);

					var val = conversions[func](arg);
					if (typeof val == "string" || val === undefined)
						return val; // keyword

					for (var i = 0; i < val.length; i++)
						val[i] = Math.round(val[i]);
					return val;
				}
			})(func);
		}


		/* Converter does lazy conversion and caching */
		var Converter = function () {
			this.convs = {};
		};

		/* Either get the values for a space or
		  set the values for a space, depending on args */
		Converter.prototype.routeSpace = function (space, args) {
			var values = args[0];
			if (values === undefined) {
				// color.rgb()
				return this.getValues(space);
			}
			// color.rgb(10, 10, 10)
			if (typeof values == "number") {
				values = Array.prototype.slice.call(args);
			}

			return this.setValues(space, values);
		};

		/* Set the values for a space, invalidating cache */
		Converter.prototype.setValues = function (space, values) {
			this.space = space;
			this.convs = {};
			this.convs[space] = values;
			return this;
		};

		/* Get the values for a space. If there's already
		  a conversion for the space, fetch it, otherwise
		  compute it */
		Converter.prototype.getValues = function (space) {
			var vals = this.convs[space];
			if (!vals) {
				var fspace = this.space,
					from = this.convs[fspace];
				vals = convert[fspace][space](from);

				this.convs[space] = vals;
			}
			return vals;
		};

		["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
			Converter.prototype[space] = function (vals) {
				return this.routeSpace(space, arguments);
			}
		});

		module.exports = convert;
	}, { "./conversions": 4 }], 6: [function (require, module, exports) {
		module.exports = {
			"aliceblue": [240, 248, 255],
			"antiquewhite": [250, 235, 215],
			"aqua": [0, 255, 255],
			"aquamarine": [127, 255, 212],
			"azure": [240, 255, 255],
			"beige": [245, 245, 220],
			"bisque": [255, 228, 196],
			"black": [0, 0, 0],
			"blanchedalmond": [255, 235, 205],
			"blue": [0, 0, 255],
			"blueviolet": [138, 43, 226],
			"brown": [165, 42, 42],
			"burlywood": [222, 184, 135],
			"cadetblue": [95, 158, 160],
			"chartreuse": [127, 255, 0],
			"chocolate": [210, 105, 30],
			"coral": [255, 127, 80],
			"cornflowerblue": [100, 149, 237],
			"cornsilk": [255, 248, 220],
			"crimson": [220, 20, 60],
			"cyan": [0, 255, 255],
			"darkblue": [0, 0, 139],
			"darkcyan": [0, 139, 139],
			"darkgoldenrod": [184, 134, 11],
			"darkgray": [169, 169, 169],
			"darkgreen": [0, 100, 0],
			"darkgrey": [169, 169, 169],
			"darkkhaki": [189, 183, 107],
			"darkmagenta": [139, 0, 139],
			"darkolivegreen": [85, 107, 47],
			"darkorange": [255, 140, 0],
			"darkorchid": [153, 50, 204],
			"darkred": [139, 0, 0],
			"darksalmon": [233, 150, 122],
			"darkseagreen": [143, 188, 143],
			"darkslateblue": [72, 61, 139],
			"darkslategray": [47, 79, 79],
			"darkslategrey": [47, 79, 79],
			"darkturquoise": [0, 206, 209],
			"darkviolet": [148, 0, 211],
			"deeppink": [255, 20, 147],
			"deepskyblue": [0, 191, 255],
			"dimgray": [105, 105, 105],
			"dimgrey": [105, 105, 105],
			"dodgerblue": [30, 144, 255],
			"firebrick": [178, 34, 34],
			"floralwhite": [255, 250, 240],
			"forestgreen": [34, 139, 34],
			"fuchsia": [255, 0, 255],
			"gainsboro": [220, 220, 220],
			"ghostwhite": [248, 248, 255],
			"gold": [255, 215, 0],
			"goldenrod": [218, 165, 32],
			"gray": [128, 128, 128],
			"green": [0, 128, 0],
			"greenyellow": [173, 255, 47],
			"grey": [128, 128, 128],
			"honeydew": [240, 255, 240],
			"hotpink": [255, 105, 180],
			"indianred": [205, 92, 92],
			"indigo": [75, 0, 130],
			"ivory": [255, 255, 240],
			"khaki": [240, 230, 140],
			"lavender": [230, 230, 250],
			"lavenderblush": [255, 240, 245],
			"lawngreen": [124, 252, 0],
			"lemonchiffon": [255, 250, 205],
			"lightblue": [173, 216, 230],
			"lightcoral": [240, 128, 128],
			"lightcyan": [224, 255, 255],
			"lightgoldenrodyellow": [250, 250, 210],
			"lightgray": [211, 211, 211],
			"lightgreen": [144, 238, 144],
			"lightgrey": [211, 211, 211],
			"lightpink": [255, 182, 193],
			"lightsalmon": [255, 160, 122],
			"lightseagreen": [32, 178, 170],
			"lightskyblue": [135, 206, 250],
			"lightslategray": [119, 136, 153],
			"lightslategrey": [119, 136, 153],
			"lightsteelblue": [176, 196, 222],
			"lightyellow": [255, 255, 224],
			"lime": [0, 255, 0],
			"limegreen": [50, 205, 50],
			"linen": [250, 240, 230],
			"magenta": [255, 0, 255],
			"maroon": [128, 0, 0],
			"mediumaquamarine": [102, 205, 170],
			"mediumblue": [0, 0, 205],
			"mediumorchid": [186, 85, 211],
			"mediumpurple": [147, 112, 219],
			"mediumseagreen": [60, 179, 113],
			"mediumslateblue": [123, 104, 238],
			"mediumspringgreen": [0, 250, 154],
			"mediumturquoise": [72, 209, 204],
			"mediumvioletred": [199, 21, 133],
			"midnightblue": [25, 25, 112],
			"mintcream": [245, 255, 250],
			"mistyrose": [255, 228, 225],
			"moccasin": [255, 228, 181],
			"navajowhite": [255, 222, 173],
			"navy": [0, 0, 128],
			"oldlace": [253, 245, 230],
			"olive": [128, 128, 0],
			"olivedrab": [107, 142, 35],
			"orange": [255, 165, 0],
			"orangered": [255, 69, 0],
			"orchid": [218, 112, 214],
			"palegoldenrod": [238, 232, 170],
			"palegreen": [152, 251, 152],
			"paleturquoise": [175, 238, 238],
			"palevioletred": [219, 112, 147],
			"papayawhip": [255, 239, 213],
			"peachpuff": [255, 218, 185],
			"peru": [205, 133, 63],
			"pink": [255, 192, 203],
			"plum": [221, 160, 221],
			"powderblue": [176, 224, 230],
			"purple": [128, 0, 128],
			"rebeccapurple": [102, 51, 153],
			"red": [255, 0, 0],
			"rosybrown": [188, 143, 143],
			"royalblue": [65, 105, 225],
			"saddlebrown": [139, 69, 19],
			"salmon": [250, 128, 114],
			"sandybrown": [244, 164, 96],
			"seagreen": [46, 139, 87],
			"seashell": [255, 245, 238],
			"sienna": [160, 82, 45],
			"silver": [192, 192, 192],
			"skyblue": [135, 206, 235],
			"slateblue": [106, 90, 205],
			"slategray": [112, 128, 144],
			"slategrey": [112, 128, 144],
			"snow": [255, 250, 250],
			"springgreen": [0, 255, 127],
			"steelblue": [70, 130, 180],
			"tan": [210, 180, 140],
			"teal": [0, 128, 128],
			"thistle": [216, 191, 216],
			"tomato": [255, 99, 71],
			"turquoise": [64, 224, 208],
			"violet": [238, 130, 238],
			"wheat": [245, 222, 179],
			"white": [255, 255, 255],
			"whitesmoke": [245, 245, 245],
			"yellow": [255, 255, 0],
			"yellowgreen": [154, 205, 50]
		};
	}, {}], 7: [function (require, module, exports) {
		var Chart = require('./core/core.js')();

		require('./core/core.helpers')(Chart);
		require('./core/core.element')(Chart);
		require('./core/core.animation')(Chart);
		require('./core/core.controller')(Chart);
		require('./core/core.datasetController')(Chart);
		require('./core/core.layoutService')(Chart);
		require('./core/core.legend')(Chart);
		require('./core/core.plugin.js')(Chart);
		require('./core/core.scale')(Chart);
		require('./core/core.scaleService')(Chart);
		require('./core/core.title')(Chart);
		require('./core/core.tooltip')(Chart);

		require('./controllers/controller.bar')(Chart);
		require('./controllers/controller.bubble')(Chart);
		require('./controllers/controller.doughnut')(Chart);
		require('./controllers/controller.line')(Chart);
		require('./controllers/controller.polarArea')(Chart);
		require('./controllers/controller.radar')(Chart);

		require('./scales/scale.category')(Chart);
		require('./scales/scale.linear')(Chart);
		require('./scales/scale.logarithmic')(Chart);
		require('./scales/scale.radialLinear')(Chart);
		require('./scales/scale.time')(Chart);

		require('./elements/element.arc')(Chart);
		require('./elements/element.line')(Chart);
		require('./elements/element.point')(Chart);
		require('./elements/element.rectangle')(Chart);

		require('./charts/Chart.Bar')(Chart);
		require('./charts/Chart.Bubble')(Chart);
		require('./charts/Chart.Doughnut')(Chart);
		require('./charts/Chart.Line')(Chart);
		require('./charts/Chart.PolarArea')(Chart);
		require('./charts/Chart.Radar')(Chart);
		require('./charts/Chart.Scatter')(Chart);

		window.Chart = module.exports = Chart;

	}, { "./charts/Chart.Bar": 8, "./charts/Chart.Bubble": 9, "./charts/Chart.Doughnut": 10, "./charts/Chart.Line": 11, "./charts/Chart.PolarArea": 12, "./charts/Chart.Radar": 13, "./charts/Chart.Scatter": 14, "./controllers/controller.bar": 15, "./controllers/controller.bubble": 16, "./controllers/controller.doughnut": 17, "./controllers/controller.line": 18, "./controllers/controller.polarArea": 19, "./controllers/controller.radar": 20, "./core/core.animation": 21, "./core/core.controller": 22, "./core/core.datasetController": 23, "./core/core.element": 24, "./core/core.helpers": 25, "./core/core.js": 26, "./core/core.layoutService": 27, "./core/core.legend": 28, "./core/core.plugin.js": 29, "./core/core.scale": 30, "./core/core.scaleService": 31, "./core/core.title": 32, "./core/core.tooltip": 33, "./elements/element.arc": 34, "./elements/element.line": 35, "./elements/element.point": 36, "./elements/element.rectangle": 37, "./scales/scale.category": 38, "./scales/scale.linear": 39, "./scales/scale.logarithmic": 40, "./scales/scale.radialLinear": 41, "./scales/scale.time": 42 }], 8: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			Chart.Bar = function (context, config) {
				config.type = 'bar';

				return new Chart(context, config);
			};

		};
	}, {}], 9: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			Chart.Bubble = function (context, config) {
				config.type = 'bubble';
				return new Chart(context, config);
			};

		};
	}, {}], 10: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			Chart.Doughnut = function (context, config) {
				config.type = 'doughnut';

				return new Chart(context, config);
			};

		};
	}, {}], 11: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			Chart.Line = function (context, config) {
				config.type = 'line';

				return new Chart(context, config);
			};

		};
	}, {}], 12: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			Chart.PolarArea = function (context, config) {
				config.type = 'polarArea';

				return new Chart(context, config);
			};

		};
	}, {}], 13: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			var defaultConfig = {
				aspectRatio: 1
			};

			Chart.Radar = function (context, config) {
				config.options = helpers.configMerge(defaultConfig, config.options);
				config.type = 'radar';

				return new Chart(context, config);
			};

		};

	}, {}], 14: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var defaultConfig = {
				hover: {
					mode: 'single'
				},

				scales: {
					xAxes: [{
						type: "linear", // scatter should not use a category axis
						position: "bottom",
						id: "x-axis-1" // need an ID so datasets can reference the scale
					}],
					yAxes: [{
						type: "linear",
						position: "left",
						id: "y-axis-1"
					}]
				},

				tooltips: {
					callbacks: {
						title: function (tooltipItems, data) {
							// Title doesn't make sense for scatter since we format the data as a point
							return '';
						},
						label: function (tooltipItem, data) {
							return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';
						}
					}
				}
			};

			// Register the default config for this type
			Chart.defaults.scatter = defaultConfig;

			// Scatter charts use line controllers
			Chart.controllers.scatter = Chart.controllers.line;

			Chart.Scatter = function (context, config) {
				config.type = 'scatter';
				return new Chart(context, config);
			};

		};
	}, {}], 15: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.bar = {
				hover: {
					mode: "label"
				},

				scales: {
					xAxes: [{
						type: "category",

						// Specific to Bar Controller
						categoryPercentage: 0.8,
						barPercentage: 0.9,

						// grid line settings
						gridLines: {
							offsetGridLines: true
						}
					}],
					yAxes: [{
						type: "linear"
					}]
				}
			};

			Chart.controllers.bar = Chart.DatasetController.extend({
				initialize: function (chart, datasetIndex) {
					Chart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);

					// Use this to indicate that this is a bar dataset.
					this.getMeta().bar = true;
				},
				// Get the number of datasets that display bars. We use this to correctly calculate the bar width
				getBarCount: function getBarCount() {
					var barCount = 0;
					helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
						var meta = this.chart.getDatasetMeta(datasetIndex);
						if (meta.bar && this.chart.isDatasetVisible(datasetIndex)) {
							++barCount;
						}
					}, this);
					return barCount;
				},

				addElements: function () {
					var meta = this.getMeta();
					helpers.each(this.getDataset().data, function (value, index) {
						meta.data[index] = meta.data[index] || new Chart.elements.Rectangle({
							_chart: this.chart.chart,
							_datasetIndex: this.index,
							_index: index
						});
					}, this);
				},

				addElementAndReset: function (index) {
					var rectangle = new Chart.elements.Rectangle({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index
					});

					var numBars = this.getBarCount();

					// Add to the points array and reset it
					this.getMeta().data.splice(index, 0, rectangle);
					this.updateElement(rectangle, index, true, numBars);
				},

				update: function update(reset) {
					var numBars = this.getBarCount();

					helpers.each(this.getMeta().data, function (rectangle, index) {
						this.updateElement(rectangle, index, reset, numBars);
					}, this);
				},

				updateElement: function updateElement(rectangle, index, reset, numBars) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					var yScalePoint;

					if (yScale.min < 0 && yScale.max < 0) {
						// all less than 0. use the top
						yScalePoint = yScale.getPixelForValue(yScale.max);
					} else if (yScale.min > 0 && yScale.max > 0) {
						yScalePoint = yScale.getPixelForValue(yScale.min);
					} else {
						yScalePoint = yScale.getPixelForValue(0);
					}

					helpers.extend(rectangle, {
						// Utility
						_chart: this.chart.chart,
						_xScale: xScale,
						_yScale: yScale,
						_datasetIndex: this.index,
						_index: index,


						// Desired view properties
						_model: {
							x: this.calculateBarX(index, this.index),
							y: reset ? yScalePoint : this.calculateBarY(index, this.index),

							// Tooltip
							label: this.chart.data.labels[index],
							datasetLabel: this.getDataset().label,

							// Appearance
							base: reset ? yScalePoint : this.calculateBarBase(this.index, index),
							width: this.calculateBarWidth(numBars),
							backgroundColor: rectangle.custom && rectangle.custom.backgroundColor ? rectangle.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.rectangle.backgroundColor),
							borderSkipped: rectangle.custom && rectangle.custom.borderSkipped ? rectangle.custom.borderSkipped : this.chart.options.elements.rectangle.borderSkipped,
							borderColor: rectangle.custom && rectangle.custom.borderColor ? rectangle.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.rectangle.borderColor),
							borderWidth: rectangle.custom && rectangle.custom.borderWidth ? rectangle.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.rectangle.borderWidth)
						}
					});
					rectangle.pivot();
				},

				calculateBarBase: function (datasetIndex, index) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					var base = 0;

					if (yScale.options.stacked) {

						var value = this.chart.data.datasets[datasetIndex].data[index];

						if (value < 0) {
							for (var i = 0; i < datasetIndex; i++) {
								var negDS = this.chart.data.datasets[i];
								var negDSMeta = this.chart.getDatasetMeta(i);
								if (negDSMeta.bar && negDSMeta.yAxisID === yScale.id && this.chart.isDatasetVisible(i)) {
									base += negDS.data[index] < 0 ? negDS.data[index] : 0;
								}
							}
						} else {
							for (var j = 0; j < datasetIndex; j++) {
								var posDS = this.chart.data.datasets[j];
								var posDSMeta = this.chart.getDatasetMeta(j);
								if (posDSMeta.bar && posDSMeta.yAxisID === yScale.id && this.chart.isDatasetVisible(j)) {
									base += posDS.data[index] > 0 ? posDS.data[index] : 0;
								}
							}
						}

						return yScale.getPixelForValue(base);
					}

					base = yScale.getPixelForValue(yScale.min);

					if (yScale.beginAtZero || ((yScale.min <= 0 && yScale.max >= 0) || (yScale.min >= 0 && yScale.max <= 0))) {
						base = yScale.getPixelForValue(0, 0);
						//base += yScale.options.gridLines.lineWidth;
					} else if (yScale.min < 0 && yScale.max < 0) {
						// All values are negative. Use the top as the base
						base = yScale.getPixelForValue(yScale.max);
					}

					return base;

				},

				getRuler: function () {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);
					var datasetCount = this.getBarCount();

					var tickWidth = (function () {
						var min = xScale.getPixelForTick(1) - xScale.getPixelForTick(0);
						for (var i = 2; i < xScale.ticks.length; i++) {
							min = Math.min(xScale.getPixelForTick(i) - xScale.getPixelForTick(i - 1), min);
						}
						return min;
					}).call(this);
					var categoryWidth = tickWidth * xScale.options.categoryPercentage;
					var categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;
					var fullBarWidth = categoryWidth / datasetCount;

					if (xScale.ticks.length !== this.chart.data.labels.length) {
						var perc = xScale.ticks.length / this.chart.data.labels.length;
						fullBarWidth = fullBarWidth * perc;
					}

					var barWidth = fullBarWidth * xScale.options.barPercentage;
					var barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);

					return {
						datasetCount: datasetCount,
						tickWidth: tickWidth,
						categoryWidth: categoryWidth,
						categorySpacing: categorySpacing,
						fullBarWidth: fullBarWidth,
						barWidth: barWidth,
						barSpacing: barSpacing
					};
				},

				calculateBarWidth: function () {
					var xScale = this.getScaleForId(this.getMeta().xAxisID);
					var ruler = this.getRuler();
					return xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth;
				},

				// Get bar index from the given dataset index accounting for the fact that not all bars are visible
				getBarIndex: function (datasetIndex) {
					var barIndex = 0;
					var meta, j;

					for (j = 0; j < datasetIndex; ++j) {
						meta = this.chart.getDatasetMeta(j);
						if (meta.bar && this.chart.isDatasetVisible(j)) {
							++barIndex;
						}
					}

					return barIndex;
				},

				calculateBarX: function (index, datasetIndex) {
					var meta = this.getMeta();
					var yScale = this.getScaleForId(meta.yAxisID);
					var xScale = this.getScaleForId(meta.xAxisID);
					var barIndex = this.getBarIndex(datasetIndex);

					var ruler = this.getRuler();
					var leftTick = xScale.getPixelForValue(null, index, datasetIndex, this.chart.isCombo);
					leftTick -= this.chart.isCombo ? (ruler.tickWidth / 2) : 0;

					if (xScale.options.stacked) {
						return leftTick + (ruler.categoryWidth / 2) + ruler.categorySpacing;
					}

					return leftTick +
						(ruler.barWidth / 2) +
						ruler.categorySpacing +
						(ruler.barWidth * barIndex) +
						(ruler.barSpacing / 2) +
						(ruler.barSpacing * barIndex);
				},

				calculateBarY: function (index, datasetIndex) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					var value = this.getDataset().data[index];

					if (yScale.options.stacked) {

						var sumPos = 0,
							sumNeg = 0;

						for (var i = 0; i < datasetIndex; i++) {
							var ds = this.chart.data.datasets[i];
							var dsMeta = this.chart.getDatasetMeta(i);
							if (dsMeta.bar && dsMeta.yAxisID === yScale.id && this.chart.isDatasetVisible(i)) {
								if (ds.data[index] < 0) {
									sumNeg += ds.data[index] || 0;
								} else {
									sumPos += ds.data[index] || 0;
								}
							}
						}

						if (value < 0) {
							return yScale.getPixelForValue(sumNeg + value);
						} else {
							return yScale.getPixelForValue(sumPos + value);
						}
					}

					return yScale.getPixelForValue(value);
				},

				draw: function (ease) {
					var easingDecimal = ease || 1;
					helpers.each(this.getMeta().data, function (rectangle, index) {
						var d = this.getDataset().data[index];
						if (d !== null && d !== undefined && !isNaN(d)) {
							rectangle.transition(easingDecimal).draw();
						}
					}, this);
				},

				setHoverStyle: function (rectangle) {
					var dataset = this.chart.data.datasets[rectangle._datasetIndex];
					var index = rectangle._index;

					rectangle._model.backgroundColor = rectangle.custom && rectangle.custom.hoverBackgroundColor ? rectangle.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(rectangle._model.backgroundColor));
					rectangle._model.borderColor = rectangle.custom && rectangle.custom.hoverBorderColor ? rectangle.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(rectangle._model.borderColor));
					rectangle._model.borderWidth = rectangle.custom && rectangle.custom.hoverBorderWidth ? rectangle.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, rectangle._model.borderWidth);
				},

				removeHoverStyle: function (rectangle) {
					var dataset = this.chart.data.datasets[rectangle._datasetIndex];
					var index = rectangle._index;

					rectangle._model.backgroundColor = rectangle.custom && rectangle.custom.backgroundColor ? rectangle.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.rectangle.backgroundColor);
					rectangle._model.borderColor = rectangle.custom && rectangle.custom.borderColor ? rectangle.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.rectangle.borderColor);
					rectangle._model.borderWidth = rectangle.custom && rectangle.custom.borderWidth ? rectangle.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.rectangle.borderWidth);
				}

			});


			// including horizontalBar in the bar file, instead of a file of its own
			// it extends bar (like pie extends doughnut)
			Chart.defaults.horizontalBar = {
				hover: {
					mode: "label"
				},

				scales: {
					xAxes: [{
						type: "linear",
						position: "bottom"
					}],
					yAxes: [{
						position: "left",
						type: "category",

						// Specific to Horizontal Bar Controller
						categoryPercentage: 0.8,
						barPercentage: 0.9,

						// grid line settings
						gridLines: {
							offsetGridLines: true
						}
					}]
				},
			};

			Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
				updateElement: function updateElement(rectangle, index, reset, numBars) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					var xScalePoint;

					if (xScale.min < 0 && xScale.max < 0) {
						// all less than 0. use the right
						xScalePoint = xScale.getPixelForValue(xScale.max);
					} else if (xScale.min > 0 && xScale.max > 0) {
						xScalePoint = xScale.getPixelForValue(xScale.min);
					} else {
						xScalePoint = xScale.getPixelForValue(0);
					}

					helpers.extend(rectangle, {
						// Utility
						_chart: this.chart.chart,
						_xScale: xScale,
						_yScale: yScale,
						_datasetIndex: this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: reset ? xScalePoint : this.calculateBarX(index, this.index),
							y: this.calculateBarY(index, this.index),

							// Tooltip
							label: this.chart.data.labels[index],
							datasetLabel: this.getDataset().label,

							// Appearance
							base: reset ? xScalePoint : this.calculateBarBase(this.index, index),
							height: this.calculateBarHeight(numBars),
							backgroundColor: rectangle.custom && rectangle.custom.backgroundColor ? rectangle.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.rectangle.backgroundColor),
							borderSkipped: rectangle.custom && rectangle.custom.borderSkipped ? rectangle.custom.borderSkipped : this.chart.options.elements.rectangle.borderSkipped,
							borderColor: rectangle.custom && rectangle.custom.borderColor ? rectangle.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.rectangle.borderColor),
							borderWidth: rectangle.custom && rectangle.custom.borderWidth ? rectangle.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.rectangle.borderWidth)
						},

						draw: function () {

							var ctx = this._chart.ctx;
							var vm = this._view;

							var halfHeight = vm.height / 2,
								topY = vm.y - halfHeight,
								bottomY = vm.y + halfHeight,
								right = vm.base - (vm.base - vm.x),
								halfStroke = vm.borderWidth / 2;

							// Canvas doesn't allow us to stroke inside the width so we can
							// adjust the sizes to fit if we're setting a stroke on the line
							if (vm.borderWidth) {
								topY += halfStroke;
								bottomY -= halfStroke;
								right += halfStroke;
							}

							ctx.beginPath();

							ctx.fillStyle = vm.backgroundColor;
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							// Corner points, from bottom-left to bottom-right clockwise
							// | 1 2 |
							// | 0 3 |
							var corners = [
								[vm.base, bottomY],
								[vm.base, topY],
								[right, topY],
								[right, bottomY]
							];

							// Find first (starting) corner with fallback to 'bottom'
							var borders = ['bottom', 'left', 'top', 'right'];
							var startCorner = borders.indexOf(vm.borderSkipped, 0);
							if (startCorner === -1)
								startCorner = 0;

							function cornerAt(index) {
								return corners[(startCorner + index) % 4];
							}

							// Draw rectangle from 'startCorner'
							ctx.moveTo.apply(ctx, cornerAt(0));
							for (var i = 1; i < 4; i++)
								ctx.lineTo.apply(ctx, cornerAt(i));

							ctx.fill();
							if (vm.borderWidth) {
								ctx.stroke();
							}
						},

						inRange: function (mouseX, mouseY) {
							var vm = this._view;
							var inRange = false;

							if (vm) {
								if (vm.x < vm.base) {
									inRange = (mouseY >= vm.y - vm.height / 2 && mouseY <= vm.y + vm.height / 2) && (mouseX >= vm.x && mouseX <= vm.base);
								} else {
									inRange = (mouseY >= vm.y - vm.height / 2 && mouseY <= vm.y + vm.height / 2) && (mouseX >= vm.base && mouseX <= vm.x);
								}
							}

							return inRange;
						}
					});

					rectangle.pivot();
				},

				calculateBarBase: function (datasetIndex, index) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					var base = 0;

					if (xScale.options.stacked) {

						var value = this.chart.data.datasets[datasetIndex].data[index];

						if (value < 0) {
							for (var i = 0; i < datasetIndex; i++) {
								var negDS = this.chart.data.datasets[i];
								var negDSMeta = this.chart.getDatasetMeta(i);
								if (negDSMeta.bar && negDSMeta.xAxisID === xScale.id && this.chart.isDatasetVisible(i)) {
									base += negDS.data[index] < 0 ? negDS.data[index] : 0;
								}
							}
						} else {
							for (var j = 0; j < datasetIndex; j++) {
								var posDS = this.chart.data.datasets[j];
								var posDSMeta = this.chart.getDatasetMeta(j);
								if (posDSMeta.bar && posDSMeta.xAxisID === xScale.id && this.chart.isDatasetVisible(j)) {
									base += posDS.data[index] > 0 ? posDS.data[index] : 0;
								}
							}
						}

						return xScale.getPixelForValue(base);
					}

					base = xScale.getPixelForValue(xScale.min);

					if (xScale.beginAtZero || ((xScale.min <= 0 && xScale.max >= 0) || (xScale.min >= 0 && xScale.max <= 0))) {
						base = xScale.getPixelForValue(0, 0);
					} else if (xScale.min < 0 && xScale.max < 0) {
						// All values are negative. Use the right as the base
						base = xScale.getPixelForValue(xScale.max);
					}

					return base;
				},

				getRuler: function () {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);
					var datasetCount = this.getBarCount();

					var tickHeight = (function () {
						var min = yScale.getPixelForTick(1) - yScale.getPixelForTick(0);
						for (var i = 2; i < this.getDataset().data.length; i++) {
							min = Math.min(yScale.getPixelForTick(i) - yScale.getPixelForTick(i - 1), min);
						}
						return min;
					}).call(this);
					var categoryHeight = tickHeight * yScale.options.categoryPercentage;
					var categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;
					var fullBarHeight = categoryHeight / datasetCount;

					if (yScale.ticks.length !== this.chart.data.labels.length) {
						var perc = yScale.ticks.length / this.chart.data.labels.length;
						fullBarHeight = fullBarHeight * perc;
					}

					var barHeight = fullBarHeight * yScale.options.barPercentage;
					var barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);

					return {
						datasetCount: datasetCount,
						tickHeight: tickHeight,
						categoryHeight: categoryHeight,
						categorySpacing: categorySpacing,
						fullBarHeight: fullBarHeight,
						barHeight: barHeight,
						barSpacing: barSpacing,
					};
				},

				calculateBarHeight: function () {
					var yScale = this.getScaleForId(this.getMeta().yAxisID);
					var ruler = this.getRuler();
					return yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight;
				},

				calculateBarX: function (index, datasetIndex) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					var value = this.getDataset().data[index];

					if (xScale.options.stacked) {

						var sumPos = 0,
							sumNeg = 0;

						for (var i = 0; i < datasetIndex; i++) {
							var ds = this.chart.data.datasets[i];
							var dsMeta = this.chart.getDatasetMeta(i);
							if (dsMeta.bar && dsMeta.xAxisID === xScale.id && this.chart.isDatasetVisible(i)) {
								if (ds.data[index] < 0) {
									sumNeg += ds.data[index] || 0;
								} else {
									sumPos += ds.data[index] || 0;
								}
							}
						}

						if (value < 0) {
							return xScale.getPixelForValue(sumNeg + value);
						} else {
							return xScale.getPixelForValue(sumPos + value);
						}
					}

					return xScale.getPixelForValue(value);
				},

				calculateBarY: function (index, datasetIndex) {
					var meta = this.getMeta();
					var yScale = this.getScaleForId(meta.yAxisID);
					var xScale = this.getScaleForId(meta.xAxisID);
					var barIndex = this.getBarIndex(datasetIndex);

					var ruler = this.getRuler();
					var topTick = yScale.getPixelForValue(null, index, datasetIndex, this.chart.isCombo);
					topTick -= this.chart.isCombo ? (ruler.tickHeight / 2) : 0;

					if (yScale.options.stacked) {
						return topTick + (ruler.categoryHeight / 2) + ruler.categorySpacing;
					}

					return topTick +
						(ruler.barHeight / 2) +
						ruler.categorySpacing +
						(ruler.barHeight * barIndex) +
						(ruler.barSpacing / 2) +
						(ruler.barSpacing * barIndex);
				}
			});
		};

	}, {}], 16: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.bubble = {
				hover: {
					mode: "single"
				},

				scales: {
					xAxes: [{
						type: "linear", // bubble should probably use a linear scale by default
						position: "bottom",
						id: "x-axis-0" // need an ID so datasets can reference the scale
					}],
					yAxes: [{
						type: "linear",
						position: "left",
						id: "y-axis-0"
					}]
				},

				tooltips: {
					callbacks: {
						title: function (tooltipItems, data) {
							// Title doesn't make sense for scatter since we format the data as a point
							return '';
						},
						label: function (tooltipItem, data) {
							var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
							var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
							return datasetLabel + ': (' + dataPoint.x + ', ' + dataPoint.y + ', ' + dataPoint.r + ')';
						}
					}
				}
			};


			Chart.controllers.bubble = Chart.DatasetController.extend({
				addElements: function () {
					var meta = this.getMeta();
					helpers.each(this.getDataset().data, function (value, index) {
						meta.data[index] = meta.data[index] || new Chart.elements.Point({
							_chart: this.chart.chart,
							_datasetIndex: this.index,
							_index: index
						});
					}, this);
				},
				addElementAndReset: function (index) {
					var point = new Chart.elements.Point({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index
					});

					// Add to the points array and reset it
					this.getMeta().data.splice(index, 0, point);
					this.updateElement(point, index, true);
				},

				update: function update(reset) {
					var meta = this.getMeta();
					var points = meta.data;
					var yScale = this.getScaleForId(meta.yAxisID);
					var xScale = this.getScaleForId(meta.xAxisID);
					var scaleBase;

					if (yScale.min < 0 && yScale.max < 0) {
						scaleBase = yScale.getPixelForValue(yScale.max);
					} else if (yScale.min > 0 && yScale.max > 0) {
						scaleBase = yScale.getPixelForValue(yScale.min);
					} else {
						scaleBase = yScale.getPixelForValue(0);
					}

					// Update Points
					helpers.each(points, function (point, index) {
						this.updateElement(point, index, reset);
					}, this);

				},

				updateElement: function (point, index, reset) {
					var meta = this.getMeta();
					var yScale = this.getScaleForId(meta.yAxisID);
					var xScale = this.getScaleForId(meta.xAxisID);
					var scaleBase;

					if (yScale.min < 0 && yScale.max < 0) {
						scaleBase = yScale.getPixelForValue(yScale.max);
					} else if (yScale.min > 0 && yScale.max > 0) {
						scaleBase = yScale.getPixelForValue(yScale.min);
					} else {
						scaleBase = yScale.getPixelForValue(0);
					}

					helpers.extend(point, {
						// Utility
						_chart: this.chart.chart,
						_xScale: xScale,
						_yScale: yScale,
						_datasetIndex: this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(this.getDataset().data[index], index, this.index, this.chart.isCombo),
							y: reset ? scaleBase : yScale.getPixelForValue(this.getDataset().data[index], index, this.index),
							// Appearance
							radius: reset ? 0 : point.custom && point.custom.radius ? point.custom.radius : this.getRadius(this.getDataset().data[index]),
							backgroundColor: point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.point.backgroundColor),
							borderColor: point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.point.borderColor),
							borderWidth: point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.point.borderWidth),

							// Tooltip
							hitRadius: point.custom && point.custom.hitRadius ? point.custom.hitRadius : helpers.getValueAtIndexOrDefault(this.getDataset().hitRadius, index, this.chart.options.elements.point.hitRadius)
						}
					});

					point._model.skip = point.custom && point.custom.skip ? point.custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));

					point.pivot();
				},

				getRadius: function (value) {
					return value.r || this.chart.options.elements.point.radius;
				},

				draw: function (ease) {
					var easingDecimal = ease || 1;

					// Transition and Draw the Points
					helpers.each(this.getMeta().data, function (point, index) {
						point.transition(easingDecimal);
						point.draw();
					});

				},

				setHoverStyle: function (point) {
					// Point
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var index = point._index;

					point._model.radius = point.custom && point.custom.hoverRadius ? point.custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, this.chart.options.elements.point.hoverRadius)) + this.getRadius(this.getDataset().data[point._index]);
					point._model.backgroundColor = point.custom && point.custom.hoverBackgroundColor ? point.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(point._model.backgroundColor));
					point._model.borderColor = point.custom && point.custom.hoverBorderColor ? point.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(point._model.borderColor));
					point._model.borderWidth = point.custom && point.custom.hoverBorderWidth ? point.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, point._model.borderWidth);
				},

				removeHoverStyle: function (point) {
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var index = point._index;

					point._model.radius = point.custom && point.custom.radius ? point.custom.radius : this.getRadius(this.getDataset().data[point._index]);
					point._model.backgroundColor = point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.point.backgroundColor);
					point._model.borderColor = point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.point.borderColor);
					point._model.borderWidth = point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.point.borderWidth);
				}
			});
		};

	}, {}], 17: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.doughnut = {
				animation: {
					//Boolean - Whether we animate the rotation of the Doughnut
					animateRotate: true,
					//Boolean - Whether we animate scaling the Doughnut from the centre
					animateScale: false
				},
				aspectRatio: 1,
				hover: {
					mode: 'single'
				},
				legendCallback: function (chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');

					if (chart.data.datasets.length) {
						for (var i = 0; i < chart.data.datasets[0].data.length; ++i) {
							text.push('<li><span style="background-color:' + chart.data.datasets[0].backgroundColor[i] + '"></span>');
							if (chart.data.labels[i]) {
								text.push(chart.data.labels[i]);
							}
							text.push('</li>');
						}
					}

					text.push('</ul>');
					return text.join("");
				},
				legend: {
					labels: {
						generateLabels: function (chart) {
							var data = chart.data;
							if (data.labels.length && data.datasets.length) {
								return data.labels.map(function (label, i) {
									var meta = chart.getDatasetMeta(0);
									var ds = data.datasets[0];
									var arc = meta.data[i];
									var fill = arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(ds.backgroundColor, i, this.chart.options.elements.arc.backgroundColor);
									var stroke = arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(ds.borderColor, i, this.chart.options.elements.arc.borderColor);
									var bw = arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(ds.borderWidth, i, this.chart.options.elements.arc.borderWidth);

									return {
										text: label,
										fillStyle: fill,
										strokeStyle: stroke,
										lineWidth: bw,
										hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

										// Extra data used for toggling the correct item
										index: i
									};
								}, this);
							} else {
								return [];
							}
						}
					},

					onClick: function (e, legendItem) {
						var index = legendItem.index;
						var chart = this.chart;
						var i, ilen, meta;

						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							meta.data[index].hidden = !meta.data[index].hidden;
						}

						chart.update();
					}
				},

				//The percentage of the chart that we cut out of the middle.
				cutoutPercentage: 50,

				//The rotation of the chart, where the first data arc begins.
				rotation: Math.PI * -0.5,

				//The total circumference of the chart.
				circumference: Math.PI * 2.0,

				// Need to override these to give a nice default
				tooltips: {
					callbacks: {
						title: function () {
							return '';
						},
						label: function (tooltipItem, data) {
							return data.labels[tooltipItem.index] + ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
						}
					}
				}
			};

			Chart.defaults.pie = helpers.clone(Chart.defaults.doughnut);
			helpers.extend(Chart.defaults.pie, {
				cutoutPercentage: 0
			});


			Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
				linkScales: function () {
					// no scales for doughnut
				},

				addElements: function () {
					var meta = this.getMeta();
					helpers.each(this.getDataset().data, function (value, index) {
						meta.data[index] = meta.data[index] || new Chart.elements.Arc({
							_chart: this.chart.chart,
							_datasetIndex: this.index,
							_index: index
						});
					}, this);
				},

				addElementAndReset: function (index, colorForNewElement) {
					var arc = new Chart.elements.Arc({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index
					});

					if (colorForNewElement && helpers.isArray(this.getDataset().backgroundColor)) {
						this.getDataset().backgroundColor.splice(index, 0, colorForNewElement);
					}

					// Add to the points array and reset it
					this.getMeta().data.splice(index, 0, arc);
					this.updateElement(arc, index, true);
				},

				// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
				getRingIndex: function getRingIndex(datasetIndex) {
					var ringIndex = 0;

					for (var j = 0; j < datasetIndex; ++j) {
						if (this.chart.isDatasetVisible(j)) {
							++ringIndex;
						}
					}

					return ringIndex;
				},

				update: function update(reset) {
					var availableWidth = this.chart.chartArea.right - this.chart.chartArea.left - this.chart.options.elements.arc.borderWidth;
					var availableHeight = this.chart.chartArea.bottom - this.chart.chartArea.top - this.chart.options.elements.arc.borderWidth;
					var minSize = Math.min(availableWidth, availableHeight);
					var offset = { x: 0, y: 0 };

					// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
					if (this.chart.options.circumference < Math.PI * 2.0) {
						var startAngle = this.chart.options.rotation % (Math.PI * 2.0);
						startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
						var endAngle = startAngle + this.chart.options.circumference;
						var start = { x: Math.cos(startAngle), y: Math.sin(startAngle) };
						var end = { x: Math.cos(endAngle), y: Math.sin(endAngle) };
						var contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
						var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
						var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
						var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
						var cutout = this.chart.options.cutoutPercentage / 100.0;
						var min = { x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout)) };
						var max = { x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout)) };
						var size = { width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5 };
						minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
						offset = { x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5 };
					}

					this.chart.outerRadius = Math.max(minSize / 2, 0);
					this.chart.innerRadius = Math.max(this.chart.options.cutoutPercentage ? (this.chart.outerRadius / 100) * (this.chart.options.cutoutPercentage) : 1, 0);
					this.chart.radiusLength = (this.chart.outerRadius - this.chart.innerRadius) / this.chart.getVisibleDatasetCount();
					this.chart.offsetX = offset.x * this.chart.outerRadius;
					this.chart.offsetY = offset.y * this.chart.outerRadius;

					this.getMeta().total = this.calculateTotal();

					this.outerRadius = this.chart.outerRadius - (this.chart.radiusLength * this.getRingIndex(this.index));
					this.innerRadius = this.outerRadius - this.chart.radiusLength;

					helpers.each(this.getMeta().data, function (arc, index) {
						this.updateElement(arc, index, reset);
					}, this);
				},

				updateElement: function (arc, index, reset) {
					var centerX = (this.chart.chartArea.left + this.chart.chartArea.right) / 2;
					var centerY = (this.chart.chartArea.top + this.chart.chartArea.bottom) / 2;
					var startAngle = this.chart.options.rotation; // non reset case handled later
					var endAngle = this.chart.options.rotation; // non reset case handled later
					var circumference = reset && this.chart.options.animation.animateRotate ? 0 : arc.hidden ? 0 : this.calculateCircumference(this.getDataset().data[index]) * (this.chart.options.circumference / (2.0 * Math.PI));
					var innerRadius = reset && this.chart.options.animation.animateScale ? 0 : this.innerRadius;
					var outerRadius = reset && this.chart.options.animation.animateScale ? 0 : this.outerRadius;

					helpers.extend(arc, {
						// Utility
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + this.chart.offsetX,
							y: centerY + this.chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,

							backgroundColor: arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor),
							hoverBackgroundColor: arc.custom && arc.custom.hoverBackgroundColor ? arc.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().hoverBackgroundColor, index, this.chart.options.elements.arc.hoverBackgroundColor),
							borderWidth: arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth),
							borderColor: arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor),

							label: helpers.getValueAtIndexOrDefault(this.getDataset().label, index, this.chart.data.labels[index])
						}
					});

					// Set correct angles if not resetting
					if (!reset || !this.chart.options.animation.animateRotate) {

						if (index === 0) {
							arc._model.startAngle = this.chart.options.rotation;
						} else {
							arc._model.startAngle = this.getMeta().data[index - 1]._model.endAngle;
						}

						arc._model.endAngle = arc._model.startAngle + arc._model.circumference;
					}

					arc.pivot();
				},

				draw: function (ease) {
					var easingDecimal = ease || 1;
					helpers.each(this.getMeta().data, function (arc, index) {
						arc.transition(easingDecimal).draw();
					});
				},

				setHoverStyle: function (arc) {
					var dataset = this.chart.data.datasets[arc._datasetIndex];
					var index = arc._index;

					arc._model.backgroundColor = arc.custom && arc.custom.hoverBackgroundColor ? arc.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(arc._model.backgroundColor));
					arc._model.borderColor = arc.custom && arc.custom.hoverBorderColor ? arc.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(arc._model.borderColor));
					arc._model.borderWidth = arc.custom && arc.custom.hoverBorderWidth ? arc.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, arc._model.borderWidth);
				},

				removeHoverStyle: function (arc) {
					var dataset = this.chart.data.datasets[arc._datasetIndex];
					var index = arc._index;

					arc._model.backgroundColor = arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor);
					arc._model.borderColor = arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor);
					arc._model.borderWidth = arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth);
				},

				calculateTotal: function () {
					var dataset = this.getDataset();
					var meta = this.getMeta();
					var total = 0;
					var value;

					helpers.each(meta.data, function (element, index) {
						value = dataset.data[index];
						if (!isNaN(value) && !element.hidden) {
							total += Math.abs(value);
						}
					});

					return total;
				},

				calculateCircumference: function (value) {
					var total = this.getMeta().total;
					if (total > 0 && !isNaN(value)) {
						return (Math.PI * 2.0) * (value / total);
					} else {
						return 0;
					}
				}
			});
		};

	}, {}], 18: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.line = {
				showLines: true,

				hover: {
					mode: "label"
				},

				scales: {
					xAxes: [{
						type: "category",
						id: 'x-axis-0'
					}],
					yAxes: [{
						type: "linear",
						id: 'y-axis-0'
					}]
				}
			};


			Chart.controllers.line = Chart.DatasetController.extend({
				addElements: function () {
					var meta = this.getMeta();
					meta.dataset = meta.dataset || new Chart.elements.Line({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_points: meta.data
					});

					helpers.each(this.getDataset().data, function (value, index) {
						meta.data[index] = meta.data[index] || new Chart.elements.Point({
							_chart: this.chart.chart,
							_datasetIndex: this.index,
							_index: index
						});
					}, this);
				},

				addElementAndReset: function (index) {
					var point = new Chart.elements.Point({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index
					});

					// Add to the points array and reset it
					this.getMeta().data.splice(index, 0, point);
					this.updateElement(point, index, true);

					// Make sure bezier control points are updated
					if (this.chart.options.showLines && this.chart.options.elements.line.tension !== 0)
						this.updateBezierControlPoints();
				},

				update: function update(reset) {
					var meta = this.getMeta();
					var line = meta.dataset;
					var points = meta.data;

					var yScale = this.getScaleForId(meta.yAxisID);
					var xScale = this.getScaleForId(meta.xAxisID);
					var scaleBase;

					if (yScale.min < 0 && yScale.max < 0) {
						scaleBase = yScale.getPixelForValue(yScale.max);
					} else if (yScale.min > 0 && yScale.max > 0) {
						scaleBase = yScale.getPixelForValue(yScale.min);
					} else {
						scaleBase = yScale.getPixelForValue(0);
					}

					// Update Line
					if (this.chart.options.showLines) {
						// Utility
						line._scale = yScale;
						line._datasetIndex = this.index;
						// Data
						line._children = points;
						// Model

						// Compatibility: If the properties are defined with only the old name, use those values
						if ((this.getDataset().tension !== undefined) && (this.getDataset().lineTension === undefined)) {
							this.getDataset().lineTension = this.getDataset().tension;
						}

						line._model = {
							// Appearance
							tension: line.custom && line.custom.tension ? line.custom.tension : helpers.getValueOrDefault(this.getDataset().lineTension, this.chart.options.elements.line.tension),
							backgroundColor: line.custom && line.custom.backgroundColor ? line.custom.backgroundColor : (this.getDataset().backgroundColor || this.chart.options.elements.line.backgroundColor),
							borderWidth: line.custom && line.custom.borderWidth ? line.custom.borderWidth : (this.getDataset().borderWidth || this.chart.options.elements.line.borderWidth),
							borderColor: line.custom && line.custom.borderColor ? line.custom.borderColor : (this.getDataset().borderColor || this.chart.options.elements.line.borderColor),
							borderCapStyle: line.custom && line.custom.borderCapStyle ? line.custom.borderCapStyle : (this.getDataset().borderCapStyle || this.chart.options.elements.line.borderCapStyle),
							borderDash: line.custom && line.custom.borderDash ? line.custom.borderDash : (this.getDataset().borderDash || this.chart.options.elements.line.borderDash),
							borderDashOffset: line.custom && line.custom.borderDashOffset ? line.custom.borderDashOffset : (this.getDataset().borderDashOffset || this.chart.options.elements.line.borderDashOffset),
							borderJoinStyle: line.custom && line.custom.borderJoinStyle ? line.custom.borderJoinStyle : (this.getDataset().borderJoinStyle || this.chart.options.elements.line.borderJoinStyle),
							fill: line.custom && line.custom.fill ? line.custom.fill : (this.getDataset().fill !== undefined ? this.getDataset().fill : this.chart.options.elements.line.fill),
							// Scale
							scaleTop: yScale.top,
							scaleBottom: yScale.bottom,
							scaleZero: scaleBase
						};
						line.pivot();
					}

					// Update Points
					helpers.each(points, function (point, index) {
						this.updateElement(point, index, reset);
					}, this);

					if (this.chart.options.showLines && this.chart.options.elements.line.tension !== 0)
						this.updateBezierControlPoints();
				},

				getPointBackgroundColor: function (point, index) {
					var backgroundColor = this.chart.options.elements.point.backgroundColor;
					var dataset = this.getDataset();

					if (point.custom && point.custom.backgroundColor) {
						backgroundColor = point.custom.backgroundColor;
					} else if (dataset.pointBackgroundColor) {
						backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
					} else if (dataset.backgroundColor) {
						backgroundColor = dataset.backgroundColor;
					}

					return backgroundColor;
				},
				getPointBorderColor: function (point, index) {
					var borderColor = this.chart.options.elements.point.borderColor;
					var dataset = this.getDataset();

					if (point.custom && point.custom.borderColor) {
						borderColor = point.custom.borderColor;
					} else if (dataset.pointBorderColor) {
						borderColor = helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderColor, index, borderColor);
					} else if (dataset.borderColor) {
						borderColor = dataset.borderColor;
					}

					return borderColor;
				},
				getPointBorderWidth: function (point, index) {
					var borderWidth = this.chart.options.elements.point.borderWidth;
					var dataset = this.getDataset();

					if (point.custom && point.custom.borderWidth !== undefined) {
						borderWidth = point.custom.borderWidth;
					} else if (dataset.pointBorderWidth !== undefined) {
						borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
					} else if (dataset.borderWidth !== undefined) {
						borderWidth = dataset.borderWidth;
					}

					return borderWidth;
				},

				updateElement: function (point, index, reset) {
					var meta = this.getMeta();
					var yScale = this.getScaleForId(meta.yAxisID);
					var xScale = this.getScaleForId(meta.xAxisID);
					var scaleBase;

					if (yScale.min < 0 && yScale.max < 0) {
						scaleBase = yScale.getPixelForValue(yScale.max);
					} else if (yScale.min > 0 && yScale.max > 0) {
						scaleBase = yScale.getPixelForValue(yScale.min);
					} else {
						scaleBase = yScale.getPixelForValue(0);
					}

					// Utility
					point._chart = this.chart.chart;
					point._xScale = xScale;
					point._yScale = yScale;
					point._datasetIndex = this.index;
					point._index = index;

					// Desired view properties

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((this.getDataset().radius !== undefined) && (this.getDataset().pointRadius === undefined)) {
						this.getDataset().pointRadius = this.getDataset().radius;
					}
					if ((this.getDataset().hitRadius !== undefined) && (this.getDataset().pointHitRadius === undefined)) {
						this.getDataset().pointHitRadius = this.getDataset().hitRadius;
					}

					point._model = {
						x: xScale.getPixelForValue(this.getDataset().data[index], index, this.index, this.chart.isCombo),
						y: reset ? scaleBase : this.calculatePointY(this.getDataset().data[index], index, this.index, this.chart.isCombo),
						// Appearance
						radius: point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().pointRadius, index, this.chart.options.elements.point.radius),
						pointStyle: point.custom && point.custom.pointStyle ? point.custom.pointStyle : helpers.getValueAtIndexOrDefault(this.getDataset().pointStyle, index, this.chart.options.elements.point.pointStyle),
						backgroundColor: this.getPointBackgroundColor(point, index),
						borderColor: this.getPointBorderColor(point, index),
						borderWidth: this.getPointBorderWidth(point, index),
						tension: meta.dataset._model ? meta.dataset._model.tension : 0,
						// Tooltip
						hitRadius: point.custom && point.custom.hitRadius ? point.custom.hitRadius : helpers.getValueAtIndexOrDefault(this.getDataset().pointHitRadius, index, this.chart.options.elements.point.hitRadius)
					};

					point._model.skip = point.custom && point.custom.skip ? point.custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
				},

				calculatePointY: function (value, index, datasetIndex, isCombo) {
					var meta = this.getMeta();
					var xScale = this.getScaleForId(meta.xAxisID);
					var yScale = this.getScaleForId(meta.yAxisID);

					if (yScale.options.stacked) {

						var sumPos = 0,
							sumNeg = 0;

						for (var i = 0; i < datasetIndex; i++) {
							var ds = this.chart.data.datasets[i];
							var dsMeta = this.chart.getDatasetMeta(i);
							if (dsMeta.type === 'line' && this.chart.isDatasetVisible(i)) {
								if (ds.data[index] < 0) {
									sumNeg += ds.data[index] || 0;
								} else {
									sumPos += ds.data[index] || 0;
								}
							}
						}

						if (value < 0) {
							return yScale.getPixelForValue(sumNeg + value);
						} else {
							return yScale.getPixelForValue(sumPos + value);
						}
					}

					return yScale.getPixelForValue(value);
				},

				updateBezierControlPoints: function () {
					// Update bezier control points
					var meta = this.getMeta();
					helpers.each(meta.data, function (point, index) {
						var controlPoints = helpers.splineCurve(
							helpers.previousItem(meta.data, index)._model,
							point._model,
							helpers.nextItem(meta.data, index)._model,
							meta.dataset._model.tension
						);

						// Prevent the bezier going outside of the bounds of the graph
						point._model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, this.chart.chartArea.right), this.chart.chartArea.left);
						point._model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, this.chart.chartArea.bottom), this.chart.chartArea.top);

						point._model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, this.chart.chartArea.right), this.chart.chartArea.left);
						point._model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, this.chart.chartArea.bottom), this.chart.chartArea.top);

						// Now pivot the point for animation
						point.pivot();
					}, this);
				},

				draw: function (ease) {
					var meta = this.getMeta();
					var easingDecimal = ease || 1;

					// Transition Point Locations
					helpers.each(meta.data, function (point) {
						point.transition(easingDecimal);
					});

					// Transition and Draw the line
					if (this.chart.options.showLines)
						meta.dataset.transition(easingDecimal).draw();

					// Draw the points
					helpers.each(meta.data, function (point) {
						point.draw();
					});
				},

				setHoverStyle: function (point) {
					// Point
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var index = point._index;

					point._model.radius = point.custom && point.custom.hoverRadius ? point.custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
					point._model.backgroundColor = point.custom && point.custom.hoverBackgroundColor ? point.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(point._model.backgroundColor));
					point._model.borderColor = point.custom && point.custom.hoverBorderColor ? point.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(point._model.borderColor));
					point._model.borderWidth = point.custom && point.custom.hoverBorderWidth ? point.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, point._model.borderWidth);
				},

				removeHoverStyle: function (point) {
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var index = point._index;

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((this.getDataset().radius !== undefined) && (this.getDataset().pointRadius === undefined)) {
						this.getDataset().pointRadius = this.getDataset().radius;
					}

					point._model.radius = point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().pointRadius, index, this.chart.options.elements.point.radius);
					point._model.backgroundColor = this.getPointBackgroundColor(point, index);
					point._model.borderColor = this.getPointBorderColor(point, index);
					point._model.borderWidth = this.getPointBorderWidth(point, index);
				}
			});
		};

	}, {}], 19: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.polarArea = {

				scale: {
					type: "radialLinear",
					lineArc: true // so that lines are circular
				},

				//Boolean - Whether to animate the rotation of the chart
				animation: {
					animateRotate: true,
					animateScale: true
				},

				aspectRatio: 1,
				legendCallback: function (chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');

					if (chart.data.datasets.length) {
						for (var i = 0; i < chart.data.datasets[0].data.length; ++i) {
							text.push('<li><span style="background-color:' + chart.data.datasets[0].backgroundColor[i] + '">');
							if (chart.data.labels[i]) {
								text.push(chart.data.labels[i]);
							}
							text.push('</span></li>');
						}
					}

					text.push('</ul>');
					return text.join("");
				},
				legend: {
					labels: {
						generateLabels: function (chart) {
							var data = chart.data;
							if (data.labels.length && data.datasets.length) {
								return data.labels.map(function (label, i) {
									var meta = chart.getDatasetMeta(0);
									var ds = data.datasets[0];
									var arc = meta.data[i];
									var fill = arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(ds.backgroundColor, i, this.chart.options.elements.arc.backgroundColor);
									var stroke = arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(ds.borderColor, i, this.chart.options.elements.arc.borderColor);
									var bw = arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(ds.borderWidth, i, this.chart.options.elements.arc.borderWidth);

									return {
										text: label,
										fillStyle: fill,
										strokeStyle: stroke,
										lineWidth: bw,
										hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

										// Extra data used for toggling the correct item
										index: i
									};
								}, this);
							} else {
								return [];
							}
						}
					},

					onClick: function (e, legendItem) {
						var index = legendItem.index;
						var chart = this.chart;
						var i, ilen, meta;

						for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
							meta = chart.getDatasetMeta(i);
							meta.data[index].hidden = !meta.data[index].hidden;
						}

						chart.update();
					}
				},

				// Need to override these to give a nice default
				tooltips: {
					callbacks: {
						title: function () {
							return '';
						},
						label: function (tooltipItem, data) {
							return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;
						}
					}
				}
			};

			Chart.controllers.polarArea = Chart.DatasetController.extend({
				linkScales: function () {
					// no scales for doughnut
				},

				addElements: function () {
					var meta = this.getMeta();
					helpers.each(this.getDataset().data, function (value, index) {
						meta.data[index] = meta.data[index] || new Chart.elements.Arc({
							_chart: this.chart.chart,
							_datasetIndex: this.index,
							_index: index
						});
					}, this);
				},

				addElementAndReset: function (index) {
					var arc = new Chart.elements.Arc({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index
					});

					// Add to the points array and reset it
					this.getMeta().data.splice(index, 0, arc);
					this.updateElement(arc, index, true);
				},

				update: function update(reset) {
					var meta = this.getMeta();
					var minSize = Math.min(this.chart.chartArea.right - this.chart.chartArea.left, this.chart.chartArea.bottom - this.chart.chartArea.top);
					this.chart.outerRadius = Math.max((minSize - this.chart.options.elements.arc.borderWidth / 2) / 2, 0);
					this.chart.innerRadius = Math.max(this.chart.options.cutoutPercentage ? (this.chart.outerRadius / 100) * (this.chart.options.cutoutPercentage) : 1, 0);
					this.chart.radiusLength = (this.chart.outerRadius - this.chart.innerRadius) / this.chart.getVisibleDatasetCount();

					this.outerRadius = this.chart.outerRadius - (this.chart.radiusLength * this.index);
					this.innerRadius = this.outerRadius - this.chart.radiusLength;

					meta.count = this.countVisibleElements();

					helpers.each(meta.data, function (arc, index) {
						this.updateElement(arc, index, reset);
					}, this);
				},

				updateElement: function (arc, index, reset) {
					var circumference = this.calculateCircumference(this.getDataset().data[index]);
					var centerX = (this.chart.chartArea.left + this.chart.chartArea.right) / 2;
					var centerY = (this.chart.chartArea.top + this.chart.chartArea.bottom) / 2;

					// If there is NaN data before us, we need to calculate the starting angle correctly.
					// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
					var visibleCount = 0;
					var meta = this.getMeta();
					for (var i = 0; i < index; ++i) {
						if (!isNaN(this.getDataset().data[i]) && !meta.data[i].hidden) {
							++visibleCount;
						}
					}

					var distance = arc.hidden ? 0 : this.chart.scale.getDistanceFromCenterForValue(this.getDataset().data[index]);
					var startAngle = (-0.5 * Math.PI) + (circumference * visibleCount);
					var endAngle = startAngle + (arc.hidden ? 0 : circumference);

					var resetModel = {
						x: centerX,
						y: centerY,
						innerRadius: 0,
						outerRadius: this.chart.options.animation.animateScale ? 0 : this.chart.scale.getDistanceFromCenterForValue(this.getDataset().data[index]),
						startAngle: this.chart.options.animation.animateRotate ? Math.PI * -0.5 : startAngle,
						endAngle: this.chart.options.animation.animateRotate ? Math.PI * -0.5 : endAngle,

						backgroundColor: arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor),
						borderWidth: arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth),
						borderColor: arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor),

						label: helpers.getValueAtIndexOrDefault(this.chart.data.labels, index, this.chart.data.labels[index])
					};

					helpers.extend(arc, {
						// Utility
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index,
						_scale: this.chart.scale,

						// Desired view properties
						_model: reset ? resetModel : {
							x: centerX,
							y: centerY,
							innerRadius: 0,
							outerRadius: distance,
							startAngle: startAngle,
							endAngle: endAngle,

							backgroundColor: arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor),
							borderWidth: arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth),
							borderColor: arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor),

							label: helpers.getValueAtIndexOrDefault(this.chart.data.labels, index, this.chart.data.labels[index])
						}
					});

					arc.pivot();
				},

				draw: function (ease) {
					var easingDecimal = ease || 1;
					helpers.each(this.getMeta().data, function (arc, index) {
						arc.transition(easingDecimal).draw();
					});
				},

				setHoverStyle: function (arc) {
					var dataset = this.chart.data.datasets[arc._datasetIndex];
					var index = arc._index;

					arc._model.backgroundColor = arc.custom && arc.custom.hoverBackgroundColor ? arc.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(arc._model.backgroundColor));
					arc._model.borderColor = arc.custom && arc.custom.hoverBorderColor ? arc.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(arc._model.borderColor));
					arc._model.borderWidth = arc.custom && arc.custom.hoverBorderWidth ? arc.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, arc._model.borderWidth);
				},

				removeHoverStyle: function (arc) {
					var dataset = this.chart.data.datasets[arc._datasetIndex];
					var index = arc._index;

					arc._model.backgroundColor = arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor);
					arc._model.borderColor = arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor);
					arc._model.borderWidth = arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth);
				},

				countVisibleElements: function () {
					var dataset = this.getDataset();
					var meta = this.getMeta();
					var count = 0;

					helpers.each(meta.data, function (element, index) {
						if (!isNaN(dataset.data[index]) && !element.hidden) {
							count++;
						}
					});

					return count;
				},

				calculateCircumference: function (value) {
					var count = this.getMeta().count;
					if (count > 0 && !isNaN(value)) {
						return (2 * Math.PI) / count;
					} else {
						return 0;
					}
				}
			});
		};

	}, {}], 20: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;


			Chart.defaults.radar = {
				scale: {
					type: "radialLinear"
				},
				elements: {
					line: {
						tension: 0 // no bezier in radar
					}
				}
			};

			Chart.controllers.radar = Chart.DatasetController.extend({
				linkScales: function () {
					// No need. Single scale only
				},

				addElements: function () {
					var meta = this.getMeta();

					meta.dataset = meta.dataset || new Chart.elements.Line({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_points: meta.data,
						_loop: true
					});

					helpers.each(this.getDataset().data, function (value, index) {
						meta.data[index] = meta.data[index] || new Chart.elements.Point({
							_chart: this.chart.chart,
							_datasetIndex: this.index,
							_index: index,
							_model: {
								x: 0, //xScale.getPixelForValue(null, index, true),
								y: 0 //this.chartArea.bottom,
							}
						});
					}, this);
				},
				addElementAndReset: function (index) {
					var point = new Chart.elements.Point({
						_chart: this.chart.chart,
						_datasetIndex: this.index,
						_index: index
					});

					// Add to the points array and reset it
					this.getMeta().data.splice(index, 0, point);
					this.updateElement(point, index, true);

					// Make sure bezier control points are updated
					this.updateBezierControlPoints();
				},

				update: function update(reset) {
					var meta = this.getMeta();
					var line = meta.dataset;
					var points = meta.data;

					var scale = this.chart.scale;
					var scaleBase;

					if (scale.min < 0 && scale.max < 0) {
						scaleBase = scale.getPointPositionForValue(0, scale.max);
					} else if (scale.min > 0 && scale.max > 0) {
						scaleBase = scale.getPointPositionForValue(0, scale.min);
					} else {
						scaleBase = scale.getPointPositionForValue(0, 0);
					}

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((this.getDataset().tension !== undefined) && (this.getDataset().lineTension === undefined)) {
						this.getDataset().lineTension = this.getDataset().tension;
					}

					helpers.extend(meta.dataset, {
						// Utility
						_datasetIndex: this.index,
						// Data
						_children: points,
						// Model
						_model: {
							// Appearance
							tension: line.custom && line.custom.tension ? line.custom.tension : helpers.getValueOrDefault(this.getDataset().lineTension, this.chart.options.elements.line.tension),
							backgroundColor: line.custom && line.custom.backgroundColor ? line.custom.backgroundColor : (this.getDataset().backgroundColor || this.chart.options.elements.line.backgroundColor),
							borderWidth: line.custom && line.custom.borderWidth ? line.custom.borderWidth : (this.getDataset().borderWidth || this.chart.options.elements.line.borderWidth),
							borderColor: line.custom && line.custom.borderColor ? line.custom.borderColor : (this.getDataset().borderColor || this.chart.options.elements.line.borderColor),
							fill: line.custom && line.custom.fill ? line.custom.fill : (this.getDataset().fill !== undefined ? this.getDataset().fill : this.chart.options.elements.line.fill),
							borderCapStyle: line.custom && line.custom.borderCapStyle ? line.custom.borderCapStyle : (this.getDataset().borderCapStyle || this.chart.options.elements.line.borderCapStyle),
							borderDash: line.custom && line.custom.borderDash ? line.custom.borderDash : (this.getDataset().borderDash || this.chart.options.elements.line.borderDash),
							borderDashOffset: line.custom && line.custom.borderDashOffset ? line.custom.borderDashOffset : (this.getDataset().borderDashOffset || this.chart.options.elements.line.borderDashOffset),
							borderJoinStyle: line.custom && line.custom.borderJoinStyle ? line.custom.borderJoinStyle : (this.getDataset().borderJoinStyle || this.chart.options.elements.line.borderJoinStyle),

							// Scale
							scaleTop: scale.top,
							scaleBottom: scale.bottom,
							scaleZero: scaleBase
						}
					});

					meta.dataset.pivot();

					// Update Points
					helpers.each(points, function (point, index) {
						this.updateElement(point, index, reset);
					}, this);


					// Update bezier control points
					this.updateBezierControlPoints();
				},
				updateElement: function (point, index, reset) {
					var pointPosition = this.chart.scale.getPointPositionForValue(index, this.getDataset().data[index]);

					helpers.extend(point, {
						// Utility
						_datasetIndex: this.index,
						_index: index,
						_scale: this.chart.scale,

						// Desired view properties
						_model: {
							x: reset ? this.chart.scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
							y: reset ? this.chart.scale.yCenter : pointPosition.y,

							// Appearance
							tension: point.custom && point.custom.tension ? point.custom.tension : helpers.getValueOrDefault(this.getDataset().tension, this.chart.options.elements.line.tension),
							radius: point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().pointRadius, index, this.chart.options.elements.point.radius),
							backgroundColor: point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBackgroundColor, index, this.chart.options.elements.point.backgroundColor),
							borderColor: point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderColor, index, this.chart.options.elements.point.borderColor),
							borderWidth: point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderWidth, index, this.chart.options.elements.point.borderWidth),
							pointStyle: point.custom && point.custom.pointStyle ? point.custom.pointStyle : helpers.getValueAtIndexOrDefault(this.getDataset().pointStyle, index, this.chart.options.elements.point.pointStyle),

							// Tooltip
							hitRadius: point.custom && point.custom.hitRadius ? point.custom.hitRadius : helpers.getValueAtIndexOrDefault(this.getDataset().hitRadius, index, this.chart.options.elements.point.hitRadius)
						}
					});

					point._model.skip = point.custom && point.custom.skip ? point.custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
				},
				updateBezierControlPoints: function () {
					var meta = this.getMeta();
					helpers.each(meta.data, function (point, index) {
						var controlPoints = helpers.splineCurve(
							helpers.previousItem(meta.data, index, true)._model,
							point._model,
							helpers.nextItem(meta.data, index, true)._model,
							point._model.tension
						);

						// Prevent the bezier going outside of the bounds of the graph
						point._model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, this.chart.chartArea.right), this.chart.chartArea.left);
						point._model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, this.chart.chartArea.bottom), this.chart.chartArea.top);

						point._model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, this.chart.chartArea.right), this.chart.chartArea.left);
						point._model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, this.chart.chartArea.bottom), this.chart.chartArea.top);

						// Now pivot the point for animation
						point.pivot();
					}, this);
				},

				draw: function (ease) {
					var meta = this.getMeta();
					var easingDecimal = ease || 1;

					// Transition Point Locations
					helpers.each(meta.data, function (point, index) {
						point.transition(easingDecimal);
					});

					// Transition and Draw the line
					meta.dataset.transition(easingDecimal).draw();

					// Draw the points
					helpers.each(meta.data, function (point) {
						point.draw();
					});
				},

				setHoverStyle: function (point) {
					// Point
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var index = point._index;

					point._model.radius = point.custom && point.custom.hoverRadius ? point.custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
					point._model.backgroundColor = point.custom && point.custom.hoverBackgroundColor ? point.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(point._model.backgroundColor));
					point._model.borderColor = point.custom && point.custom.hoverBorderColor ? point.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(point._model.borderColor));
					point._model.borderWidth = point.custom && point.custom.hoverBorderWidth ? point.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, point._model.borderWidth);
				},

				removeHoverStyle: function (point) {
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var index = point._index;

					point._model.radius = point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().radius, index, this.chart.options.elements.point.radius);
					point._model.backgroundColor = point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBackgroundColor, index, this.chart.options.elements.point.backgroundColor);
					point._model.borderColor = point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderColor, index, this.chart.options.elements.point.borderColor);
					point._model.borderWidth = point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderWidth, index, this.chart.options.elements.point.borderWidth);
				}
			});
		};

	}, {}], 21: [function (require, module, exports) {
		/*global window: false */
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.global.animation = {
				duration: 1000,
				easing: "easeOutQuart",
				onProgress: helpers.noop,
				onComplete: helpers.noop
			};

			Chart.Animation = Chart.Element.extend({
				currentStep: null, // the current animation step
				numSteps: 60, // default number of steps
				easing: "", // the easing to use for this animation
				render: null, // render function used by the animation service

				onAnimationProgress: null, // user specified callback to fire on each step of the animation
				onAnimationComplete: null // user specified callback to fire when the animation finishes
			});

			Chart.animationService = {
				frameDuration: 17,
				animations: [],
				dropFrames: 0,
				request: null,
				addAnimation: function (chartInstance, animationObject, duration, lazy) {

					if (!lazy) {
						chartInstance.animating = true;
					}

					for (var index = 0; index < this.animations.length; ++index) {
						if (this.animations[index].chartInstance === chartInstance) {
							// replacing an in progress animation
							this.animations[index].animationObject = animationObject;
							return;
						}
					}

					this.animations.push({
						chartInstance: chartInstance,
						animationObject: animationObject
					});

					// If there are no animations queued, manually kickstart a digest, for lack of a better word
					if (this.animations.length === 1) {
						this.requestAnimationFrame();
					}
				},
				// Cancel the animation for a given chart instance
				cancelAnimation: function (chartInstance) {
					var index = helpers.findIndex(this.animations, function (animationWrapper) {
						return animationWrapper.chartInstance === chartInstance;
					});

					if (index !== -1) {
						this.animations.splice(index, 1);
						chartInstance.animating = false;
					}
				},
				requestAnimationFrame: function () {
					var me = this;
					if (me.request === null) {
						// Skip animation frame requests until the active one is executed.
						// This can happen when processing mouse events, e.g. 'mousemove'
						// and 'mouseout' events will trigger multiple renders.
						me.request = helpers.requestAnimFrame.call(window, function () {
							me.request = null;
							me.startDigest();
						});
					}
				},
				startDigest: function () {

					var startTime = Date.now();
					var framesToDrop = 0;

					if (this.dropFrames > 1) {
						framesToDrop = Math.floor(this.dropFrames);
						this.dropFrames = this.dropFrames % 1;
					}

					var i = 0;
					while (i < this.animations.length) {
						if (this.animations[i].animationObject.currentStep === null) {
							this.animations[i].animationObject.currentStep = 0;
						}

						this.animations[i].animationObject.currentStep += 1 + framesToDrop;

						if (this.animations[i].animationObject.currentStep > this.animations[i].animationObject.numSteps) {
							this.animations[i].animationObject.currentStep = this.animations[i].animationObject.numSteps;
						}

						this.animations[i].animationObject.render(this.animations[i].chartInstance, this.animations[i].animationObject);
						if (this.animations[i].animationObject.onAnimationProgress && this.animations[i].animationObject.onAnimationProgress.call) {
							this.animations[i].animationObject.onAnimationProgress.call(this.animations[i].chartInstance, this.animations[i]);
						}

						if (this.animations[i].animationObject.currentStep === this.animations[i].animationObject.numSteps) {
							if (this.animations[i].animationObject.onAnimationComplete && this.animations[i].animationObject.onAnimationComplete.call) {
								this.animations[i].animationObject.onAnimationComplete.call(this.animations[i].chartInstance, this.animations[i]);
							}

							// executed the last frame. Remove the animation.
							this.animations[i].chartInstance.animating = false;

							this.animations.splice(i, 1);
						} else {
							++i;
						}
					}

					var endTime = Date.now();
					var dropFrames = (endTime - startTime) / this.frameDuration;

					this.dropFrames += dropFrames;

					// Do we have more stuff to animate?
					if (this.animations.length > 0) {
						this.requestAnimationFrame();
					}
				}
			};
		};
	}, {}], 22: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;
			//Create a dictionary of chart types, to allow for extension of existing types
			Chart.types = {};

			//Store a reference to each instance - allowing us to globally resize chart instances on window resize.
			//Destroy method on the chart will remove the instance of the chart from this reference.
			Chart.instances = {};

			// Controllers available for dataset visualization eg. bar, line, slice, etc.
			Chart.controllers = {};

			// The main controller of a chart
			Chart.Controller = function (instance) {

				this.chart = instance;
				this.config = instance.config;
				this.options = this.config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[this.config.type], this.config.options || {});
				this.id = helpers.uid();

				Object.defineProperty(this, 'data', {
					get: function () {
						return this.config.data;
					}
				});

				//Add the chart instance to the global namespace
				Chart.instances[this.id] = this;

				if (this.options.responsive) {
					// Silent resize before chart draws
					this.resize(true);
				}

				this.initialize();

				return this;
			};

			helpers.extend(Chart.Controller.prototype, {

				initialize: function initialize() {
					// Before init plugin notification
					Chart.pluginService.notifyPlugins('beforeInit', [this]);

					this.bindEvents();

					// Make sure controllers are built first so that each dataset is bound to an axis before the scales
					// are built
					this.ensureScalesHaveIDs();
					this.buildOrUpdateControllers();
					this.buildScales();
					this.buildSurroundingItems();
					this.updateLayout();
					this.resetElements();
					this.initToolTip();
					this.update();

					// After init plugin notification
					Chart.pluginService.notifyPlugins('afterInit', [this]);

					return this;
				},

				clear: function clear() {
					helpers.clear(this.chart);
					return this;
				},

				stop: function stop() {
					// Stops any current animation loop occuring
					Chart.animationService.cancelAnimation(this);
					return this;
				},

				resize: function resize(silent) {
					var canvas = this.chart.canvas;
					var newWidth = helpers.getMaximumWidth(this.chart.canvas);
					var newHeight = (this.options.maintainAspectRatio && isNaN(this.chart.aspectRatio) === false && isFinite(this.chart.aspectRatio) && this.chart.aspectRatio !== 0) ? newWidth / this.chart.aspectRatio : helpers.getMaximumHeight(this.chart.canvas);

					var sizeChanged = this.chart.width !== newWidth || this.chart.height !== newHeight;

					if (!sizeChanged)
						return this;

					canvas.width = this.chart.width = newWidth;
					canvas.height = this.chart.height = newHeight;

					helpers.retinaScale(this.chart);

					if (!silent) {
						this.stop();
						this.update(this.options.responsiveAnimationDuration);
					}

					return this;
				},
				ensureScalesHaveIDs: function ensureScalesHaveIDs() {
					var defaultXAxisID = 'x-axis-';
					var defaultYAxisID = 'y-axis-';

					if (this.options.scales) {
						if (this.options.scales.xAxes && this.options.scales.xAxes.length) {
							helpers.each(this.options.scales.xAxes, function (xAxisOptions, index) {
								xAxisOptions.id = xAxisOptions.id || (defaultXAxisID + index);
							});
						}

						if (this.options.scales.yAxes && this.options.scales.yAxes.length) {
							// Build the y axes
							helpers.each(this.options.scales.yAxes, function (yAxisOptions, index) {
								yAxisOptions.id = yAxisOptions.id || (defaultYAxisID + index);
							});
						}
					}
				},
				buildScales: function buildScales() {
					// Map of scale ID to scale object so we can lookup later
					this.scales = {};

					// Build the x axes
					if (this.options.scales) {
						if (this.options.scales.xAxes && this.options.scales.xAxes.length) {
							helpers.each(this.options.scales.xAxes, function (xAxisOptions, index) {
								var xType = helpers.getValueOrDefault(xAxisOptions.type, 'category');
								var ScaleClass = Chart.scaleService.getScaleConstructor(xType);
								if (ScaleClass) {
									var scale = new ScaleClass({
										ctx: this.chart.ctx,
										options: xAxisOptions,
										chart: this,
										id: xAxisOptions.id
									});

									this.scales[scale.id] = scale;
								}
							}, this);
						}

						if (this.options.scales.yAxes && this.options.scales.yAxes.length) {
							// Build the y axes
							helpers.each(this.options.scales.yAxes, function (yAxisOptions, index) {
								var yType = helpers.getValueOrDefault(yAxisOptions.type, 'linear');
								var ScaleClass = Chart.scaleService.getScaleConstructor(yType);
								if (ScaleClass) {
									var scale = new ScaleClass({
										ctx: this.chart.ctx,
										options: yAxisOptions,
										chart: this,
										id: yAxisOptions.id
									});

									this.scales[scale.id] = scale;
								}
							}, this);
						}
					}
					if (this.options.scale) {
						// Build radial axes
						var ScaleClass = Chart.scaleService.getScaleConstructor(this.options.scale.type);
						if (ScaleClass) {
							var scale = new ScaleClass({
								ctx: this.chart.ctx,
								options: this.options.scale,
								chart: this
							});

							this.scale = scale;

							this.scales.radialScale = scale;
						}
					}

					Chart.scaleService.addScalesToLayout(this);
				},

				buildSurroundingItems: function () {
					if (this.options.title) {
						this.titleBlock = new Chart.Title({
							ctx: this.chart.ctx,
							options: this.options.title,
							chart: this
						});

						Chart.layoutService.addBox(this, this.titleBlock);
					}

					if (this.options.legend) {
						this.legend = new Chart.Legend({
							ctx: this.chart.ctx,
							options: this.options.legend,
							chart: this
						});

						Chart.layoutService.addBox(this, this.legend);
					}
				},

				updateLayout: function () {
					Chart.layoutService.update(this, this.chart.width, this.chart.height);
				},

				buildOrUpdateControllers: function buildOrUpdateControllers() {
					var types = [];
					var newControllers = [];

					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						var meta = this.getDatasetMeta(datasetIndex);
						if (!meta.type) {
							meta.type = dataset.type || this.config.type;
						}

						types.push(meta.type);

						if (meta.controller) {
							meta.controller.updateIndex(datasetIndex);
						} else {
							meta.controller = new Chart.controllers[meta.type](this, datasetIndex);
							newControllers.push(meta.controller);
						}
					}, this);

					if (types.length > 1) {
						for (var i = 1; i < types.length; i++) {
							if (types[i] !== types[i - 1]) {
								this.isCombo = true;
								break;
							}
						}
					}

					return newControllers;
				},

				resetElements: function resetElements() {
					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						this.getDatasetMeta(datasetIndex).controller.reset();
					}, this);
				},

				update: function update(animationDuration, lazy) {
					Chart.pluginService.notifyPlugins('beforeUpdate', [this]);

					// In case the entire data object changed
					this.tooltip._data = this.data;

					// Make sure dataset controllers are updated and new controllers are reset
					var newControllers = this.buildOrUpdateControllers();

					// Make sure all dataset controllers have correct meta data counts
					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						this.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
					}, this);

					Chart.layoutService.update(this, this.chart.width, this.chart.height);

					// Apply changes to the dataets that require the scales to have been calculated i.e BorderColor chages
					Chart.pluginService.notifyPlugins('afterScaleUpdate', [this]);

					// Can only reset the new controllers after the scales have been updated
					helpers.each(newControllers, function (controller) {
						controller.reset();
					});

					// This will loop through any data and do the appropriate element update for the type
					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						this.getDatasetMeta(datasetIndex).controller.update();
					}, this);

					// Do this before render so that any plugins that need final scale updates can use it
					Chart.pluginService.notifyPlugins('afterUpdate', [this]);

					this.render(animationDuration, lazy);
				},

				render: function render(duration, lazy) {
					Chart.pluginService.notifyPlugins('beforeRender', [this]);

					if (this.options.animation && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && this.options.animation.duration !== 0))) {
						var animation = new Chart.Animation();
						animation.numSteps = (duration || this.options.animation.duration) / 16.66; //60 fps
						animation.easing = this.options.animation.easing;

						// render function
						animation.render = function (chartInstance, animationObject) {
							var easingFunction = helpers.easingEffects[animationObject.easing];
							var stepDecimal = animationObject.currentStep / animationObject.numSteps;
							var easeDecimal = easingFunction(stepDecimal);

							chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);
						};

						// user events
						animation.onAnimationProgress = this.options.animation.onProgress;
						animation.onAnimationComplete = this.options.animation.onComplete;

						Chart.animationService.addAnimation(this, animation, duration, lazy);
					} else {
						this.draw();
						if (this.options.animation && this.options.animation.onComplete && this.options.animation.onComplete.call) {
							this.options.animation.onComplete.call(this);
						}
					}
					return this;
				},

				draw: function (ease) {
					var easingDecimal = ease || 1;
					this.clear();

					Chart.pluginService.notifyPlugins('beforeDraw', [this, easingDecimal]);

					// Draw all the scales
					helpers.each(this.boxes, function (box) {
						box.draw(this.chartArea);
					}, this);
					if (this.scale) {
						this.scale.draw();
					}

					// Clip out the chart area so that anything outside does not draw. This is necessary for zoom and pan to function
					this.chart.ctx.save();
					this.chart.ctx.beginPath();
					this.chart.ctx.rect(this.chartArea.left, this.chartArea.top, this.chartArea.right - this.chartArea.left, this.chartArea.bottom - this.chartArea.top);
					this.chart.ctx.clip();

					// Draw each dataset via its respective controller (reversed to support proper line stacking)
					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						if (this.isDatasetVisible(datasetIndex)) {
							this.getDatasetMeta(datasetIndex).controller.draw(ease);
						}
					}, this, true);

					// Restore from the clipping operation
					this.chart.ctx.restore();

					// Finally draw the tooltip
					this.tooltip.transition(easingDecimal).draw();

					Chart.pluginService.notifyPlugins('afterDraw', [this, easingDecimal]);
				},

				// Get the single element that was clicked on
				// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
				getElementAtEvent: function (e) {
					var eventPosition = helpers.getRelativePosition(e, this.chart);
					var elementsArray = [];

					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						if (this.isDatasetVisible(datasetIndex)) {
							var meta = this.getDatasetMeta(datasetIndex);
							helpers.each(meta.data, function (element, index) {
								if (element.inRange(eventPosition.x, eventPosition.y)) {
									elementsArray.push(element);
									return elementsArray;
								}
							});
						}
					}, this);

					return elementsArray;
				},

				getElementsAtEvent: function (e) {
					var eventPosition = helpers.getRelativePosition(e, this.chart);
					var elementsArray = [];

					var found = (function () {
						if (this.data.datasets) {
							for (var i = 0; i < this.data.datasets.length; i++) {
								var meta = this.getDatasetMeta(i);
								if (this.isDatasetVisible(i)) {
									for (var j = 0; j < meta.data.length; j++) {
										if (meta.data[j].inRange(eventPosition.x, eventPosition.y)) {
											return meta.data[j];
										}
									}
								}
							}
						}
					}).call(this);

					if (!found) {
						return elementsArray;
					}

					helpers.each(this.data.datasets, function (dataset, datasetIndex) {
						if (this.isDatasetVisible(datasetIndex)) {
							var meta = this.getDatasetMeta(datasetIndex);
							elementsArray.push(meta.data[found._index]);
						}
					}, this);

					return elementsArray;
				},

				getDatasetAtEvent: function (e) {
					var elementsArray = this.getElementAtEvent(e);

					if (elementsArray.length > 0) {
						elementsArray = this.getDatasetMeta(elementsArray[0]._datasetIndex).data;
					}

					return elementsArray;
				},

				getDatasetMeta: function (datasetIndex) {
					var dataset = this.data.datasets[datasetIndex];
					if (!dataset._meta) {
						dataset._meta = {};
					}

					var meta = dataset._meta[this.id];
					if (!meta) {
						meta = dataset._meta[this.id] = {
							type: null,
							data: [],
							dataset: null,
							controller: null,
							hidden: null,			// See isDatasetVisible() comment
							xAxisID: null,
							yAxisID: null
						};
					}

					return meta;
				},

				getVisibleDatasetCount: function () {
					var count = 0;
					for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
						if (this.isDatasetVisible(i)) {
							count++;
						}
					}
					return count;
				},

				isDatasetVisible: function (datasetIndex) {
					var meta = this.getDatasetMeta(datasetIndex);

					// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
					// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
					return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
				},

				generateLegend: function generateLegend() {
					return this.options.legendCallback(this);
				},

				destroy: function destroy() {
					this.clear();
					helpers.unbindEvents(this, this.events);
					helpers.removeResizeListener(this.chart.canvas.parentNode);

					// Reset canvas height/width attributes
					var canvas = this.chart.canvas;
					canvas.width = this.chart.width;
					canvas.height = this.chart.height;

					// if we scaled the canvas in response to a devicePixelRatio !== 1, we need to undo that transform here
					if (this.chart.originalDevicePixelRatio !== undefined) {
						this.chart.ctx.scale(1 / this.chart.originalDevicePixelRatio, 1 / this.chart.originalDevicePixelRatio);
					}

					// Reset to the old style since it may have been changed by the device pixel ratio changes
					canvas.style.width = this.chart.originalCanvasStyleWidth;
					canvas.style.height = this.chart.originalCanvasStyleHeight;

					Chart.pluginService.notifyPlugins('destroy', [this]);

					delete Chart.instances[this.id];
				},

				toBase64Image: function toBase64Image() {
					return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
				},

				initToolTip: function initToolTip() {
					this.tooltip = new Chart.Tooltip({
						_chart: this.chart,
						_chartInstance: this,
						_data: this.data,
						_options: this.options
					}, this);
				},

				bindEvents: function bindEvents() {
					helpers.bindEvents(this, this.options.events, function (evt) {
						this.eventHandler(evt);
					});
				},
				eventHandler: function eventHandler(e) {
					this.lastActive = this.lastActive || [];
					this.lastTooltipActive = this.lastTooltipActive || [];

					// Find Active Elements for hover and tooltips
					if (e.type === 'mouseout') {
						this.active = [];
						this.tooltipActive = [];
					} else {

						var _this = this;
						var getItemsForMode = function (mode) {
							switch (mode) {
								case 'single':
									return _this.getElementAtEvent(e);
								case 'label':
									return _this.getElementsAtEvent(e);
								case 'dataset':
									return _this.getDatasetAtEvent(e);
								default:
									return e;
							}
						};

						this.active = getItemsForMode(this.options.hover.mode);
						this.tooltipActive = getItemsForMode(this.options.tooltips.mode);
					}

					// On Hover hook
					if (this.options.hover.onHover) {
						this.options.hover.onHover.call(this, this.active);
					}

					if (e.type === 'mouseup' || e.type === 'click') {
						if (this.options.onClick) {
							this.options.onClick.call(this, e, this.active);
						}

						if (this.legend && this.legend.handleEvent) {
							this.legend.handleEvent(e);
						}
					}

					// Remove styling for last active (even if it may still be active)
					if (this.lastActive.length) {
						switch (this.options.hover.mode) {
							case 'single':
								this.getDatasetMeta(this.lastActive[0]._datasetIndex).controller.removeHoverStyle(this.lastActive[0], this.lastActive[0]._datasetIndex, this.lastActive[0]._index);
								break;
							case 'label':
							case 'dataset':
								for (var i = 0; i < this.lastActive.length; i++) {
									if (this.lastActive[i])
										this.getDatasetMeta(this.lastActive[i]._datasetIndex).controller.removeHoverStyle(this.lastActive[i], this.lastActive[i]._datasetIndex, this.lastActive[i]._index);
								}
								break;
							default:
							// Don't change anything
						}
					}

					// Built in hover styling
					if (this.active.length && this.options.hover.mode) {
						switch (this.options.hover.mode) {
							case 'single':
								this.getDatasetMeta(this.active[0]._datasetIndex).controller.setHoverStyle(this.active[0]);
								break;
							case 'label':
							case 'dataset':
								for (var j = 0; j < this.active.length; j++) {
									if (this.active[j])
										this.getDatasetMeta(this.active[j]._datasetIndex).controller.setHoverStyle(this.active[j]);
								}
								break;
							default:
							// Don't change anything
						}
					}


					// Built in Tooltips
					if (this.options.tooltips.enabled || this.options.tooltips.custom) {

						// The usual updates
						this.tooltip.initialize();
						this.tooltip._active = this.tooltipActive;
						this.tooltip.update(true);
					}

					// Hover animations
					this.tooltip.pivot();

					if (!this.animating) {
						var changed;

						helpers.each(this.active, function (element, index) {
							if (element !== this.lastActive[index]) {
								changed = true;
							}
						}, this);

						helpers.each(this.tooltipActive, function (element, index) {
							if (element !== this.lastTooltipActive[index]) {
								changed = true;
							}
						}, this);

						// If entering, leaving, or changing elements, animate the change via pivot
						if ((this.lastActive.length !== this.active.length) ||
							(this.lastTooltipActive.length !== this.tooltipActive.length) ||
							changed) {

							this.stop();

							if (this.options.tooltips.enabled || this.options.tooltips.custom) {
								this.tooltip.update(true);
							}

							// We only need to render at this point. Updating will cause scales to be recomputed generating flicker & using more
							// memory than necessary.
							this.render(this.options.hover.animationDuration, true);
						}
					}

					// Remember Last Actives
					this.lastActive = this.active;
					this.lastTooltipActive = this.tooltipActive;
					return this;
				}
			});
		};

	}, {}], 23: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;
			var noop = helpers.noop;

			// Base class for all dataset controllers (line, bar, etc)
			Chart.DatasetController = function (chart, datasetIndex) {
				this.initialize.call(this, chart, datasetIndex);
			};

			helpers.extend(Chart.DatasetController.prototype, {
				initialize: function (chart, datasetIndex) {
					this.chart = chart;
					this.index = datasetIndex;
					this.linkScales();
					this.addElements();
				},
				updateIndex: function (datasetIndex) {
					this.index = datasetIndex;
				},

				linkScales: function () {
					var meta = this.getMeta();
					var dataset = this.getDataset();

					if (meta.xAxisID === null) {
						meta.xAxisID = dataset.xAxisID || this.chart.options.scales.xAxes[0].id;
					}
					if (meta.yAxisID === null) {
						meta.yAxisID = dataset.yAxisID || this.chart.options.scales.yAxes[0].id;
					}
				},

				getDataset: function () {
					return this.chart.data.datasets[this.index];
				},

				getMeta: function () {
					return this.chart.getDatasetMeta(this.index);
				},

				getScaleForId: function (scaleID) {
					return this.chart.scales[scaleID];
				},

				reset: function () {
					this.update(true);
				},

				buildOrUpdateElements: function buildOrUpdateElements() {
					// Handle the number of data points changing
					var meta = this.getMeta(),
						md = meta.data,
						numData = this.getDataset().data.length,
						numMetaData = md.length;

					// Make sure that we handle number of datapoints changing
					if (numData < numMetaData) {
						// Remove excess bars for data points that have been removed
						md.splice(numData, numMetaData - numData);
					} else if (numData > numMetaData) {
						// Add new elements
						for (var index = numMetaData; index < numData; ++index) {
							this.addElementAndReset(index);
						}
					}
				},

				// Controllers should implement the following
				addElements: noop,
				addElementAndReset: noop,
				draw: noop,
				removeHoverStyle: noop,
				setHoverStyle: noop,
				update: noop
			});

			Chart.DatasetController.extend = helpers.inherits;
		};
	}, {}], 24: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.elements = {};

			Chart.Element = function (configuration) {
				helpers.extend(this, configuration);
				this.initialize.apply(this, arguments);
			};
			helpers.extend(Chart.Element.prototype, {
				initialize: function () {
					this.hidden = false;
				},
				pivot: function () {
					if (!this._view) {
						this._view = helpers.clone(this._model);
					}
					this._start = helpers.clone(this._view);
					return this;
				},
				transition: function (ease) {
					if (!this._view) {
						this._view = helpers.clone(this._model);
					}

					// No animation -> No Transition
					if (ease === 1) {
						this._view = this._model;
						this._start = null;
						return this;
					}

					if (!this._start) {
						this.pivot();
					}

					helpers.each(this._model, function (value, key) {

						if (key[0] === '_' || !this._model.hasOwnProperty(key)) {
							// Only non-underscored properties
						}

						// Init if doesn't exist
						else if (!this._view.hasOwnProperty(key)) {
							if (typeof value === 'number' && !isNaN(this._view[key])) {
								this._view[key] = value * ease;
							} else {
								this._view[key] = value;
							}
						}

						// No unnecessary computations
						else if (value === this._view[key]) {
							// It's the same! Woohoo!
						}

						// Color transitions if possible
						else if (typeof value === 'string') {
							try {
								var color = helpers.color(this._start[key]).mix(helpers.color(this._model[key]), ease);
								this._view[key] = color.rgbString();
							} catch (err) {
								this._view[key] = value;
							}
						}
						// Number transitions
						else if (typeof value === 'number') {
							var startVal = this._start[key] !== undefined && isNaN(this._start[key]) === false ? this._start[key] : 0;
							this._view[key] = ((this._model[key] - startVal) * ease) + startVal;
						}
						// Everything else
						else {
							this._view[key] = value;
						}
					}, this);

					return this;
				},
				tooltipPosition: function () {
					return {
						x: this._model.x,
						y: this._model.y
					};
				},
				hasValue: function () {
					return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
				}
			});

			Chart.Element.extend = helpers.inherits;

		};

	}, {}], 25: [function (require, module, exports) {
		/*global window: false */
		/*global document: false */
		"use strict";

		var color = require('chartjs-color');

		module.exports = function (Chart) {

			//Global Chart helpers object for utility methods and classes
			var helpers = Chart.helpers = {};

			//-- Basic js utility methods
			helpers.each = function (loopable, callback, self, reverse) {
				// Check to see if null or undefined firstly.
				var i, len;
				if (helpers.isArray(loopable)) {
					len = loopable.length;
					if (reverse) {
						for (i = len - 1; i >= 0; i--) {
							callback.call(self, loopable[i], i);
						}
					} else {
						for (i = 0; i < len; i++) {
							callback.call(self, loopable[i], i);
						}
					}
				} else if (typeof loopable === 'object') {
					var keys = Object.keys(loopable);
					len = keys.length;
					for (i = 0; i < len; i++) {
						callback.call(self, loopable[keys[i]], keys[i]);
					}
				}
			};
			helpers.clone = function (obj) {
				var objClone = {};
				helpers.each(obj, function (value, key) {
					if (obj.hasOwnProperty(key)) {
						if (helpers.isArray(value)) {
							objClone[key] = value.slice(0);
						} else if (typeof value === 'object' && value !== null) {
							objClone[key] = helpers.clone(value);
						} else {
							objClone[key] = value;
						}
					}
				});
				return objClone;
			};
			helpers.extend = function (base) {
				var len = arguments.length;
				var additionalArgs = [];
				for (var i = 1; i < len; i++) {
					additionalArgs.push(arguments[i]);
				}
				helpers.each(additionalArgs, function (extensionObject) {
					helpers.each(extensionObject, function (value, key) {
						if (extensionObject.hasOwnProperty(key)) {
							base[key] = value;
						}
					});
				});
				return base;
			};
			// Need a special merge function to chart configs since they are now grouped
			helpers.configMerge = function (_base) {
				var base = helpers.clone(_base);
				helpers.each(Array.prototype.slice.call(arguments, 1), function (extension) {
					helpers.each(extension, function (value, key) {
						if (extension.hasOwnProperty(key)) {
							if (key === 'scales') {
								// Scale config merging is complex. Add out own function here for that
								base[key] = helpers.scaleMerge(base.hasOwnProperty(key) ? base[key] : {}, value);

							} else if (key === 'scale') {
								// Used in polar area & radar charts since there is only one scale
								base[key] = helpers.configMerge(base.hasOwnProperty(key) ? base[key] : {}, Chart.scaleService.getScaleDefaults(value.type), value);
							} else if (base.hasOwnProperty(key) && helpers.isArray(base[key]) && helpers.isArray(value)) {
								// In this case we have an array of objects replacing another array. Rather than doing a strict replace,
								// merge. This allows easy scale option merging
								var baseArray = base[key];

								helpers.each(value, function (valueObj, index) {

									if (index < baseArray.length) {
										if (typeof baseArray[index] === 'object' && baseArray[index] !== null && typeof valueObj === 'object' && valueObj !== null) {
											// Two objects are coming together. Do a merge of them.
											baseArray[index] = helpers.configMerge(baseArray[index], valueObj);
										} else {
											// Just overwrite in this case since there is nothing to merge
											baseArray[index] = valueObj;
										}
									} else {
										baseArray.push(valueObj); // nothing to merge
									}
								});

							} else if (base.hasOwnProperty(key) && typeof base[key] === "object" && base[key] !== null && typeof value === "object") {
								// If we are overwriting an object with an object, do a merge of the properties.
								base[key] = helpers.configMerge(base[key], value);

							} else {
								// can just overwrite the value in this case
								base[key] = value;
							}
						}
					});
				});

				return base;
			};
			helpers.extendDeep = function (_base) {
				return _extendDeep.apply(this, arguments);

				function _extendDeep(dst) {
					helpers.each(arguments, function (obj) {
						if (obj !== dst) {
							helpers.each(obj, function (value, key) {
								if (dst[key] && dst[key].constructor && dst[key].constructor === Object) {
									_extendDeep(dst[key], value);
								} else {
									dst[key] = value;
								}
							});
						}
					});
					return dst;
				}
			};
			helpers.scaleMerge = function (_base, extension) {
				var base = helpers.clone(_base);

				helpers.each(extension, function (value, key) {
					if (extension.hasOwnProperty(key)) {
						if (key === 'xAxes' || key === 'yAxes') {
							// These properties are arrays of items
							if (base.hasOwnProperty(key)) {
								helpers.each(value, function (valueObj, index) {
									var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
									var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);
									if (index >= base[key].length || !base[key][index].type) {
										base[key].push(helpers.configMerge(axisDefaults, valueObj));
									} else if (valueObj.type && valueObj.type !== base[key][index].type) {
										// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults
										base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);
									} else {
										// Type is the same
										base[key][index] = helpers.configMerge(base[key][index], valueObj);
									}
								});
							} else {
								base[key] = [];
								helpers.each(value, function (valueObj) {
									var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
									base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));
								});
							}
						} else if (base.hasOwnProperty(key) && typeof base[key] === "object" && base[key] !== null && typeof value === "object") {
							// If we are overwriting an object with an object, do a merge of the properties.
							base[key] = helpers.configMerge(base[key], value);

						} else {
							// can just overwrite the value in this case
							base[key] = value;
						}
					}
				});

				return base;
			};
			helpers.getValueAtIndexOrDefault = function (value, index, defaultValue) {
				if (value === undefined || value === null) {
					return defaultValue;
				}

				if (helpers.isArray(value)) {
					return index < value.length ? value[index] : defaultValue;
				}

				return value;
			};
			helpers.getValueOrDefault = function (value, defaultValue) {
				return value === undefined ? defaultValue : value;
			};
			helpers.indexOf = function (arrayToSearch, item) {
				if (Array.prototype.indexOf) {
					return arrayToSearch.indexOf(item);
				} else {
					for (var i = 0; i < arrayToSearch.length; i++) {
						if (arrayToSearch[i] === item)
							return i;
					}
					return -1;
				}
			};
			helpers.where = function (collection, filterCallback) {
				var filtered = [];

				helpers.each(collection, function (item) {
					if (filterCallback(item)) {
						filtered.push(item);
					}
				});

				return filtered;
			};
			helpers.findIndex = function (arrayToSearch, callback, thisArg) {
				var index = -1;
				if (Array.prototype.findIndex) {
					index = arrayToSearch.findIndex(callback, thisArg);
				} else {
					for (var i = 0; i < arrayToSearch.length; ++i) {
						thisArg = thisArg !== undefined ? thisArg : arrayToSearch;

						if (callback.call(thisArg, arrayToSearch[i], i, arrayToSearch)) {
							index = i;
							break;
						}
					}
				}

				return index;
			};
			helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
				// Default to start of the array
				if (startIndex === undefined || startIndex === null) {
					startIndex = -1;
				}
				for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
					var currentItem = arrayToSearch[i];
					if (filterCallback(currentItem)) {
						return currentItem;
					}
				}
			};
			helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
				// Default to end of the array
				if (startIndex === undefined || startIndex === null) {
					startIndex = arrayToSearch.length;
				}
				for (var i = startIndex - 1; i >= 0; i--) {
					var currentItem = arrayToSearch[i];
					if (filterCallback(currentItem)) {
						return currentItem;
					}
				}
			};
			helpers.inherits = function (extensions) {
				//Basic javascript inheritance based on the model created in Backbone.js
				var parent = this;
				var ChartElement = (extensions && extensions.hasOwnProperty("constructor")) ? extensions.constructor : function () {
					return parent.apply(this, arguments);
				};

				var Surrogate = function () {
					this.constructor = ChartElement;
				};
				Surrogate.prototype = parent.prototype;
				ChartElement.prototype = new Surrogate();

				ChartElement.extend = helpers.inherits;

				if (extensions) {
					helpers.extend(ChartElement.prototype, extensions);
				}

				ChartElement.__super__ = parent.prototype;

				return ChartElement;
			};
			helpers.noop = function () { };
			helpers.uid = (function () {
				var id = 0;
				return function () {
					return id++;
				};
			})();
			helpers.warn = function (str) {
				//Method for warning of errors
				if (console && typeof console.warn === "function") {
					console.warn(str);
				}
			};
			//-- Math methods
			helpers.isNumber = function (n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			};
			helpers.almostEquals = function (x, y, epsilon) {
				return Math.abs(x - y) < epsilon;
			};
			helpers.max = function (array) {
				return array.reduce(function (max, value) {
					if (!isNaN(value)) {
						return Math.max(max, value);
					} else {
						return max;
					}
				}, Number.NEGATIVE_INFINITY);
			};
			helpers.min = function (array) {
				return array.reduce(function (min, value) {
					if (!isNaN(value)) {
						return Math.min(min, value);
					} else {
						return min;
					}
				}, Number.POSITIVE_INFINITY);
			};
			helpers.sign = function (x) {
				if (Math.sign) {
					return Math.sign(x);
				} else {
					x = +x; // convert to a number
					if (x === 0 || isNaN(x)) {
						return x;
					}
					return x > 0 ? 1 : -1;
				}
			};
			helpers.log10 = function (x) {
				if (Math.log10) {
					return Math.log10(x);
				} else {
					return Math.log(x) / Math.LN10;
				}
			};
			helpers.toRadians = function (degrees) {
				return degrees * (Math.PI / 180);
			};
			helpers.toDegrees = function (radians) {
				return radians * (180 / Math.PI);
			};
			// Gets the angle from vertical upright to the point about a centre.
			helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
				var distanceFromXCenter = anglePoint.x - centrePoint.x,
					distanceFromYCenter = anglePoint.y - centrePoint.y,
					radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

				var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

				if (angle < (-0.5 * Math.PI)) {
					angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
				}

				return {
					angle: angle,
					distance: radialDistanceFromCenter
				};
			};
			helpers.aliasPixel = function (pixelWidth) {
				return (pixelWidth % 2 === 0) ? 0 : 0.5;
			};
			helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
				//Props to Rob Spencer at scaled innovation for his post on splining between points
				//http://scaledinnovation.com/analytics/splines/aboutSplines.html

				// This function must also respect "skipped" points

				var previous = firstPoint.skip ? middlePoint : firstPoint,
					current = middlePoint,
					next = afterPoint.skip ? middlePoint : afterPoint;

				var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
				var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

				var s01 = d01 / (d01 + d12);
				var s12 = d12 / (d01 + d12);

				// If all points are the same, s01 & s02 will be inf
				s01 = isNaN(s01) ? 0 : s01;
				s12 = isNaN(s12) ? 0 : s12;

				var fa = t * s01; // scaling factor for triangle Ta
				var fb = t * s12;

				return {
					previous: {
						x: current.x - fa * (next.x - previous.x),
						y: current.y - fa * (next.y - previous.y)
					},
					next: {
						x: current.x + fb * (next.x - previous.x),
						y: current.y + fb * (next.y - previous.y)
					}
				};
			};
			helpers.nextItem = function (collection, index, loop) {
				if (loop) {
					return index >= collection.length - 1 ? collection[0] : collection[index + 1];
				}

				return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
			};
			helpers.previousItem = function (collection, index, loop) {
				if (loop) {
					return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
				}
				return index <= 0 ? collection[0] : collection[index - 1];
			};
			// Implementation of the nice number algorithm used in determining where axis labels will go
			helpers.niceNum = function (range, round) {
				var exponent = Math.floor(helpers.log10(range));
				var fraction = range / Math.pow(10, exponent);
				var niceFraction;

				if (round) {
					if (fraction < 1.5) {
						niceFraction = 1;
					} else if (fraction < 3) {
						niceFraction = 2;
					} else if (fraction < 7) {
						niceFraction = 5;
					} else {
						niceFraction = 10;
					}
				} else {
					if (fraction <= 1.0) {
						niceFraction = 1;
					} else if (fraction <= 2) {
						niceFraction = 2;
					} else if (fraction <= 5) {
						niceFraction = 5;
					} else {
						niceFraction = 10;
					}
				}

				return niceFraction * Math.pow(10, exponent);
			};
			//Easing functions adapted from Robert Penner's easing equations
			//http://www.robertpenner.com/easing/
			var easingEffects = helpers.easingEffects = {
				linear: function (t) {
					return t;
				},
				easeInQuad: function (t) {
					return t * t;
				},
				easeOutQuad: function (t) {
					return -1 * t * (t - 2);
				},
				easeInOutQuad: function (t) {
					if ((t /= 1 / 2) < 1) {
						return 1 / 2 * t * t;
					}
					return -1 / 2 * ((--t) * (t - 2) - 1);
				},
				easeInCubic: function (t) {
					return t * t * t;
				},
				easeOutCubic: function (t) {
					return 1 * ((t = t / 1 - 1) * t * t + 1);
				},
				easeInOutCubic: function (t) {
					if ((t /= 1 / 2) < 1) {
						return 1 / 2 * t * t * t;
					}
					return 1 / 2 * ((t -= 2) * t * t + 2);
				},
				easeInQuart: function (t) {
					return t * t * t * t;
				},
				easeOutQuart: function (t) {
					return -1 * ((t = t / 1 - 1) * t * t * t - 1);
				},
				easeInOutQuart: function (t) {
					if ((t /= 1 / 2) < 1) {
						return 1 / 2 * t * t * t * t;
					}
					return -1 / 2 * ((t -= 2) * t * t * t - 2);
				},
				easeInQuint: function (t) {
					return 1 * (t /= 1) * t * t * t * t;
				},
				easeOutQuint: function (t) {
					return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
				},
				easeInOutQuint: function (t) {
					if ((t /= 1 / 2) < 1) {
						return 1 / 2 * t * t * t * t * t;
					}
					return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
				},
				easeInSine: function (t) {
					return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
				},
				easeOutSine: function (t) {
					return 1 * Math.sin(t / 1 * (Math.PI / 2));
				},
				easeInOutSine: function (t) {
					return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
				},
				easeInExpo: function (t) {
					return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
				},
				easeOutExpo: function (t) {
					return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
				},
				easeInOutExpo: function (t) {
					if (t === 0) {
						return 0;
					}
					if (t === 1) {
						return 1;
					}
					if ((t /= 1 / 2) < 1) {
						return 1 / 2 * Math.pow(2, 10 * (t - 1));
					}
					return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
				},
				easeInCirc: function (t) {
					if (t >= 1) {
						return t;
					}
					return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
				},
				easeOutCirc: function (t) {
					return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
				},
				easeInOutCirc: function (t) {
					if ((t /= 1 / 2) < 1) {
						return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
					}
					return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
				},
				easeInElastic: function (t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if ((t /= 1) === 1) {
						return 1;
					}
					if (!p) {
						p = 1 * 0.3;
					}
					if (a < Math.abs(1)) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
				},
				easeOutElastic: function (t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if ((t /= 1) === 1) {
						return 1;
					}
					if (!p) {
						p = 1 * 0.3;
					}
					if (a < Math.abs(1)) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
				},
				easeInOutElastic: function (t) {
					var s = 1.70158;
					var p = 0;
					var a = 1;
					if (t === 0) {
						return 0;
					}
					if ((t /= 1 / 2) === 2) {
						return 1;
					}
					if (!p) {
						p = 1 * (0.3 * 1.5);
					}
					if (a < Math.abs(1)) {
						a = 1;
						s = p / 4;
					} else {
						s = p / (2 * Math.PI) * Math.asin(1 / a);
					}
					if (t < 1) {
						return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
					}
					return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
				},
				easeInBack: function (t) {
					var s = 1.70158;
					return 1 * (t /= 1) * t * ((s + 1) * t - s);
				},
				easeOutBack: function (t) {
					var s = 1.70158;
					return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
				},
				easeInOutBack: function (t) {
					var s = 1.70158;
					if ((t /= 1 / 2) < 1) {
						return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
					}
					return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
				},
				easeInBounce: function (t) {
					return 1 - easingEffects.easeOutBounce(1 - t);
				},
				easeOutBounce: function (t) {
					if ((t /= 1) < (1 / 2.75)) {
						return 1 * (7.5625 * t * t);
					} else if (t < (2 / 2.75)) {
						return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);
					} else if (t < (2.5 / 2.75)) {
						return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);
					} else {
						return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);
					}
				},
				easeInOutBounce: function (t) {
					if (t < 1 / 2) {
						return easingEffects.easeInBounce(t * 2) * 0.5;
					}
					return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;
				}
			};
			//Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
			helpers.requestAnimFrame = (function () {
				return window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame ||
					function (callback) {
						return window.setTimeout(callback, 1000 / 60);
					};
			})();
			helpers.cancelAnimFrame = (function () {
				return window.cancelAnimationFrame ||
					window.webkitCancelAnimationFrame ||
					window.mozCancelAnimationFrame ||
					window.oCancelAnimationFrame ||
					window.msCancelAnimationFrame ||
					function (callback) {
						return window.clearTimeout(callback, 1000 / 60);
					};
			})();
			//-- DOM methods
			helpers.getRelativePosition = function (evt, chart) {
				var mouseX, mouseY;
				var e = evt.originalEvent || evt,
					canvas = evt.currentTarget || evt.srcElement,
					boundingRect = canvas.getBoundingClientRect();

				if (e.touches && e.touches.length > 0) {
					mouseX = e.touches[0].clientX;
					mouseY = e.touches[0].clientY;

				} else {
					mouseX = e.clientX;
					mouseY = e.clientY;
				}

				// Scale mouse coordinates into canvas coordinates
				// by following the pattern laid out by 'jerryj' in the comments of
				// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
				var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
				var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
				var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
				var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
				var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
				var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

				// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
				// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
				mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
				mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

				return {
					x: mouseX,
					y: mouseY
				};

			};
			helpers.addEvent = function (node, eventType, method) {
				if (node.addEventListener) {
					node.addEventListener(eventType, method);
				} else if (node.attachEvent) {
					node.attachEvent("on" + eventType, method);
				} else {
					node["on" + eventType] = method;
				}
			};
			helpers.removeEvent = function (node, eventType, handler) {
				if (node.removeEventListener) {
					node.removeEventListener(eventType, handler, false);
				} else if (node.detachEvent) {
					node.detachEvent("on" + eventType, handler);
				} else {
					node["on" + eventType] = helpers.noop;
				}
			};
			helpers.bindEvents = function (chartInstance, arrayOfEvents, handler) {
				// Create the events object if it's not already present
				if (!chartInstance.events)
					chartInstance.events = {};

				helpers.each(arrayOfEvents, function (eventName) {
					chartInstance.events[eventName] = function () {
						handler.apply(chartInstance, arguments);
					};
					helpers.addEvent(chartInstance.chart.canvas, eventName, chartInstance.events[eventName]);
				});
			};
			helpers.unbindEvents = function (chartInstance, arrayOfEvents) {
				helpers.each(arrayOfEvents, function (handler, eventName) {
					helpers.removeEvent(chartInstance.chart.canvas, eventName, handler);
				});
			};

			// Private helper function to convert max-width/max-height values that may be percentages into a number
			function parseMaxStyle(styleValue, node, parentProperty) {
				var valueInPixels;
				if (typeof (styleValue) === 'string') {
					valueInPixels = parseInt(styleValue, 10);

					if (styleValue.indexOf('%') != -1) {
						// percentage * size in dimension
						valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
					}
				} else {
					valueInPixels = styleValue;
				}

				return valueInPixels;
			}

			// Private helper to get a constraint dimension
			// @param domNode : the node to check the constraint on
			// @param maxStyle : the style that defines the maximum for the direction we are using (max-width / max-height)
			// @param percentageProperty : property of parent to use when calculating width as a percentage
			function getConstraintDimension(domNode, maxStyle, percentageProperty) {
				var constrainedDimension;
				var constrainedNode = document.defaultView.getComputedStyle(domNode)[maxStyle];
				var constrainedContainer = document.defaultView.getComputedStyle(domNode.parentNode)[maxStyle];
				var hasCNode = constrainedNode !== null && constrainedNode !== "none";
				var hasCContainer = constrainedContainer !== null && constrainedContainer !== "none";

				if (hasCNode || hasCContainer) {
					constrainedDimension = Math.min((hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : Number.POSITIVE_INFINITY), (hasCContainer ? parseMaxStyle(constrainedContainer, domNode.parentNode, percentageProperty) : Number.POSITIVE_INFINITY));
				}
				return constrainedDimension;
			}
			// returns Number or undefined if no constraint
			helpers.getConstraintWidth = function (domNode) {
				return getConstraintDimension(domNode, 'max-width', 'clientWidth');
			};
			// returns Number or undefined if no constraint
			helpers.getConstraintHeight = function (domNode) {
				return getConstraintDimension(domNode, 'max-height', 'clientHeight');
			};
			helpers.getMaximumWidth = function (domNode) {
				var container = domNode.parentNode;
				var padding = parseInt(helpers.getStyle(container, 'padding-left')) + parseInt(helpers.getStyle(container, 'padding-right'));

				var w = container.clientWidth - padding;
				var cw = helpers.getConstraintWidth(domNode);
				if (cw !== undefined) {
					w = Math.min(w, cw);
				}

				return w;
			};
			helpers.getMaximumHeight = function (domNode) {
				var container = domNode.parentNode;
				var padding = parseInt(helpers.getStyle(container, 'padding-top')) + parseInt(helpers.getStyle(container, 'padding-bottom'));

				var h = container.clientHeight - padding;
				var ch = helpers.getConstraintHeight(domNode);
				if (ch !== undefined) {
					h = Math.min(h, ch);
				}

				return h;
			};
			helpers.getStyle = function (el, property) {
				return el.currentStyle ?
					el.currentStyle[property] :
					document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
			};
			helpers.retinaScale = function (chart) {
				var ctx = chart.ctx;
				var width = chart.canvas.width;
				var height = chart.canvas.height;
				var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;

				if (pixelRatio !== 1) {
					ctx.canvas.height = height * pixelRatio;
					ctx.canvas.width = width * pixelRatio;
					ctx.scale(pixelRatio, pixelRatio);

					// Store the device pixel ratio so that we can go backwards in `destroy`.
					// The devicePixelRatio changes with zoom, so there are no guarantees that it is the same
					// when destroy is called
					chart.originalDevicePixelRatio = chart.originalDevicePixelRatio || pixelRatio;
				}

				ctx.canvas.style.width = width + 'px';
				ctx.canvas.style.height = height + 'px';
			};
			//-- Canvas methods
			helpers.clear = function (chart) {
				chart.ctx.clearRect(0, 0, chart.width, chart.height);
			};
			helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
				return fontStyle + " " + pixelSize + "px " + fontFamily;
			};
			helpers.longestText = function (ctx, font, arrayOfStrings, cache) {
				cache = cache || {};
				cache.data = cache.data || {};
				cache.garbageCollect = cache.garbageCollect || [];

				if (cache.font !== font) {
					cache.data = {};
					cache.garbageCollect = [];
					cache.font = font;
				}

				ctx.font = font;
				var longest = 0;
				helpers.each(arrayOfStrings, function (string) {
					// Undefined strings should not be measured
					if (string !== undefined && string !== null) {
						var textWidth = cache.data[string];
						if (!textWidth) {
							textWidth = cache.data[string] = ctx.measureText(string).width;
							cache.garbageCollect.push(string);
						}

						if (textWidth > longest) {
							longest = textWidth;
						}
					}
				});

				var gcLen = cache.garbageCollect.length / 2;
				if (gcLen > arrayOfStrings.length) {
					for (var i = 0; i < gcLen; i++) {
						delete cache.data[cache.garbageCollect[i]];
					}
					cache.garbageCollect.splice(0, gcLen);
				}

				return longest;
			};
			helpers.drawRoundedRectangle = function (ctx, x, y, width, height, radius) {
				ctx.beginPath();
				ctx.moveTo(x + radius, y);
				ctx.lineTo(x + width - radius, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
				ctx.lineTo(x + width, y + height - radius);
				ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
				ctx.lineTo(x + radius, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
				ctx.lineTo(x, y + radius);
				ctx.quadraticCurveTo(x, y, x + radius, y);
				ctx.closePath();
			};
			helpers.color = function (c) {
				if (!color) {
					console.log('Color.js not found!');
					return c;
				}

				/* global CanvasGradient */
				if (c instanceof CanvasGradient) {
					return color(Chart.defaults.global.defaultColor);
				}

				return color(c);
			};
			helpers.addResizeListener = function (node, callback) {
				// Hide an iframe before the node
				var hiddenIframe = document.createElement('iframe');
				var hiddenIframeClass = 'chartjs-hidden-iframe';

				if (hiddenIframe.classlist) {
					// can use classlist
					hiddenIframe.classlist.add(hiddenIframeClass);
				} else {
					hiddenIframe.setAttribute('class', hiddenIframeClass);
				}

				// Set the style
				hiddenIframe.style.width = '100%';
				hiddenIframe.style.display = 'block';
				hiddenIframe.style.border = 0;
				hiddenIframe.style.height = 0;
				hiddenIframe.style.margin = 0;
				hiddenIframe.style.position = 'absolute';
				hiddenIframe.style.left = 0;
				hiddenIframe.style.right = 0;
				hiddenIframe.style.top = 0;
				hiddenIframe.style.bottom = 0;

				// Insert the iframe so that contentWindow is available
				node.insertBefore(hiddenIframe, node.firstChild);

				(hiddenIframe.contentWindow || hiddenIframe).onresize = function () {
					if (callback) {
						callback();
					}
				};
			};
			helpers.removeResizeListener = function (node) {
				var hiddenIframe = node.querySelector('.chartjs-hidden-iframe');

				// Remove the resize detect iframe
				if (hiddenIframe) {
					hiddenIframe.parentNode.removeChild(hiddenIframe);
				}
			};
			helpers.isArray = function (obj) {
				if (!Array.isArray) {
					return Object.prototype.toString.call(obj) === '[object Array]';
				}
				return Array.isArray(obj);
			};
			helpers.pushAllIfDefined = function (element, array) {
				if (typeof element === "undefined") {
					return;
				}

				if (helpers.isArray(element)) {
					array.push.apply(array, element);
				} else {
					array.push(element);
				}
			};
			helpers.callCallback = function (fn, args, _tArg) {
				if (fn && typeof fn.call === 'function') {
					fn.apply(_tArg, args);
				}
			};
			helpers.getHoverColor = function (color) {
				/* global CanvasPattern */
				return (color instanceof CanvasPattern) ?
					color :
					helpers.color(color).saturate(0.5).darken(0.1).rgbString();
			};
		};

	}, { "chartjs-color": 3 }], 26: [function (require, module, exports) {
		"use strict";

		module.exports = function () {

			//Occupy the global variable of Chart, and create a simple base class
			var Chart = function (context, config) {
				this.config = config;

				// Support a jQuery'd canvas element
				if (context.length && context[0].getContext) {
					context = context[0];
				}

				// Support a canvas domnode
				if (context.getContext) {
					context = context.getContext("2d");
				}

				this.ctx = context;
				this.canvas = context.canvas;

				// Figure out what the size of the chart will be.
				// If the canvas has a specified width and height, we use those else
				// we look to see if the canvas node has a CSS width and height.
				// If there is still no height, fill the parent container
				this.width = context.canvas.width || parseInt(Chart.helpers.getStyle(context.canvas, 'width')) || Chart.helpers.getMaximumWidth(context.canvas);
				this.height = context.canvas.height || parseInt(Chart.helpers.getStyle(context.canvas, 'height')) || Chart.helpers.getMaximumHeight(context.canvas);

				this.aspectRatio = this.width / this.height;

				if (isNaN(this.aspectRatio) || isFinite(this.aspectRatio) === false) {
					// If the canvas has no size, try and figure out what the aspect ratio will be.
					// Some charts prefer square canvases (pie, radar, etc). If that is specified, use that
					// else use the canvas default ratio of 2
					this.aspectRatio = config.aspectRatio !== undefined ? config.aspectRatio : 2;
				}

				// Store the original style of the element so we can set it back
				this.originalCanvasStyleWidth = context.canvas.style.width;
				this.originalCanvasStyleHeight = context.canvas.style.height;

				// High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
				Chart.helpers.retinaScale(this);

				if (config) {
					this.controller = new Chart.Controller(this);
				}

				// Always bind this so that if the responsive state changes we still work
				var _this = this;
				Chart.helpers.addResizeListener(context.canvas.parentNode, function () {
					if (_this.controller && _this.controller.config.options.responsive) {
						_this.controller.resize();
					}
				});

				return this.controller ? this.controller : this;

			};

			//Globally expose the defaults to allow for user updating/changing
			Chart.defaults = {
				global: {
					responsive: true,
					responsiveAnimationDuration: 0,
					maintainAspectRatio: true,
					events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
					hover: {
						onHover: null,
						mode: 'single',
						animationDuration: 400
					},
					onClick: null,
					defaultColor: 'rgba(0,0,0,0.1)',
					defaultFontColor: '#666',
					defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
					defaultFontSize: 12,
					defaultFontStyle: 'normal',
					showLines: true,

					// Element defaults defined in element extensions
					elements: {},

					// Legend callback string
					legendCallback: function (chart) {
						var text = [];
						text.push('<ul class="' + chart.id + '-legend">');
						for (var i = 0; i < chart.data.datasets.length; i++) {
							text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
							if (chart.data.datasets[i].label) {
								text.push(chart.data.datasets[i].label);
							}
							text.push('</li>');
						}
						text.push('</ul>');

						return text.join("");
					}
				}
			};

			return Chart;

		};

	}, {}], 27: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			// The layout service is very self explanatory.  It's responsible for the layout within a chart.
			// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
			// It is this service's responsibility of carrying out that layout.
			Chart.layoutService = {
				defaults: {},

				// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.
				addBox: function (chartInstance, box) {
					if (!chartInstance.boxes) {
						chartInstance.boxes = [];
					}
					chartInstance.boxes.push(box);
				},

				removeBox: function (chartInstance, box) {
					if (!chartInstance.boxes) {
						return;
					}
					chartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);
				},

				// The most important function
				update: function (chartInstance, width, height) {

					if (!chartInstance) {
						return;
					}

					var xPadding = 0;
					var yPadding = 0;

					var leftBoxes = helpers.where(chartInstance.boxes, function (box) {
						return box.options.position === "left";
					});
					var rightBoxes = helpers.where(chartInstance.boxes, function (box) {
						return box.options.position === "right";
					});
					var topBoxes = helpers.where(chartInstance.boxes, function (box) {
						return box.options.position === "top";
					});
					var bottomBoxes = helpers.where(chartInstance.boxes, function (box) {
						return box.options.position === "bottom";
					});

					// Boxes that overlay the chartarea such as the radialLinear scale
					var chartAreaBoxes = helpers.where(chartInstance.boxes, function (box) {
						return box.options.position === "chartArea";
					});

					// Ensure that full width boxes are at the very top / bottom
					topBoxes.sort(function (a, b) {
						return (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);
					});
					bottomBoxes.sort(function (a, b) {
						return (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);
					});

					// Essentially we now have any number of boxes on each of the 4 sides.
					// Our canvas looks like the following.
					// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
					// B1 is the bottom axis
					// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
					// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
					// an error will be thrown.
					//
					// |----------------------------------------------------|
					// |                  T1 (Full Width)                   |
					// |----------------------------------------------------|
					// |    |    |                 T2                  |    |
					// |    |----|-------------------------------------|----|
					// |    |    | C1 |                           | C2 |    |
					// |    |    |----|                           |----|    |
					// |    |    |                                     |    |
					// | L1 | L2 |           ChartArea (C0)            | R1 |
					// |    |    |                                     |    |
					// |    |    |----|                           |----|    |
					// |    |    | C3 |                           | C4 |    |
					// |    |----|-------------------------------------|----|
					// |    |    |                 B1                  |    |
					// |----------------------------------------------------|
					// |                  B2 (Full Width)                   |
					// |----------------------------------------------------|
					//
					// What we do to find the best sizing, we do the following
					// 1. Determine the minimum size of the chart area.
					// 2. Split the remaining width equally between each vertical axis
					// 3. Split the remaining height equally between each horizontal axis
					// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
					// 5. Adjust the sizes of each axis based on it's minimum reported size.
					// 6. Refit each axis
					// 7. Position each axis in the final location
					// 8. Tell the chart the final location of the chart area
					// 9. Tell any axes that overlay the chart area the positions of the chart area

					// Step 1
					var chartWidth = width - (2 * xPadding);
					var chartHeight = height - (2 * yPadding);
					var chartAreaWidth = chartWidth / 2; // min 50%
					var chartAreaHeight = chartHeight / 2; // min 50%

					// Step 2
					var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

					// Step 3
					var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

					// Step 4
					var maxChartAreaWidth = chartWidth;
					var maxChartAreaHeight = chartHeight;
					var minBoxSizes = [];

					helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

					function getMinimumBoxSize(box) {
						var minSize;
						var isHorizontal = box.isHorizontal();

						if (isHorizontal) {
							minSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
							maxChartAreaHeight -= minSize.height;
						} else {
							minSize = box.update(verticalBoxWidth, chartAreaHeight);
							maxChartAreaWidth -= minSize.width;
						}

						minBoxSizes.push({
							horizontal: isHorizontal,
							minSize: minSize,
							box: box
						});
					}

					// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
					// be if the axes are drawn at their minimum sizes.

					// Steps 5 & 6
					var totalLeftBoxesWidth = xPadding;
					var totalRightBoxesWidth = xPadding;
					var totalTopBoxesHeight = yPadding;
					var totalBottomBoxesHeight = yPadding;

					// Update, and calculate the left and right margins for the horizontal boxes
					helpers.each(leftBoxes.concat(rightBoxes), fitBox);

					helpers.each(leftBoxes, function (box) {
						totalLeftBoxesWidth += box.width;
					});

					helpers.each(rightBoxes, function (box) {
						totalRightBoxesWidth += box.width;
					});

					// Set the Left and Right margins for the horizontal boxes
					helpers.each(topBoxes.concat(bottomBoxes), fitBox);

					// Function to fit a box
					function fitBox(box) {
						var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBoxSize) {
							return minBoxSize.box === box;
						});

						if (minBoxSize) {
							if (box.isHorizontal()) {
								var scaleMargin = {
									left: totalLeftBoxesWidth,
									right: totalRightBoxesWidth,
									top: 0,
									bottom: 0
								};

								// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
								// on the margin. Sometimes they need to increase in size slightly
								box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
							} else {
								box.update(minBoxSize.minSize.width, maxChartAreaHeight);
							}
						}
					}

					// Figure out how much margin is on the top and bottom of the vertical boxes
					helpers.each(topBoxes, function (box) {
						totalTopBoxesHeight += box.height;
					});

					helpers.each(bottomBoxes, function (box) {
						totalBottomBoxesHeight += box.height;
					});

					// Let the left layout know the final margin
					helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

					function finalFitVerticalBox(box) {
						var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBoxSize) {
							return minBoxSize.box === box;
						});

						var scaleMargin = {
							left: 0,
							right: 0,
							top: totalTopBoxesHeight,
							bottom: totalBottomBoxesHeight
						};

						if (minBoxSize) {
							box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
						}
					}

					// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
					totalLeftBoxesWidth = xPadding;
					totalRightBoxesWidth = xPadding;
					totalTopBoxesHeight = yPadding;
					totalBottomBoxesHeight = yPadding;

					helpers.each(leftBoxes, function (box) {
						totalLeftBoxesWidth += box.width;
					});

					helpers.each(rightBoxes, function (box) {
						totalRightBoxesWidth += box.width;
					});

					helpers.each(topBoxes, function (box) {
						totalTopBoxesHeight += box.height;
					});
					helpers.each(bottomBoxes, function (box) {
						totalBottomBoxesHeight += box.height;
					});

					// Figure out if our chart area changed. This would occur if the dataset layout label rotation
					// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
					// without calling `fit` again
					var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
					var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

					if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
						helpers.each(leftBoxes, function (box) {
							box.height = newMaxChartAreaHeight;
						});

						helpers.each(rightBoxes, function (box) {
							box.height = newMaxChartAreaHeight;
						});

						helpers.each(topBoxes, function (box) {
							if (!box.options.fullWidth) {
								box.width = newMaxChartAreaWidth;
							}
						});

						helpers.each(bottomBoxes, function (box) {
							if (!box.options.fullWidth) {
								box.width = newMaxChartAreaWidth;
							}
						});

						maxChartAreaHeight = newMaxChartAreaHeight;
						maxChartAreaWidth = newMaxChartAreaWidth;
					}

					// Step 7 - Position the boxes
					var left = xPadding;
					var top = yPadding;
					var right = 0;
					var bottom = 0;

					helpers.each(leftBoxes.concat(topBoxes), placeBox);

					// Account for chart width and height
					left += maxChartAreaWidth;
					top += maxChartAreaHeight;

					helpers.each(rightBoxes, placeBox);
					helpers.each(bottomBoxes, placeBox);

					function placeBox(box) {
						if (box.isHorizontal()) {
							box.left = box.options.fullWidth ? xPadding : totalLeftBoxesWidth;
							box.right = box.options.fullWidth ? width - xPadding : totalLeftBoxesWidth + maxChartAreaWidth;
							box.top = top;
							box.bottom = top + box.height;

							// Move to next point
							top = box.bottom;

						} else {

							box.left = left;
							box.right = left + box.width;
							box.top = totalTopBoxesHeight;
							box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

							// Move to next point
							left = box.right;
						}
					}

					// Step 8
					chartInstance.chartArea = {
						left: totalLeftBoxesWidth,
						top: totalTopBoxesHeight,
						right: totalLeftBoxesWidth + maxChartAreaWidth,
						bottom: totalTopBoxesHeight + maxChartAreaHeight
					};

					// Step 9
					helpers.each(chartAreaBoxes, function (box) {
						box.left = chartInstance.chartArea.left;
						box.top = chartInstance.chartArea.top;
						box.right = chartInstance.chartArea.right;
						box.bottom = chartInstance.chartArea.bottom;

						box.update(maxChartAreaWidth, maxChartAreaHeight);
					});
				}
			};
		};

	}, {}], 28: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;
			var noop = helpers.noop;

			Chart.defaults.global.legend = {

				display: true,
				position: 'top',
				fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)
				reverse: false,

				// a callback that will handle
				onClick: function (e, legendItem) {
					var index = legendItem.datasetIndex;
					var ci = this.chart;
					var meta = ci.getDatasetMeta(index);

					// See controller.isDatasetVisible comment
					meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

					// We hid a dataset ... rerender the chart
					ci.update();
				},

				labels: {
					boxWidth: 40,
					padding: 10,
					// Generates labels shown in the legend
					// Valid properties to return:
					// text : text to display
					// fillStyle : fill of coloured box
					// strokeStyle: stroke of coloured box
					// hidden : if this legend item refers to a hidden item
					// lineCap : cap style for line
					// lineDash
					// lineDashOffset :
					// lineJoin :
					// lineWidth :
					generateLabels: function (chart) {
						var data = chart.data;
						return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
							return {
								text: dataset.label,
								fillStyle: dataset.backgroundColor,
								hidden: !chart.isDatasetVisible(i),
								lineCap: dataset.borderCapStyle,
								lineDash: dataset.borderDash,
								lineDashOffset: dataset.borderDashOffset,
								lineJoin: dataset.borderJoinStyle,
								lineWidth: dataset.borderWidth,
								strokeStyle: dataset.borderColor,

								// Below is extra data used for toggling the datasets
								datasetIndex: i
							};
						}, this) : [];
					}
				}
			};

			Chart.Legend = Chart.Element.extend({

				initialize: function (config) {
					helpers.extend(this, config);

					// Contains hit boxes for each dataset (in dataset order)
					this.legendHitBoxes = [];

					// Are we in doughnut mode which has a different data type
					this.doughnutMode = false;
				},

				// These methods are ordered by lifecyle. Utilities then follow.
				// Any function defined here is inherited by all legend types.
				// Any function can be extended by the legend type

				beforeUpdate: noop,
				update: function (maxWidth, maxHeight, margins) {

					// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
					this.beforeUpdate();

					// Absorb the master measurements
					this.maxWidth = maxWidth;
					this.maxHeight = maxHeight;
					this.margins = margins;

					// Dimensions
					this.beforeSetDimensions();
					this.setDimensions();
					this.afterSetDimensions();
					// Labels
					this.beforeBuildLabels();
					this.buildLabels();
					this.afterBuildLabels();

					// Fit
					this.beforeFit();
					this.fit();
					this.afterFit();
					//
					this.afterUpdate();

					return this.minSize;
				},
				afterUpdate: noop,

				//

				beforeSetDimensions: noop,
				setDimensions: function () {
					// Set the unconstrained dimension before label rotation
					if (this.isHorizontal()) {
						// Reset position before calculating rotation
						this.width = this.maxWidth;
						this.left = 0;
						this.right = this.width;
					} else {
						this.height = this.maxHeight;

						// Reset position before calculating rotation
						this.top = 0;
						this.bottom = this.height;
					}

					// Reset padding
					this.paddingLeft = 0;
					this.paddingTop = 0;
					this.paddingRight = 0;
					this.paddingBottom = 0;

					// Reset minSize
					this.minSize = {
						width: 0,
						height: 0
					};
				},
				afterSetDimensions: noop,

				//

				beforeBuildLabels: noop,
				buildLabels: function () {
					this.legendItems = this.options.labels.generateLabels.call(this, this.chart);
					if (this.options.reverse) {
						this.legendItems.reverse();
					}
				},
				afterBuildLabels: noop,

				//

				beforeFit: noop,
				fit: function () {
					var opts = this.options;
					var labelOpts = opts.labels;
					var display = opts.display;

					var ctx = this.ctx;

					var globalDefault = Chart.defaults.global,
						itemOrDefault = helpers.getValueOrDefault,
						fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
						fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
						fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
						labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

					// Reset hit boxes
					var hitboxes = this.legendHitBoxes = [];

					var minSize = this.minSize;
					var isHorizontal = this.isHorizontal();

					if (isHorizontal) {
						minSize.width = this.maxWidth; // fill all the width
						minSize.height = display ? 10 : 0;
					} else {
						minSize.width = display ? 10 : 0;
						minSize.height = this.maxHeight; // fill all the height
					}

					// Increase sizes here
					if (display) {
						if (isHorizontal) {
							// Labels

							// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
							var lineWidths = this.lineWidths = [0];
							var totalHeight = this.legendItems.length ? fontSize + (labelOpts.padding) : 0;

							ctx.textAlign = "left";
							ctx.textBaseline = 'top';
							ctx.font = labelFont;

							helpers.each(this.legendItems, function (legendItem, i) {
								var width = labelOpts.boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
								if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= this.width) {
									totalHeight += fontSize + (labelOpts.padding);
									lineWidths[lineWidths.length] = this.left;
								}

								// Store the hitbox width and height here. Final position will be updated in `draw`
								hitboxes[i] = {
									left: 0,
									top: 0,
									width: width,
									height: fontSize
								};

								lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
							}, this);

							minSize.height += totalHeight;

						} else {
							// TODO vertical
						}
					}

					this.width = minSize.width;
					this.height = minSize.height;
				},
				afterFit: noop,

				// Shared Methods
				isHorizontal: function () {
					return this.options.position === "top" || this.options.position === "bottom";
				},

				// Actualy draw the legend on the canvas
				draw: function () {
					var opts = this.options;
					var labelOpts = opts.labels;
					var globalDefault = Chart.defaults.global,
						lineDefault = globalDefault.elements.line,
						legendWidth = this.width,
						lineWidths = this.lineWidths;

					if (opts.display) {
						var ctx = this.ctx,
							cursor = {
								x: this.left + ((legendWidth - lineWidths[0]) / 2),
								y: this.top + labelOpts.padding,
								line: 0
							},
							itemOrDefault = helpers.getValueOrDefault,
							fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),
							fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
							fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
							fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
							labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

						// Horizontal
						if (this.isHorizontal()) {
							// Labels
							ctx.textAlign = "left";
							ctx.textBaseline = 'top';
							ctx.lineWidth = 0.5;
							ctx.strokeStyle = fontColor; // for strikethrough effect
							ctx.fillStyle = fontColor; // render in correct colour
							ctx.font = labelFont;

							var boxWidth = labelOpts.boxWidth,
								hitboxes = this.legendHitBoxes;

							helpers.each(this.legendItems, function (legendItem, i) {
								var textWidth = ctx.measureText(legendItem.text).width,
									width = boxWidth + (fontSize / 2) + textWidth,
									x = cursor.x,
									y = cursor.y;

								if (x + width >= legendWidth) {
									y = cursor.y += fontSize + (labelOpts.padding);
									cursor.line++;
									x = cursor.x = this.left + ((legendWidth - lineWidths[cursor.line]) / 2);
								}

								// Set the ctx for the box
								ctx.save();

								ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
								ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
								ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
								ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
								ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
								ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);

								if (ctx.setLineDash) {
									// IE 9 and 10 do not support line dash
									ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));
								}

								// Draw the box
								ctx.strokeRect(x, y, boxWidth, fontSize);
								ctx.fillRect(x, y, boxWidth, fontSize);

								ctx.restore();

								hitboxes[i].left = x;
								hitboxes[i].top = y;

								// Fill the actual label
								ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);

								if (legendItem.hidden) {
									// Strikethrough the text if hidden
									ctx.beginPath();
									ctx.lineWidth = 2;
									ctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));
									ctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));
									ctx.stroke();
								}

								cursor.x += width + (labelOpts.padding);
							}, this);
						} else {

						}
					}
				},

				// Handle an event
				handleEvent: function (e) {
					var position = helpers.getRelativePosition(e, this.chart.chart),
						x = position.x,
						y = position.y,
						opts = this.options;

					if (x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {
						// See if we are touching one of the dataset boxes
						var lh = this.legendHitBoxes;
						for (var i = 0; i < lh.length; ++i) {
							var hitBox = lh[i];

							if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
								// Touching an element
								if (opts.onClick) {
									opts.onClick.call(this, e, this.legendItems[i]);
								}
								break;
							}
						}
					}
				}
			});

		};

	}, {}], 29: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {
			var helpers = Chart.helpers;

			// Plugins are stored here
			Chart.plugins = [];
			Chart.pluginService = {
				// Register a new plugin
				register: function (plugin) {
					var p = Chart.plugins;
					if (p.indexOf(plugin) === -1) {
						p.push(plugin);
					}
				},

				// Remove a registered plugin
				remove: function (plugin) {
					var p = Chart.plugins;
					var idx = p.indexOf(plugin);
					if (idx !== -1) {
						p.splice(idx, 1);
					}
				},

				// Iterate over all plugins
				notifyPlugins: function (method, args, scope) {
					helpers.each(Chart.plugins, function (plugin) {
						if (plugin[method] && typeof plugin[method] === 'function') {
							plugin[method].apply(scope, args);
						}
					}, scope);
				}
			};

			var noop = helpers.noop;
			Chart.PluginBase = Chart.Element.extend({
				// Plugin methods. All functions are passed the chart instance

				// Called at start of chart init
				beforeInit: noop,

				// Called at end of chart init
				afterInit: noop,

				// Called at start of update
				beforeUpdate: noop,

				// Called at end of update
				afterUpdate: noop,

				// Called at start of draw
				beforeDraw: noop,

				// Called at end of draw
				afterDraw: noop,

				// Called during destroy
				destroy: noop,
			});
		};

	}, {}], 30: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.scale = {
				display: true,
				position: "left",

				// grid line settings
				gridLines: {
					display: true,
					color: "rgba(0, 0, 0, 0.1)",
					lineWidth: 1,
					drawOnChartArea: true,
					drawTicks: true,
					tickMarkLength: 10,
					zeroLineWidth: 1,
					zeroLineColor: "rgba(0,0,0,0.25)",
					offsetGridLines: false
				},

				// scale label
				scaleLabel: {
					// actual label
					labelString: '',

					// display property
					display: false
				},

				// label settings
				ticks: {
					beginAtZero: false,
					minRotation: 0,
					maxRotation: 50,
					mirror: false,
					padding: 10,
					reverse: false,
					display: true,
					autoSkip: true,
					autoSkipPadding: 0,
					labelOffset: 0,
					callback: function (value) {
						return '' + value;
					}
				}
			};

			Chart.Scale = Chart.Element.extend({

				// These methods are ordered by lifecyle. Utilities then follow.
				// Any function defined here is inherited by all scale types.
				// Any function can be extended by the scale type

				beforeUpdate: function () {
					helpers.callCallback(this.options.beforeUpdate, [this]);
				},
				update: function (maxWidth, maxHeight, margins) {

					// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
					this.beforeUpdate();

					// Absorb the master measurements
					this.maxWidth = maxWidth;
					this.maxHeight = maxHeight;
					this.margins = helpers.extend({
						left: 0,
						right: 0,
						top: 0,
						bottom: 0
					}, margins);

					// Dimensions
					this.beforeSetDimensions();
					this.setDimensions();
					this.afterSetDimensions();

					// Data min/max
					this.beforeDataLimits();
					this.determineDataLimits();
					this.afterDataLimits();

					// Ticks
					this.beforeBuildTicks();
					this.buildTicks();
					this.afterBuildTicks();

					this.beforeTickToLabelConversion();
					this.convertTicksToLabels();
					this.afterTickToLabelConversion();

					// Tick Rotation
					this.beforeCalculateTickRotation();
					this.calculateTickRotation();
					this.afterCalculateTickRotation();
					// Fit
					this.beforeFit();
					this.fit();
					this.afterFit();
					//
					this.afterUpdate();

					return this.minSize;

				},
				afterUpdate: function () {
					helpers.callCallback(this.options.afterUpdate, [this]);
				},

				//

				beforeSetDimensions: function () {
					helpers.callCallback(this.options.beforeSetDimensions, [this]);
				},
				setDimensions: function () {
					// Set the unconstrained dimension before label rotation
					if (this.isHorizontal()) {
						// Reset position before calculating rotation
						this.width = this.maxWidth;
						this.left = 0;
						this.right = this.width;
					} else {
						this.height = this.maxHeight;

						// Reset position before calculating rotation
						this.top = 0;
						this.bottom = this.height;
					}

					// Reset padding
					this.paddingLeft = 0;
					this.paddingTop = 0;
					this.paddingRight = 0;
					this.paddingBottom = 0;
				},
				afterSetDimensions: function () {
					helpers.callCallback(this.options.afterSetDimensions, [this]);
				},

				// Data limits
				beforeDataLimits: function () {
					helpers.callCallback(this.options.beforeDataLimits, [this]);
				},
				determineDataLimits: helpers.noop,
				afterDataLimits: function () {
					helpers.callCallback(this.options.afterDataLimits, [this]);
				},

				//
				beforeBuildTicks: function () {
					helpers.callCallback(this.options.beforeBuildTicks, [this]);
				},
				buildTicks: helpers.noop,
				afterBuildTicks: function () {
					helpers.callCallback(this.options.afterBuildTicks, [this]);
				},

				beforeTickToLabelConversion: function () {
					helpers.callCallback(this.options.beforeTickToLabelConversion, [this]);
				},
				convertTicksToLabels: function () {
					// Convert ticks to strings
					this.ticks = this.ticks.map(function (numericalTick, index, ticks) {
						if (this.options.ticks.userCallback) {
							return this.options.ticks.userCallback(numericalTick, index, ticks);
						}
						return this.options.ticks.callback(numericalTick, index, ticks);
					},
						this);
				},
				afterTickToLabelConversion: function () {
					helpers.callCallback(this.options.afterTickToLabelConversion, [this]);
				},

				//

				beforeCalculateTickRotation: function () {
					helpers.callCallback(this.options.beforeCalculateTickRotation, [this]);
				},
				calculateTickRotation: function () {
					//Get the width of each grid by calculating the difference
					//between x offsets between 0 and 1.
					var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
					var tickFontStyle = helpers.getValueOrDefault(this.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
					var tickFontFamily = helpers.getValueOrDefault(this.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
					var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
					this.ctx.font = tickLabelFont;

					var firstWidth = this.ctx.measureText(this.ticks[0]).width;
					var lastWidth = this.ctx.measureText(this.ticks[this.ticks.length - 1]).width;
					var firstRotated;

					this.labelRotation = this.options.ticks.minRotation || 0;
					this.paddingRight = 0;
					this.paddingLeft = 0;

					if (this.options.display) {
						if (this.isHorizontal()) {
							this.paddingRight = lastWidth / 2 + 3;
							this.paddingLeft = firstWidth / 2 + 3;

							if (!this.longestTextCache) {
								this.longestTextCache = {};
							}
							var originalLabelWidth = helpers.longestText(this.ctx, tickLabelFont, this.ticks, this.longestTextCache);
							var labelWidth = originalLabelWidth;
							var cosRotation;
							var sinRotation;

							// Allow 3 pixels x2 padding either side for label readability
							// only the index matters for a dataset scale, but we want a consistent interface between scales
							var tickWidth = this.getPixelForTick(1) - this.getPixelForTick(0) - 6;

							//Max label rotation can be set or default to 90 - also act as a loop counter
							while (labelWidth > tickWidth && this.labelRotation < this.options.ticks.maxRotation) {
								cosRotation = Math.cos(helpers.toRadians(this.labelRotation));
								sinRotation = Math.sin(helpers.toRadians(this.labelRotation));

								firstRotated = cosRotation * firstWidth;

								// We're right aligning the text now.
								if (firstRotated + tickFontSize / 2 > this.yLabelWidth) {
									this.paddingLeft = firstRotated + tickFontSize / 2;
								}

								this.paddingRight = tickFontSize / 2;

								if (sinRotation * originalLabelWidth > this.maxHeight) {
									// go back one step
									this.labelRotation--;
									break;
								}

								this.labelRotation++;
								labelWidth = cosRotation * originalLabelWidth;
							}
						}
					}

					if (this.margins) {
						this.paddingLeft = Math.max(this.paddingLeft - this.margins.left, 0);
						this.paddingRight = Math.max(this.paddingRight - this.margins.right, 0);
					}
				},
				afterCalculateTickRotation: function () {
					helpers.callCallback(this.options.afterCalculateTickRotation, [this]);
				},

				//

				beforeFit: function () {
					helpers.callCallback(this.options.beforeFit, [this]);
				},
				fit: function () {
					// Reset
					var minSize = this.minSize = {
						width: 0,
						height: 0
					};

					var opts = this.options;
					var tickOpts = opts.ticks;
					var scaleLabelOpts = opts.scaleLabel;
					var globalOpts = Chart.defaults.global;
					var display = opts.display;
					var isHorizontal = this.isHorizontal();

					var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalOpts.defaultFontSize);
					var tickFontStyle = helpers.getValueOrDefault(tickOpts.fontStyle, globalOpts.defaultFontStyle);
					var tickFontFamily = helpers.getValueOrDefault(tickOpts.fontFamily, globalOpts.defaultFontFamily);
					var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

					var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabelOpts.fontSize, globalOpts.defaultFontSize);
					var scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabelOpts.fontStyle, globalOpts.defaultFontStyle);
					var scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabelOpts.fontFamily, globalOpts.defaultFontFamily);
					var scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);

					var tickMarkLength = opts.gridLines.tickMarkLength;

					// Width
					if (isHorizontal) {
						// subtract the margins to line up with the chartArea if we are a full width scale
						minSize.width = this.isFullWidth() ? this.maxWidth - this.margins.left - this.margins.right : this.maxWidth;
					} else {
						minSize.width = display ? tickMarkLength : 0;
					}

					// height
					if (isHorizontal) {
						minSize.height = display ? tickMarkLength : 0;
					} else {
						minSize.height = this.maxHeight; // fill all the height
					}

					// Are we showing a title for the scale?
					if (scaleLabelOpts.display && display) {
						if (isHorizontal) {
							minSize.height += (scaleLabelFontSize * 1.5);
						} else {
							minSize.width += (scaleLabelFontSize * 1.5);
						}
					}

					if (tickOpts.display && display) {
						// Don't bother fitting the ticks if we are not showing them
						if (!this.longestTextCache) {
							this.longestTextCache = {};
						}

						var largestTextWidth = helpers.longestText(this.ctx, tickLabelFont, this.ticks, this.longestTextCache);

						if (isHorizontal) {
							// A horizontal axis is more constrained by the height.
							this.longestLabelWidth = largestTextWidth;

							// TODO - improve this calculation
							var labelHeight = (Math.sin(helpers.toRadians(this.labelRotation)) * this.longestLabelWidth) + 1.5 * tickFontSize;

							minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight);
							this.ctx.font = tickLabelFont;

							var firstLabelWidth = this.ctx.measureText(this.ticks[0]).width;
							var lastLabelWidth = this.ctx.measureText(this.ticks[this.ticks.length - 1]).width;

							// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated
							// by the font height
							var cosRotation = Math.cos(helpers.toRadians(this.labelRotation));
							var sinRotation = Math.sin(helpers.toRadians(this.labelRotation));
							this.paddingLeft = this.labelRotation !== 0 ? (cosRotation * firstLabelWidth) + 3 : firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
							this.paddingRight = this.labelRotation !== 0 ? (sinRotation * (tickFontSize / 2)) + 3 : lastLabelWidth / 2 + 3; // when rotated
						} else {
							// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first
							var maxLabelWidth = this.maxWidth - minSize.width;

							// Account for padding
							var mirror = tickOpts.mirror;
							if (!mirror) {
								largestTextWidth += this.options.ticks.padding;
							} else {
								// If mirrored text is on the inside so don't expand
								largestTextWidth = 0;
							}

							if (largestTextWidth < maxLabelWidth) {
								// We don't need all the room
								minSize.width += largestTextWidth;
							} else {
								// Expand to max size
								minSize.width = this.maxWidth;
							}

							this.paddingTop = tickFontSize / 2;
							this.paddingBottom = tickFontSize / 2;
						}
					}

					if (this.margins) {
						this.paddingLeft = Math.max(this.paddingLeft - this.margins.left, 0);
						this.paddingTop = Math.max(this.paddingTop - this.margins.top, 0);
						this.paddingRight = Math.max(this.paddingRight - this.margins.right, 0);
						this.paddingBottom = Math.max(this.paddingBottom - this.margins.bottom, 0);
					}

					this.width = minSize.width;
					this.height = minSize.height;

				},
				afterFit: function () {
					helpers.callCallback(this.options.afterFit, [this]);
				},

				// Shared Methods
				isHorizontal: function () {
					return this.options.position === "top" || this.options.position === "bottom";
				},
				isFullWidth: function () {
					return (this.options.fullWidth);
				},

				// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
				getRightValue: function getRightValue(rawValue) {
					// Null and undefined values first
					if (rawValue === null || typeof (rawValue) === 'undefined') {
						return NaN;
					}
					// isNaN(object) returns true, so make sure NaN is checking for a number
					if (typeof (rawValue) === 'number' && isNaN(rawValue)) {
						return NaN;
					}
					// If it is in fact an object, dive in one more level
					if (typeof (rawValue) === "object") {
						if (rawValue instanceof Date) {
							return rawValue;
						} else {
							return getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);
						}
					}

					// Value is good, return it
					return rawValue;
				},

				// Used to get the value to display in the tooltip for the data at the given index
				// function getLabelForIndex(index, datasetIndex)
				getLabelForIndex: helpers.noop,

				// Used to get data value locations.  Value can either be an index or a numerical value
				getPixelForValue: helpers.noop,

				// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
				getValueForPixel: helpers.noop,

				// Used for tick location, should
				getPixelForTick: function (index, includeOffset) {
					if (this.isHorizontal()) {
						var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
						var tickWidth = innerWidth / Math.max((this.ticks.length - ((this.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
						var pixel = (tickWidth * index) + this.paddingLeft;

						if (includeOffset) {
							pixel += tickWidth / 2;
						}

						var finalVal = this.left + Math.round(pixel);
						finalVal += this.isFullWidth() ? this.margins.left : 0;
						return finalVal;
					} else {
						var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
						return this.top + (index * (innerHeight / (this.ticks.length - 1)));
					}
				},

				// Utility for getting the pixel location of a percentage of scale
				getPixelForDecimal: function (decimal /*, includeOffset*/) {
					if (this.isHorizontal()) {
						var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
						var valueOffset = (innerWidth * decimal) + this.paddingLeft;

						var finalVal = this.left + Math.round(valueOffset);
						finalVal += this.isFullWidth() ? this.margins.left : 0;
						return finalVal;
					} else {
						return this.top + (decimal * this.height);
					}
				},

				// Actualy draw the scale on the canvas
				// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
				draw: function (chartArea) {
					if (this.options.display) {

						var setContextLineSettings;
						var isRotated = this.labelRotation !== 0;
						var skipRatio;
						var scaleLabelX;
						var scaleLabelY;
						var useAutoskipper = this.options.ticks.autoSkip;


						// figure out the maximum number of gridlines to show
						var maxTicks;

						if (this.options.ticks.maxTicksLimit) {
							maxTicks = this.options.ticks.maxTicksLimit;
						}

						var tickFontColor = helpers.getValueOrDefault(this.options.ticks.fontColor, Chart.defaults.global.defaultFontColor);
						var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
						var tickFontStyle = helpers.getValueOrDefault(this.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
						var tickFontFamily = helpers.getValueOrDefault(this.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
						var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
						var tl = this.options.gridLines.tickMarkLength;

						var scaleLabelFontColor = helpers.getValueOrDefault(this.options.scaleLabel.fontColor, Chart.defaults.global.defaultFontColor);
						var scaleLabelFontSize = helpers.getValueOrDefault(this.options.scaleLabel.fontSize, Chart.defaults.global.defaultFontSize);
						var scaleLabelFontStyle = helpers.getValueOrDefault(this.options.scaleLabel.fontStyle, Chart.defaults.global.defaultFontStyle);
						var scaleLabelFontFamily = helpers.getValueOrDefault(this.options.scaleLabel.fontFamily, Chart.defaults.global.defaultFontFamily);
						var scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);

						var cosRotation = Math.cos(helpers.toRadians(this.labelRotation));
						var sinRotation = Math.sin(helpers.toRadians(this.labelRotation));
						var longestRotatedLabel = this.longestLabelWidth * cosRotation;
						var rotatedLabelHeight = tickFontSize * sinRotation;

						// Make sure we draw text in the correct color and font
						this.ctx.fillStyle = tickFontColor;

						if (this.isHorizontal()) {
							setContextLineSettings = true;
							var yTickStart = this.options.position === "bottom" ? this.top : this.bottom - tl;
							var yTickEnd = this.options.position === "bottom" ? this.top + tl : this.bottom;
							skipRatio = false;

							if (((longestRotatedLabel / 2) + this.options.ticks.autoSkipPadding) * this.ticks.length > (this.width - (this.paddingLeft + this.paddingRight))) {
								skipRatio = 1 + Math.floor((((longestRotatedLabel / 2) + this.options.ticks.autoSkipPadding) * this.ticks.length) / (this.width - (this.paddingLeft + this.paddingRight)));
							}

							// if they defined a max number of ticks,
							// increase skipRatio until that number is met
							if (maxTicks && this.ticks.length > maxTicks) {
								while (!skipRatio || this.ticks.length / (skipRatio || 1) > maxTicks) {
									if (!skipRatio) {
										skipRatio = 1;
									}
									skipRatio += 1;
								}
							}

							if (!useAutoskipper) {
								skipRatio = false;
							}

							helpers.each(this.ticks, function (label, index) {
								// Blank ticks
								var isLastTick = this.ticks.length === index + 1;

								// Since we always show the last tick,we need may need to hide the last shown one before
								var shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio > this.ticks.length);
								if (shouldSkip && !isLastTick || (label === undefined || label === null)) {
									return;
								}
								var xLineValue = this.getPixelForTick(index); // xvalues for grid lines
								var xLabelValue = this.getPixelForTick(index, this.options.gridLines.offsetGridLines); // x values for ticks (need to consider offsetLabel option)

								if (this.options.gridLines.display) {
									if (index === (typeof this.zeroLineIndex !== 'undefined' ? this.zeroLineIndex : 0)) {
										// Draw the first index specially
										this.ctx.lineWidth = this.options.gridLines.zeroLineWidth;
										this.ctx.strokeStyle = this.options.gridLines.zeroLineColor;
										setContextLineSettings = true; // reset next time
									} else if (setContextLineSettings) {
										this.ctx.lineWidth = this.options.gridLines.lineWidth;
										this.ctx.strokeStyle = this.options.gridLines.color;
										setContextLineSettings = false;
									}

									xLineValue += helpers.aliasPixel(this.ctx.lineWidth);

									// Draw the label area
									this.ctx.beginPath();

									if (this.options.gridLines.drawTicks) {
										this.ctx.moveTo(xLineValue, yTickStart);
										this.ctx.lineTo(xLineValue, yTickEnd);
									}

									// Draw the chart area
									if (this.options.gridLines.drawOnChartArea) {
										this.ctx.moveTo(xLineValue, chartArea.top);
										this.ctx.lineTo(xLineValue, chartArea.bottom);
									}

									// Need to stroke in the loop because we are potentially changing line widths & colours
									this.ctx.stroke();
								}

								if (this.options.ticks.display) {
									this.ctx.save();
									this.ctx.translate(xLabelValue + this.options.ticks.labelOffset, (isRotated) ? this.top + 12 : this.options.position === "top" ? this.bottom - tl : this.top + tl);
									this.ctx.rotate(helpers.toRadians(this.labelRotation) * -1);
									this.ctx.font = tickLabelFont;
									this.ctx.textAlign = (isRotated) ? "right" : "center";
									this.ctx.textBaseline = (isRotated) ? "middle" : this.options.position === "top" ? "bottom" : "top";
									this.ctx.fillText(label, 0, 0);
									this.ctx.restore();
								}
							}, this);

							if (this.options.scaleLabel.display) {
								// Draw the scale label
								this.ctx.textAlign = "center";
								this.ctx.textBaseline = 'middle';
								this.ctx.fillStyle = scaleLabelFontColor; // render in correct colour
								this.ctx.font = scaleLabelFont;

								scaleLabelX = this.left + ((this.right - this.left) / 2); // midpoint of the width
								scaleLabelY = this.options.position === 'bottom' ? this.bottom - (scaleLabelFontSize / 2) : this.top + (scaleLabelFontSize / 2);

								this.ctx.fillText(this.options.scaleLabel.labelString, scaleLabelX, scaleLabelY);
							}

						} else {
							setContextLineSettings = true;
							var xTickStart = this.options.position === "right" ? this.left : this.right - 5;
							var xTickEnd = this.options.position === "right" ? this.left + 5 : this.right;

							helpers.each(this.ticks, function (label, index) {
								// If the callback returned a null or undefined value, do not draw this line
								if (label === undefined || label === null) {
									return;
								}

								var yLineValue = this.getPixelForTick(index); // xvalues for grid lines

								if (this.options.gridLines.display) {
									if (index === (typeof this.zeroLineIndex !== 'undefined' ? this.zeroLineIndex : 0)) {
										// Draw the first index specially
										this.ctx.lineWidth = this.options.gridLines.zeroLineWidth;
										this.ctx.strokeStyle = this.options.gridLines.zeroLineColor;
										setContextLineSettings = true; // reset next time
									} else if (setContextLineSettings) {
										this.ctx.lineWidth = this.options.gridLines.lineWidth;
										this.ctx.strokeStyle = this.options.gridLines.color;
										setContextLineSettings = false;
									}

									yLineValue += helpers.aliasPixel(this.ctx.lineWidth);

									// Draw the label area
									this.ctx.beginPath();

									if (this.options.gridLines.drawTicks) {
										this.ctx.moveTo(xTickStart, yLineValue);
										this.ctx.lineTo(xTickEnd, yLineValue);
									}

									// Draw the chart area
									if (this.options.gridLines.drawOnChartArea) {
										this.ctx.moveTo(chartArea.left, yLineValue);
										this.ctx.lineTo(chartArea.right, yLineValue);
									}

									// Need to stroke in the loop because we are potentially changing line widths & colours
									this.ctx.stroke();
								}

								if (this.options.ticks.display) {
									var xLabelValue;
									var yLabelValue = this.getPixelForTick(index, this.options.gridLines.offsetGridLines); // x values for ticks (need to consider offsetLabel option)

									this.ctx.save();

									if (this.options.position === "left") {
										if (this.options.ticks.mirror) {
											xLabelValue = this.right + this.options.ticks.padding;
											this.ctx.textAlign = "left";
										} else {
											xLabelValue = this.right - this.options.ticks.padding;
											this.ctx.textAlign = "right";
										}
									} else {
										// right side
										if (this.options.ticks.mirror) {
											xLabelValue = this.left - this.options.ticks.padding;
											this.ctx.textAlign = "right";
										} else {
											xLabelValue = this.left + this.options.ticks.padding;
											this.ctx.textAlign = "left";
										}
									}

									this.ctx.translate(xLabelValue, yLabelValue + this.options.ticks.labelOffset);
									this.ctx.rotate(helpers.toRadians(this.labelRotation) * -1);
									this.ctx.font = tickLabelFont;
									this.ctx.textBaseline = "middle";
									this.ctx.fillText(label, 0, 0);
									this.ctx.restore();
								}
							}, this);

							if (this.options.scaleLabel.display) {
								// Draw the scale label
								scaleLabelX = this.options.position === 'left' ? this.left + (scaleLabelFontSize / 2) : this.right - (scaleLabelFontSize / 2);
								scaleLabelY = this.top + ((this.bottom - this.top) / 2);
								var rotation = this.options.position === 'left' ? -0.5 * Math.PI : 0.5 * Math.PI;

								this.ctx.save();
								this.ctx.translate(scaleLabelX, scaleLabelY);
								this.ctx.rotate(rotation);
								this.ctx.textAlign = "center";
								this.ctx.fillStyle = scaleLabelFontColor; // render in correct colour
								this.ctx.font = scaleLabelFont;
								this.ctx.textBaseline = 'middle';
								this.ctx.fillText(this.options.scaleLabel.labelString, 0, 0);
								this.ctx.restore();
							}
						}

						// Draw the line at the edge of the axis
						this.ctx.lineWidth = this.options.gridLines.lineWidth;
						this.ctx.strokeStyle = this.options.gridLines.color;
						var x1 = this.left,
							x2 = this.right,
							y1 = this.top,
							y2 = this.bottom;

						if (this.isHorizontal()) {
							y1 = y2 = this.options.position === 'top' ? this.bottom : this.top;
							y1 += helpers.aliasPixel(this.ctx.lineWidth);
							y2 += helpers.aliasPixel(this.ctx.lineWidth);
						} else {
							x1 = x2 = this.options.position === 'left' ? this.right : this.left;
							x1 += helpers.aliasPixel(this.ctx.lineWidth);
							x2 += helpers.aliasPixel(this.ctx.lineWidth);
						}

						this.ctx.beginPath();
						this.ctx.moveTo(x1, y1);
						this.ctx.lineTo(x2, y2);
						this.ctx.stroke();
					}
				}
			});
		};

	}, {}], 31: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.scaleService = {
				// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
				// use the new chart options to grab the correct scale
				constructors: {},
				// Use a registration function so that we can move to an ES6 map when we no longer need to support
				// old browsers

				// Scale config defaults
				defaults: {},
				registerScaleType: function (type, scaleConstructor, defaults) {
					this.constructors[type] = scaleConstructor;
					this.defaults[type] = helpers.clone(defaults);
				},
				getScaleConstructor: function (type) {
					return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
				},
				getScaleDefaults: function (type) {
					// Return the scale defaults merged with the global settings so that we always use the latest ones
					return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};
				},
				updateScaleDefaults: function (type, additions) {
					var defaults = this.defaults;
					if (defaults.hasOwnProperty(type)) {
						defaults[type] = helpers.extend(defaults[type], additions);
					}
				},
				addScalesToLayout: function (chartInstance) {
					// Adds each scale to the chart.boxes array to be sized accordingly
					helpers.each(chartInstance.scales, function (scale) {
						Chart.layoutService.addBox(chartInstance, scale);
					});
				}
			};
		};
	}, {}], 32: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.global.title = {
				display: false,
				position: 'top',
				fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)

				fontStyle: 'bold',
				padding: 10,

				// actual title
				text: ''
			};

			var noop = helpers.noop;
			Chart.Title = Chart.Element.extend({

				initialize: function (config) {
					helpers.extend(this, config);
					this.options = helpers.configMerge(Chart.defaults.global.title, config.options);

					// Contains hit boxes for each dataset (in dataset order)
					this.legendHitBoxes = [];
				},

				// These methods are ordered by lifecyle. Utilities then follow.

				beforeUpdate: noop,
				update: function (maxWidth, maxHeight, margins) {

					// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
					this.beforeUpdate();

					// Absorb the master measurements
					this.maxWidth = maxWidth;
					this.maxHeight = maxHeight;
					this.margins = margins;

					// Dimensions
					this.beforeSetDimensions();
					this.setDimensions();
					this.afterSetDimensions();
					// Labels
					this.beforeBuildLabels();
					this.buildLabels();
					this.afterBuildLabels();

					// Fit
					this.beforeFit();
					this.fit();
					this.afterFit();
					//
					this.afterUpdate();

					return this.minSize;

				},
				afterUpdate: noop,

				//

				beforeSetDimensions: noop,
				setDimensions: function () {
					// Set the unconstrained dimension before label rotation
					if (this.isHorizontal()) {
						// Reset position before calculating rotation
						this.width = this.maxWidth;
						this.left = 0;
						this.right = this.width;
					} else {
						this.height = this.maxHeight;

						// Reset position before calculating rotation
						this.top = 0;
						this.bottom = this.height;
					}

					// Reset padding
					this.paddingLeft = 0;
					this.paddingTop = 0;
					this.paddingRight = 0;
					this.paddingBottom = 0;

					// Reset minSize
					this.minSize = {
						width: 0,
						height: 0
					};
				},
				afterSetDimensions: noop,

				//

				beforeBuildLabels: noop,
				buildLabels: noop,
				afterBuildLabels: noop,

				//

				beforeFit: noop,
				fit: function () {

					var ctx = this.ctx,
						valueOrDefault = helpers.getValueOrDefault,
						opts = this.options,
						globalDefaults = Chart.defaults.global,
						display = opts.display,
						fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
						minSize = this.minSize;

					if (this.isHorizontal()) {
						minSize.width = this.maxWidth; // fill all the width
						minSize.height = display ? fontSize + (opts.padding * 2) : 0;
					} else {
						minSize.width = display ? fontSize + (opts.padding * 2) : 0;
						minSize.height = this.maxHeight; // fill all the height
					}

					this.width = minSize.width;
					this.height = minSize.height;

				},
				afterFit: noop,

				// Shared Methods
				isHorizontal: function () {
					var pos = this.options.position;
					return pos === "top" || pos === "bottom";
				},

				// Actualy draw the title block on the canvas
				draw: function () {
					var ctx = this.ctx,
						valueOrDefault = helpers.getValueOrDefault,
						opts = this.options,
						globalDefaults = Chart.defaults.global;

					if (opts.display) {
						var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
							fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),
							fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),
							titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),
							rotation = 0,
							titleX,
							titleY;

						ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
						ctx.font = titleFont;

						// Horizontal
						if (this.isHorizontal()) {
							titleX = this.left + ((this.right - this.left) / 2); // midpoint of the width
							titleY = this.top + ((this.bottom - this.top) / 2); // midpoint of the height
						} else {
							titleX = opts.position === 'left' ? this.left + (fontSize / 2) : this.right - (fontSize / 2);
							titleY = this.top + ((this.bottom - this.top) / 2);
							rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
						}

						ctx.save();
						ctx.translate(titleX, titleY);
						ctx.rotate(rotation);
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						ctx.fillText(opts.text, 0, 0);
						ctx.restore();
					}
				}
			});
		};
	}, {}], 33: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.global.tooltips = {
				enabled: true,
				custom: null,
				mode: 'single',
				backgroundColor: "rgba(0,0,0,0.8)",
				titleFontStyle: "bold",
				titleSpacing: 2,
				titleMarginBottom: 6,
				titleColor: "#fff",
				titleAlign: "left",
				bodySpacing: 2,
				bodyColor: "#fff",
				bodyAlign: "left",
				footerFontStyle: "bold",
				footerSpacing: 2,
				footerMarginTop: 6,
				footerColor: "#fff",
				footerAlign: "left",
				yPadding: 6,
				xPadding: 6,
				yAlign: 'center',
				xAlign: 'center',
				caretSize: 5,
				cornerRadius: 6,
				multiKeyBackground: '#fff',
				callbacks: {
					// Args are: (tooltipItems, data)
					beforeTitle: helpers.noop,
					title: function (tooltipItems, data) {
						// Pick first xLabel for now
						var title = '';

						if (tooltipItems.length > 0) {
							if (tooltipItems[0].xLabel) {
								title = tooltipItems[0].xLabel;
							} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {
								title = data.labels[tooltipItems[0].index];
							}
						}

						return title;
					},
					afterTitle: helpers.noop,

					// Args are: (tooltipItems, data)
					beforeBody: helpers.noop,

					// Args are: (tooltipItem, data)
					beforeLabel: helpers.noop,
					label: function (tooltipItem, data) {
						var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
						return datasetLabel + ': ' + tooltipItem.yLabel;
					},
					afterLabel: helpers.noop,

					// Args are: (tooltipItems, data)
					afterBody: helpers.noop,

					// Args are: (tooltipItems, data)
					beforeFooter: helpers.noop,
					footer: helpers.noop,
					afterFooter: helpers.noop
				}
			};

			// Helper to push or concat based on if the 2nd parameter is an array or not
			function pushOrConcat(base, toPush) {
				if (toPush) {
					if (helpers.isArray(toPush)) {
						base = base.concat(toPush);
					} else {
						base.push(toPush);
					}
				}

				return base;
			}

			Chart.Tooltip = Chart.Element.extend({
				initialize: function () {
					var options = this._options;
					helpers.extend(this, {
						_model: {
							// Positioning
							xPadding: options.tooltips.xPadding,
							yPadding: options.tooltips.yPadding,
							xAlign: options.tooltips.yAlign,
							yAlign: options.tooltips.xAlign,

							// Body
							bodyColor: options.tooltips.bodyColor,
							_bodyFontFamily: helpers.getValueOrDefault(options.tooltips.bodyFontFamily, Chart.defaults.global.defaultFontFamily),
							_bodyFontStyle: helpers.getValueOrDefault(options.tooltips.bodyFontStyle, Chart.defaults.global.defaultFontStyle),
							_bodyAlign: options.tooltips.bodyAlign,
							bodyFontSize: helpers.getValueOrDefault(options.tooltips.bodyFontSize, Chart.defaults.global.defaultFontSize),
							bodySpacing: options.tooltips.bodySpacing,

							// Title
							titleColor: options.tooltips.titleColor,
							_titleFontFamily: helpers.getValueOrDefault(options.tooltips.titleFontFamily, Chart.defaults.global.defaultFontFamily),
							_titleFontStyle: helpers.getValueOrDefault(options.tooltips.titleFontStyle, Chart.defaults.global.defaultFontStyle),
							titleFontSize: helpers.getValueOrDefault(options.tooltips.titleFontSize, Chart.defaults.global.defaultFontSize),
							_titleAlign: options.tooltips.titleAlign,
							titleSpacing: options.tooltips.titleSpacing,
							titleMarginBottom: options.tooltips.titleMarginBottom,

							// Footer
							footerColor: options.tooltips.footerColor,
							_footerFontFamily: helpers.getValueOrDefault(options.tooltips.footerFontFamily, Chart.defaults.global.defaultFontFamily),
							_footerFontStyle: helpers.getValueOrDefault(options.tooltips.footerFontStyle, Chart.defaults.global.defaultFontStyle),
							footerFontSize: helpers.getValueOrDefault(options.tooltips.footerFontSize, Chart.defaults.global.defaultFontSize),
							_footerAlign: options.tooltips.footerAlign,
							footerSpacing: options.tooltips.footerSpacing,
							footerMarginTop: options.tooltips.footerMarginTop,

							// Appearance
							caretSize: options.tooltips.caretSize,
							cornerRadius: options.tooltips.cornerRadius,
							backgroundColor: options.tooltips.backgroundColor,
							opacity: 0,
							legendColorBackground: options.tooltips.multiKeyBackground
						}
					});
				},

				// Get the title
				// Args are: (tooltipItem, data)
				getTitle: function () {
					var beforeTitle = this._options.tooltips.callbacks.beforeTitle.apply(this, arguments),
						title = this._options.tooltips.callbacks.title.apply(this, arguments),
						afterTitle = this._options.tooltips.callbacks.afterTitle.apply(this, arguments);

					var lines = [];
					lines = pushOrConcat(lines, beforeTitle);
					lines = pushOrConcat(lines, title);
					lines = pushOrConcat(lines, afterTitle);

					return lines;
				},

				// Args are: (tooltipItem, data)
				getBeforeBody: function () {
					var lines = this._options.tooltips.callbacks.beforeBody.apply(this, arguments);
					return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
				},

				// Args are: (tooltipItem, data)
				getBody: function (tooltipItems, data) {
					var lines = [];

					helpers.each(tooltipItems, function (bodyItem) {
						helpers.pushAllIfDefined(this._options.tooltips.callbacks.beforeLabel.call(this, bodyItem, data), lines);
						helpers.pushAllIfDefined(this._options.tooltips.callbacks.label.call(this, bodyItem, data), lines);
						helpers.pushAllIfDefined(this._options.tooltips.callbacks.afterLabel.call(this, bodyItem, data), lines);
					}, this);

					return lines;
				},

				// Args are: (tooltipItem, data)
				getAfterBody: function () {
					var lines = this._options.tooltips.callbacks.afterBody.apply(this, arguments);
					return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
				},

				// Get the footer and beforeFooter and afterFooter lines
				// Args are: (tooltipItem, data)
				getFooter: function () {
					var beforeFooter = this._options.tooltips.callbacks.beforeFooter.apply(this, arguments);
					var footer = this._options.tooltips.callbacks.footer.apply(this, arguments);
					var afterFooter = this._options.tooltips.callbacks.afterFooter.apply(this, arguments);

					var lines = [];
					lines = pushOrConcat(lines, beforeFooter);
					lines = pushOrConcat(lines, footer);
					lines = pushOrConcat(lines, afterFooter);

					return lines;
				},

				getAveragePosition: function (elements) {

					if (!elements.length) {
						return false;
					}

					var xPositions = [];
					var yPositions = [];

					helpers.each(elements, function (el) {
						if (el) {
							var pos = el.tooltipPosition();
							xPositions.push(pos.x);
							yPositions.push(pos.y);
						}
					});

					var x = 0,
						y = 0;
					for (var i = 0; i < xPositions.length; i++) {
						x += xPositions[i];
						y += yPositions[i];
					}

					return {
						x: Math.round(x / xPositions.length),
						y: Math.round(y / xPositions.length)
					};

				},

				update: function (changed) {
					if (this._active.length) {
						this._model.opacity = 1;

						var element = this._active[0],
							labelColors = [],
							tooltipPosition;

						var tooltipItems = [];

						if (this._options.tooltips.mode === 'single') {
							var yScale = element._yScale || element._scale; // handle radar || polarArea charts
							tooltipItems.push({
								xLabel: element._xScale ? element._xScale.getLabelForIndex(element._index, element._datasetIndex) : '',
								yLabel: yScale ? yScale.getLabelForIndex(element._index, element._datasetIndex) : '',
								index: element._index,
								datasetIndex: element._datasetIndex
							});
							tooltipPosition = this.getAveragePosition(this._active);
						} else {
							helpers.each(this._data.datasets, function (dataset, datasetIndex) {
								if (!this._chartInstance.isDatasetVisible(datasetIndex)) {
									return;
								}

								var meta = this._chartInstance.getDatasetMeta(datasetIndex);
								var currentElement = meta.data[element._index];
								if (currentElement) {
									var yScale = element._yScale || element._scale; // handle radar || polarArea charts

									tooltipItems.push({
										xLabel: currentElement._xScale ? currentElement._xScale.getLabelForIndex(currentElement._index, currentElement._datasetIndex) : '',
										yLabel: yScale ? yScale.getLabelForIndex(currentElement._index, currentElement._datasetIndex) : '',
										index: element._index,
										datasetIndex: datasetIndex
									});
								}
							}, this);

							helpers.each(this._active, function (active) {
								if (active) {
									labelColors.push({
										borderColor: active._view.borderColor,
										backgroundColor: active._view.backgroundColor
									});
								}
							}, null);

							tooltipPosition = this.getAveragePosition(this._active);
						}

						// Build the Text Lines
						helpers.extend(this._model, {
							title: this.getTitle(tooltipItems, this._data),
							beforeBody: this.getBeforeBody(tooltipItems, this._data),
							body: this.getBody(tooltipItems, this._data),
							afterBody: this.getAfterBody(tooltipItems, this._data),
							footer: this.getFooter(tooltipItems, this._data)
						});

						helpers.extend(this._model, {
							x: Math.round(tooltipPosition.x),
							y: Math.round(tooltipPosition.y),
							caretPadding: helpers.getValueOrDefault(tooltipPosition.padding, 2),
							labelColors: labelColors
						});

						// We need to determine alignment of
						var tooltipSize = this.getTooltipSize(this._model);
						this.determineAlignment(tooltipSize); // Smart Tooltip placement to stay on the canvas

						helpers.extend(this._model, this.getBackgroundPoint(this._model, tooltipSize));
					} else {
						this._model.opacity = 0;
					}

					if (changed && this._options.tooltips.custom) {
						this._options.tooltips.custom.call(this, this._model);
					}

					return this;
				},
				getTooltipSize: function getTooltipSize(vm) {
					var ctx = this._chart.ctx;

					var size = {
						height: vm.yPadding * 2, // Tooltip Padding
						width: 0
					};
					var combinedBodyLength = vm.body.length + vm.beforeBody.length + vm.afterBody.length;

					size.height += vm.title.length * vm.titleFontSize; // Title Lines
					size.height += (vm.title.length - 1) * vm.titleSpacing; // Title Line Spacing
					size.height += vm.title.length ? vm.titleMarginBottom : 0; // Title's bottom Margin
					size.height += combinedBodyLength * vm.bodyFontSize; // Body Lines
					size.height += combinedBodyLength ? (combinedBodyLength - 1) * vm.bodySpacing : 0; // Body Line Spacing
					size.height += vm.footer.length ? vm.footerMarginTop : 0; // Footer Margin
					size.height += vm.footer.length * (vm.footerFontSize); // Footer Lines
					size.height += vm.footer.length ? (vm.footer.length - 1) * vm.footerSpacing : 0; // Footer Line Spacing

					// Width
					ctx.font = helpers.fontString(vm.titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
					helpers.each(vm.title, function (line) {
						size.width = Math.max(size.width, ctx.measureText(line).width);
					});

					ctx.font = helpers.fontString(vm.bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
					helpers.each(vm.beforeBody.concat(vm.afterBody), function (line) {
						size.width = Math.max(size.width, ctx.measureText(line).width);
					});
					helpers.each(vm.body, function (line) {
						size.width = Math.max(size.width, ctx.measureText(line).width + (this._options.tooltips.mode !== 'single' ? (vm.bodyFontSize + 2) : 0));
					}, this);

					ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
					helpers.each(vm.footer, function (line) {
						size.width = Math.max(size.width, ctx.measureText(line).width);
					});
					size.width += 2 * vm.xPadding;

					return size;
				},
				determineAlignment: function determineAlignment(size) {
					if (this._model.y < size.height) {
						this._model.yAlign = 'top';
					} else if (this._model.y > (this._chart.height - size.height)) {
						this._model.yAlign = 'bottom';
					}

					var lf, rf; // functions to determine left, right alignment
					var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
					var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
					var _this = this;
					var midX = (this._chartInstance.chartArea.left + this._chartInstance.chartArea.right) / 2;
					var midY = (this._chartInstance.chartArea.top + this._chartInstance.chartArea.bottom) / 2;

					if (this._model.yAlign === 'center') {
						lf = function (x) {
							return x <= midX;
						};
						rf = function (x) {
							return x > midX;
						};
					} else {
						lf = function (x) {
							return x <= (size.width / 2);
						};
						rf = function (x) {
							return x >= (_this._chart.width - (size.width / 2));
						};
					}

					olf = function (x) {
						return x + size.width > _this._chart.width;
					};
					orf = function (x) {
						return x - size.width < 0;
					};
					yf = function (y) {
						return y <= midY ? 'top' : 'bottom';
					};

					if (lf(this._model.x)) {
						this._model.xAlign = 'left';

						// Is tooltip too wide and goes over the right side of the chart.?
						if (olf(this._model.x)) {
							this._model.xAlign = 'center';
							this._model.yAlign = yf(this._model.y);
						}
					} else if (rf(this._model.x)) {
						this._model.xAlign = 'right';

						// Is tooltip too wide and goes outside left edge of canvas?
						if (orf(this._model.x)) {
							this._model.xAlign = 'center';
							this._model.yAlign = yf(this._model.y);
						}
					}
				},
				getBackgroundPoint: function getBackgroundPoint(vm, size) {
					// Background Position
					var pt = {
						x: vm.x,
						y: vm.y
					};

					if (vm.xAlign === 'right') {
						pt.x -= size.width;
					} else if (vm.xAlign === 'center') {
						pt.x -= (size.width / 2);
					}

					if (vm.yAlign === 'top') {
						pt.y += vm.caretPadding + vm.caretSize;
					} else if (vm.yAlign === 'bottom') {
						pt.y -= size.height + vm.caretPadding + vm.caretSize;
					} else {
						pt.y -= (size.height / 2);
					}

					if (vm.yAlign === 'center') {
						if (vm.xAlign === 'left') {
							pt.x += vm.caretPadding + vm.caretSize;
						} else if (vm.xAlign === 'right') {
							pt.x -= vm.caretPadding + vm.caretSize;
						}
					} else {
						if (vm.xAlign === 'left') {
							pt.x -= vm.cornerRadius + vm.caretPadding;
						} else if (vm.xAlign === 'right') {
							pt.x += vm.cornerRadius + vm.caretPadding;
						}
					}

					return pt;
				},
				drawCaret: function drawCaret(tooltipPoint, size, opacity, caretPadding) {
					var vm = this._view;
					var ctx = this._chart.ctx;
					var x1, x2, x3;
					var y1, y2, y3;

					if (vm.yAlign === 'center') {
						// Left or right side
						if (vm.xAlign === 'left') {
							x1 = tooltipPoint.x;
							x2 = x1 - vm.caretSize;
							x3 = x1;
						} else {
							x1 = tooltipPoint.x + size.width;
							x2 = x1 + vm.caretSize;
							x3 = x1;
						}

						y2 = tooltipPoint.y + (size.height / 2);
						y1 = y2 - vm.caretSize;
						y3 = y2 + vm.caretSize;
					} else {
						if (vm.xAlign === 'left') {
							x1 = tooltipPoint.x + vm.cornerRadius;
							x2 = x1 + vm.caretSize;
							x3 = x2 + vm.caretSize;
						} else if (vm.xAlign === 'right') {
							x1 = tooltipPoint.x + size.width - vm.cornerRadius;
							x2 = x1 - vm.caretSize;
							x3 = x2 - vm.caretSize;
						} else {
							x2 = tooltipPoint.x + (size.width / 2);
							x1 = x2 - vm.caretSize;
							x3 = x2 + vm.caretSize;
						}

						if (vm.yAlign === 'top') {
							y1 = tooltipPoint.y;
							y2 = y1 - vm.caretSize;
							y3 = y1;
						} else {
							y1 = tooltipPoint.y + size.height;
							y2 = y1 + vm.caretSize;
							y3 = y1;
						}
					}

					var bgColor = helpers.color(vm.backgroundColor);
					ctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();
					ctx.beginPath();
					ctx.moveTo(x1, y1);
					ctx.lineTo(x2, y2);
					ctx.lineTo(x3, y3);
					ctx.closePath();
					ctx.fill();
				},
				drawTitle: function drawTitle(pt, vm, ctx, opacity) {
					if (vm.title.length) {
						ctx.textAlign = vm._titleAlign;
						ctx.textBaseline = "top";

						var titleColor = helpers.color(vm.titleColor);
						ctx.fillStyle = titleColor.alpha(opacity * titleColor.alpha()).rgbString();
						ctx.font = helpers.fontString(vm.titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

						helpers.each(vm.title, function (title, i) {
							ctx.fillText(title, pt.x, pt.y);
							pt.y += vm.titleFontSize + vm.titleSpacing; // Line Height and spacing

							if (i + 1 === vm.title.length) {
								pt.y += vm.titleMarginBottom - vm.titleSpacing; // If Last, add margin, remove spacing
							}
						});
					}
				},
				drawBody: function drawBody(pt, vm, ctx, opacity) {
					ctx.textAlign = vm._bodyAlign;
					ctx.textBaseline = "top";

					var bodyColor = helpers.color(vm.bodyColor);
					ctx.fillStyle = bodyColor.alpha(opacity * bodyColor.alpha()).rgbString();
					ctx.font = helpers.fontString(vm.bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

					// Before Body
					helpers.each(vm.beforeBody, function (beforeBody) {
						ctx.fillText(beforeBody, pt.x, pt.y);
						pt.y += vm.bodyFontSize + vm.bodySpacing;
					});

					helpers.each(vm.body, function (body, i) {
						// Draw Legend-like boxes if needed
						if (this._options.tooltips.mode !== 'single') {
							// Fill a white rect so that colours merge nicely if the opacity is < 1
							ctx.fillStyle = helpers.color(vm.legendColorBackground).alpha(opacity).rgbaString();
							ctx.fillRect(pt.x, pt.y, vm.bodyFontSize, vm.bodyFontSize);

							// Border
							ctx.strokeStyle = helpers.color(vm.labelColors[i].borderColor).alpha(opacity).rgbaString();
							ctx.strokeRect(pt.x, pt.y, vm.bodyFontSize, vm.bodyFontSize);

							// Inner square
							ctx.fillStyle = helpers.color(vm.labelColors[i].backgroundColor).alpha(opacity).rgbaString();
							ctx.fillRect(pt.x + 1, pt.y + 1, vm.bodyFontSize - 2, vm.bodyFontSize - 2);

							ctx.fillStyle = helpers.color(vm.bodyColor).alpha(opacity).rgbaString(); // Return fill style for text
						}

						// Body Line
						ctx.fillText(body, pt.x + (this._options.tooltips.mode !== 'single' ? (vm.bodyFontSize + 2) : 0), pt.y);

						pt.y += vm.bodyFontSize + vm.bodySpacing;
					}, this);

					// After Body
					helpers.each(vm.afterBody, function (afterBody) {
						ctx.fillText(afterBody, pt.x, pt.y);
						pt.y += vm.bodyFontSize;
					});

					pt.y -= vm.bodySpacing; // Remove last body spacing
				},
				drawFooter: function drawFooter(pt, vm, ctx, opacity) {
					if (vm.footer.length) {
						pt.y += vm.footerMarginTop;

						ctx.textAlign = vm._footerAlign;
						ctx.textBaseline = "top";

						var footerColor = helpers.color(vm.footerColor);
						ctx.fillStyle = footerColor.alpha(opacity * footerColor.alpha()).rgbString();
						ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

						helpers.each(vm.footer, function (footer) {
							ctx.fillText(footer, pt.x, pt.y);
							pt.y += vm.footerFontSize + vm.footerSpacing;
						});
					}
				},
				draw: function draw() {
					var ctx = this._chart.ctx;
					var vm = this._view;

					if (vm.opacity === 0) {
						return;
					}

					var caretPadding = vm.caretPadding;
					var tooltipSize = this.getTooltipSize(vm);
					var pt = {
						x: vm.x,
						y: vm.y
					};

					// IE11/Edge does not like very small opacities, so snap to 0
					var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

					if (this._options.tooltips.enabled) {
						// Draw Background
						var bgColor = helpers.color(vm.backgroundColor);
						ctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();
						helpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);
						ctx.fill();

						// Draw Caret
						this.drawCaret(pt, tooltipSize, opacity, caretPadding);

						// Draw Title, Body, and Footer
						pt.x += vm.xPadding;
						pt.y += vm.yPadding;

						// Titles
						this.drawTitle(pt, vm, ctx, opacity);

						// Body
						this.drawBody(pt, vm, ctx, opacity);

						// Footer
						this.drawFooter(pt, vm, ctx, opacity);
					}
				}
			});
		};

	}, {}], 34: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart, moment) {

			var helpers = Chart.helpers,
				globalOpts = Chart.defaults.global;

			globalOpts.elements.arc = {
				backgroundColor: globalOpts.defaultColor,
				borderColor: "#fff",
				borderWidth: 2
			};

			Chart.elements.Arc = Chart.Element.extend({
				inLabelRange: function (mouseX) {
					var vm = this._view;

					if (vm) {
						return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
					} else {
						return false;
					}
				},
				inRange: function (chartX, chartY) {
					var vm = this._view;

					if (vm) {
						var pointRelativePosition = helpers.getAngleFromPoint(vm, {
							x: chartX,
							y: chartY
						}),
							angle = pointRelativePosition.angle,
							distance = pointRelativePosition.distance;

						//Sanitise angle range
						var startAngle = vm.startAngle;
						var endAngle = vm.endAngle;
						while (endAngle < startAngle) {
							endAngle += 2.0 * Math.PI;
						}
						while (angle > endAngle) {
							angle -= 2.0 * Math.PI;
						}
						while (angle < startAngle) {
							angle += 2.0 * Math.PI;
						}

						//Check if within the range of the open/close angle
						var betweenAngles = (angle >= startAngle && angle <= endAngle),
							withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

						return (betweenAngles && withinRadius);
					} else {
						return false;
					}
				},
				tooltipPosition: function () {
					var vm = this._view;

					var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),
						rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
					return {
						x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
						y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
					};
				},
				draw: function () {

					var ctx = this._chart.ctx,
						vm = this._view,
						sA = vm.startAngle,
						eA = vm.endAngle;

					ctx.beginPath();

					ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
					ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

					ctx.closePath();
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = vm.borderWidth;

					ctx.fillStyle = vm.backgroundColor;

					ctx.fill();
					ctx.lineJoin = 'bevel';

					if (vm.borderWidth) {
						ctx.stroke();
					}
				}
			});
		};

	}, {}], 35: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			Chart.defaults.global.elements.line = {
				tension: 0.4,
				backgroundColor: Chart.defaults.global.defaultColor,
				borderWidth: 3,
				borderColor: Chart.defaults.global.defaultColor,
				borderCapStyle: 'butt',
				borderDash: [],
				borderDashOffset: 0.0,
				borderJoinStyle: 'miter',
				fill: true // do we fill in the area between the line and its base axis
			};

			Chart.elements.Line = Chart.Element.extend({
				lineToNextPoint: function (previousPoint, point, nextPoint, skipHandler, previousSkipHandler) {
					var ctx = this._chart.ctx;

					if (point._view.skip) {
						skipHandler.call(this, previousPoint, point, nextPoint);
					} else if (previousPoint._view.skip) {
						previousSkipHandler.call(this, previousPoint, point, nextPoint);
					} else if (point._view.tension === 0) {
						ctx.lineTo(point._view.x, point._view.y);
					} else {
						// Line between points
						ctx.bezierCurveTo(
							previousPoint._view.controlPointNextX,
							previousPoint._view.controlPointNextY,
							point._view.controlPointPreviousX,
							point._view.controlPointPreviousY,
							point._view.x,
							point._view.y
						);
					}
				},

				draw: function () {
					var _this = this;

					var vm = this._view;
					var ctx = this._chart.ctx;
					var first = this._children[0];
					var last = this._children[this._children.length - 1];

					function loopBackToStart(drawLineToCenter) {
						if (!first._view.skip && !last._view.skip) {
							// Draw a bezier line from last to first
							ctx.bezierCurveTo(
								last._view.controlPointNextX,
								last._view.controlPointNextY,
								first._view.controlPointPreviousX,
								first._view.controlPointPreviousY,
								first._view.x,
								first._view.y
							);
						} else if (drawLineToCenter) {
							// Go to center
							ctx.lineTo(_this._view.scaleZero.x, _this._view.scaleZero.y);
						}
					}

					ctx.save();

					// If we had points and want to fill this line, do so.
					if (this._children.length > 0 && vm.fill) {
						// Draw the background first (so the border is always on top)
						ctx.beginPath();

						helpers.each(this._children, function (point, index) {
							var previous = helpers.previousItem(this._children, index);
							var next = helpers.nextItem(this._children, index);

							// First point moves to it's starting position no matter what
							if (index === 0) {
								if (this._loop) {
									ctx.moveTo(vm.scaleZero.x, vm.scaleZero.y);
								} else {
									ctx.moveTo(point._view.x, vm.scaleZero);
								}

								if (point._view.skip) {
									if (!this._loop) {
										ctx.moveTo(next._view.x, this._view.scaleZero);
									}
								} else {
									ctx.lineTo(point._view.x, point._view.y);
								}
							} else {
								this.lineToNextPoint(previous, point, next, function (previousPoint, point, nextPoint) {
									if (this._loop) {
										// Go to center
										ctx.lineTo(this._view.scaleZero.x, this._view.scaleZero.y);
									} else {
										ctx.lineTo(previousPoint._view.x, this._view.scaleZero);
										ctx.moveTo(nextPoint._view.x, this._view.scaleZero);
									}
								}, function (previousPoint, point) {
									// If we skipped the last point, draw a line to ourselves so that the fill is nice
									ctx.lineTo(point._view.x, point._view.y);
								});
							}
						}, this);

						// For radial scales, loop back around to the first point
						if (this._loop) {
							loopBackToStart(true);
						} else {
							//Round off the line by going to the base of the chart, back to the start, then fill.
							ctx.lineTo(this._children[this._children.length - 1]._view.x, vm.scaleZero);
							ctx.lineTo(this._children[0]._view.x, vm.scaleZero);
						}

						ctx.fillStyle = vm.backgroundColor || Chart.defaults.global.defaultColor;
						ctx.closePath();
						ctx.fill();
					}

					// Now draw the line between all the points with any borders
					ctx.lineCap = vm.borderCapStyle || Chart.defaults.global.elements.line.borderCapStyle;

					// IE 9 and 10 do not support line dash
					if (ctx.setLineDash) {
						ctx.setLineDash(vm.borderDash || Chart.defaults.global.elements.line.borderDash);
					}

					ctx.lineDashOffset = vm.borderDashOffset || Chart.defaults.global.elements.line.borderDashOffset;
					ctx.lineJoin = vm.borderJoinStyle || Chart.defaults.global.elements.line.borderJoinStyle;
					ctx.lineWidth = vm.borderWidth || Chart.defaults.global.elements.line.borderWidth;
					ctx.strokeStyle = vm.borderColor || Chart.defaults.global.defaultColor;
					ctx.beginPath();

					helpers.each(this._children, function (point, index) {
						var previous = helpers.previousItem(this._children, index);
						var next = helpers.nextItem(this._children, index);

						if (index === 0) {
							ctx.moveTo(point._view.x, point._view.y);
						} else {
							this.lineToNextPoint(previous, point, next, function (previousPoint, point, nextPoint) {
								ctx.moveTo(nextPoint._view.x, nextPoint._view.y);
							}, function (previousPoint, point) {
								// If we skipped the last point, move up to our point preventing a line from being drawn
								ctx.moveTo(point._view.x, point._view.y);
							});
						}
					}, this);

					if (this._loop && this._children.length > 0) {
						loopBackToStart();
					}

					ctx.stroke();
					ctx.restore();
				}
			});
		};
	}, {}], 36: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers,
				globalOpts = Chart.defaults.global;

			globalOpts.elements.point = {
				radius: 3,
				pointStyle: 'circle',
				backgroundColor: globalOpts.defaultColor,
				borderWidth: 1,
				borderColor: globalOpts.defaultColor,
				// Hover
				hitRadius: 1,
				hoverRadius: 4,
				hoverBorderWidth: 1
			};


			Chart.elements.Point = Chart.Element.extend({
				inRange: function (mouseX, mouseY) {
					var vm = this._view;
					return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
				},
				inLabelRange: function (mouseX) {
					var vm = this._view;
					return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
				},
				tooltipPosition: function () {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y,
						padding: vm.radius + vm.borderWidth
					};
				},
				draw: function () {
					var vm = this._view,
						x = vm.x,
						y = vm.y;
					var ctx = this._chart.ctx;

					if (vm.skip) {
						return;
					}

					var pointStyle = vm.pointStyle;
					if (typeof pointStyle === 'object' && ((pointStyle.toString() === '[object HTMLImageElement]') || (pointStyle.toString() === '[object HTMLCanvasElement]'))) {
						ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);
						return;
					}

					if (!isNaN(vm.radius) && vm.radius > 0) {

						ctx.strokeStyle = vm.borderColor || Chart.defaults.global.defaultColor;
						ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, Chart.defaults.global.elements.point.borderWidth);

						ctx.fillStyle = vm.backgroundColor || Chart.defaults.global.defaultColor;

						var radius = vm.radius;

						var xOffset,
							yOffset;

						switch (pointStyle) {
							// Default includes circle
							default:
								ctx.beginPath();
								ctx.arc(x, y, radius, 0, Math.PI * 2);
								ctx.closePath();
								ctx.fill();
								break;
							case 'triangle':
								ctx.beginPath();
								var edgeLength = 3 * radius / Math.sqrt(3);
								var height = edgeLength * Math.sqrt(3) / 2;
								ctx.moveTo(x - edgeLength / 2, y + height / 3);
								ctx.lineTo(x + edgeLength / 2, y + height / 3);
								ctx.lineTo(x, y - 2 * height / 3);
								ctx.closePath();
								ctx.fill();
								break;
							case 'rect':
								ctx.fillRect(x - 1 / Math.SQRT2 * radius, y - 1 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius);
								ctx.strokeRect(x - 1 / Math.SQRT2 * radius, y - 1 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius);
								break;
							case 'rectRot':
								ctx.translate(x, y);
								ctx.rotate(Math.PI / 4);
								ctx.fillRect(-1 / Math.SQRT2 * radius, -1 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius);
								ctx.strokeRect(-1 / Math.SQRT2 * radius, -1 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius, 2 / Math.SQRT2 * radius);
								ctx.setTransform(1, 0, 0, 1, 0, 0);
								break;
							case 'cross':
								ctx.beginPath();
								ctx.moveTo(x, y + radius);
								ctx.lineTo(x, y - radius);
								ctx.moveTo(x - radius, y);
								ctx.lineTo(x + radius, y);
								ctx.closePath();
								break;
							case 'crossRot':
								ctx.beginPath();
								xOffset = Math.cos(Math.PI / 4) * radius;
								yOffset = Math.sin(Math.PI / 4) * radius;
								ctx.moveTo(x - xOffset, y - yOffset);
								ctx.lineTo(x + xOffset, y + yOffset);
								ctx.moveTo(x - xOffset, y + yOffset);
								ctx.lineTo(x + xOffset, y - yOffset);
								ctx.closePath();
								break;
							case 'star':
								ctx.beginPath();
								ctx.moveTo(x, y + radius);
								ctx.lineTo(x, y - radius);
								ctx.moveTo(x - radius, y);
								ctx.lineTo(x + radius, y);
								xOffset = Math.cos(Math.PI / 4) * radius;
								yOffset = Math.sin(Math.PI / 4) * radius;
								ctx.moveTo(x - xOffset, y - yOffset);
								ctx.lineTo(x + xOffset, y + yOffset);
								ctx.moveTo(x - xOffset, y + yOffset);
								ctx.lineTo(x + xOffset, y - yOffset);
								ctx.closePath();
								break;
							case 'line':
								ctx.beginPath();
								ctx.moveTo(x - radius, y);
								ctx.lineTo(x + radius, y);
								ctx.closePath();
								break;
							case 'dash':
								ctx.beginPath();
								ctx.moveTo(x, y);
								ctx.lineTo(x + radius, y);
								ctx.closePath();
								break;
						}

						ctx.stroke();
					}
				}
			});
		};
	}, {}], 37: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers,
				globalOpts = Chart.defaults.global;

			globalOpts.elements.rectangle = {
				backgroundColor: globalOpts.defaultColor,
				borderWidth: 0,
				borderColor: globalOpts.defaultColor,
				borderSkipped: 'bottom'
			};

			Chart.elements.Rectangle = Chart.Element.extend({
				draw: function () {
					var ctx = this._chart.ctx;
					var vm = this._view;

					var halfWidth = vm.width / 2,
						leftX = vm.x - halfWidth,
						rightX = vm.x + halfWidth,
						top = vm.base - (vm.base - vm.y),
						halfStroke = vm.borderWidth / 2;

					// Canvas doesn't allow us to stroke inside the width so we can
					// adjust the sizes to fit if we're setting a stroke on the line
					if (vm.borderWidth) {
						leftX += halfStroke;
						rightX -= halfStroke;
						top += halfStroke;
					}

					ctx.beginPath();
					ctx.fillStyle = vm.backgroundColor;
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = vm.borderWidth;

					// Corner points, from bottom-left to bottom-right clockwise
					// | 1 2 |
					// | 0 3 |
					var corners = [
						[leftX, vm.base],
						[leftX, top],
						[rightX, top],
						[rightX, vm.base]
					];

					// Find first (starting) corner with fallback to 'bottom' 
					var borders = ['bottom', 'left', 'top', 'right'];
					var startCorner = borders.indexOf(vm.borderSkipped, 0);
					if (startCorner === -1)
						startCorner = 0;

					function cornerAt(index) {
						return corners[(startCorner + index) % 4];
					}

					// Draw rectangle from 'startCorner'
					ctx.moveTo.apply(ctx, cornerAt(0));
					for (var i = 1; i < 4; i++)
						ctx.lineTo.apply(ctx, cornerAt(i));

					ctx.fill();
					if (vm.borderWidth) {
						ctx.stroke();
					}
				},
				height: function () {
					var vm = this._view;
					return vm.base - vm.y;
				},
				inRange: function (mouseX, mouseY) {
					var vm = this._view;
					return vm ?
						(vm.y < vm.base ?
							(mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) && (mouseY >= vm.y && mouseY <= vm.base) :
							(mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) && (mouseY >= vm.base && mouseY <= vm.y)) :
						false;
				},
				inLabelRange: function (mouseX) {
					var vm = this._view;
					return vm ? (mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) : false;
				},
				tooltipPosition: function () {
					var vm = this._view;
					return {
						x: vm.x,
						y: vm.y
					};
				}
			});

		};
	}, {}], 38: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;
			// Default config for a category scale
			var defaultConfig = {
				position: "bottom"
			};

			var DatasetScale = Chart.Scale.extend({
				// Implement this so that 
				determineDataLimits: function () {
					this.minIndex = 0;
					this.maxIndex = this.chart.data.labels.length - 1;
					var findIndex;

					if (this.options.ticks.min !== undefined) {
						// user specified min value
						findIndex = helpers.indexOf(this.chart.data.labels, this.options.ticks.min);
						this.minIndex = findIndex !== -1 ? findIndex : this.minIndex;
					}

					if (this.options.ticks.max !== undefined) {
						// user specified max value
						findIndex = helpers.indexOf(this.chart.data.labels, this.options.ticks.max);
						this.maxIndex = findIndex !== -1 ? findIndex : this.maxIndex;
					}

					this.min = this.chart.data.labels[this.minIndex];
					this.max = this.chart.data.labels[this.maxIndex];
				},

				buildTicks: function (index) {
					// If we are viewing some subset of labels, slice the original array
					this.ticks = (this.minIndex === 0 && this.maxIndex === this.chart.data.labels.length - 1) ? this.chart.data.labels : this.chart.data.labels.slice(this.minIndex, this.maxIndex + 1);
				},

				getLabelForIndex: function (index, datasetIndex) {
					return this.ticks[index];
				},

				// Used to get data value locations.  Value can either be an index or a numerical value
				getPixelForValue: function (value, index, datasetIndex, includeOffset) {
					// 1 is added because we need the length but we have the indexes
					var offsetAmt = Math.max((this.maxIndex + 1 - this.minIndex - ((this.options.gridLines.offsetGridLines) ? 0 : 1)), 1);

					if (this.isHorizontal()) {
						var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
						var valueWidth = innerWidth / offsetAmt;
						var widthOffset = (valueWidth * (index - this.minIndex)) + this.paddingLeft;

						if (this.options.gridLines.offsetGridLines && includeOffset) {
							widthOffset += (valueWidth / 2);
						}

						return this.left + Math.round(widthOffset);
					} else {
						var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
						var valueHeight = innerHeight / offsetAmt;
						var heightOffset = (valueHeight * (index - this.minIndex)) + this.paddingTop;

						if (this.options.gridLines.offsetGridLines && includeOffset) {
							heightOffset += (valueHeight / 2);
						}

						return this.top + Math.round(heightOffset);
					}
				},
				getPixelForTick: function (index, includeOffset) {
					return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);
				},
				getValueForPixel: function (pixel) {
					var value
						; var offsetAmt = Math.max((this.ticks.length - ((this.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
					var horz = this.isHorizontal();
					var innerDimension = horz ? this.width - (this.paddingLeft + this.paddingRight) : this.height - (this.paddingTop + this.paddingBottom);
					var valueDimension = innerDimension / offsetAmt;

					if (this.options.gridLines.offsetGridLines) {
						pixel -= (valueDimension / 2);
					}
					pixel -= horz ? this.paddingLeft : this.paddingTop;

					if (pixel <= 0) {
						value = 0;
					} else {
						value = Math.round(pixel / valueDimension);
					}

					return value;
				}
			});

			Chart.scaleService.registerScaleType("category", DatasetScale, defaultConfig);

		};
	}, {}], 39: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			var defaultConfig = {
				position: "left",
				ticks: {
					callback: function (tickValue, index, ticks) {
						// If we have lots of ticks, don't use the ones
						var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

						// If we have a number like 2.5 as the delta, figure out how many decimal places we need
						if (Math.abs(delta) > 1) {
							if (tickValue !== Math.floor(tickValue)) {
								// not an integer
								delta = tickValue - Math.floor(tickValue);
							}
						}

						var logDelta = helpers.log10(Math.abs(delta));
						var tickString = '';

						if (tickValue !== 0) {
							var numDecimal = -1 * Math.floor(logDelta);
							numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
							tickString = tickValue.toFixed(numDecimal);
						} else {
							tickString = '0'; // never show decimal places for 0
						}

						return tickString;
					}
				}
			};

			var LinearScale = Chart.Scale.extend({
				determineDataLimits: function () {
					// First Calculate the range
					this.min = null;
					this.max = null;

					if (this.options.stacked) {
						var valuesPerType = {};
						var hasPositiveValues = false;
						var hasNegativeValues = false;

						helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
							var meta = this.chart.getDatasetMeta(datasetIndex);
							if (valuesPerType[meta.type] === undefined) {
								valuesPerType[meta.type] = {
									positiveValues: [],
									negativeValues: []
								};
							}

							// Store these per type
							var positiveValues = valuesPerType[meta.type].positiveValues;
							var negativeValues = valuesPerType[meta.type].negativeValues;

							if (this.chart.isDatasetVisible(datasetIndex) && (this.isHorizontal() ? meta.xAxisID === this.id : meta.yAxisID === this.id)) {
								helpers.each(dataset.data, function (rawValue, index) {
									var value = +this.getRightValue(rawValue);
									if (isNaN(value) || meta.data[index].hidden) {
										return;
									}

									positiveValues[index] = positiveValues[index] || 0;
									negativeValues[index] = negativeValues[index] || 0;

									if (this.options.relativePoints) {
										positiveValues[index] = 100;
									} else {
										if (value < 0) {
											hasNegativeValues = true;
											negativeValues[index] += value;
										} else {
											hasPositiveValues = true;
											positiveValues[index] += value;
										}
									}
								}, this);
							}
						}, this);

						helpers.each(valuesPerType, function (valuesForType) {
							var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
							var minVal = helpers.min(values);
							var maxVal = helpers.max(values);
							this.min = this.min === null ? minVal : Math.min(this.min, minVal);
							this.max = this.max === null ? maxVal : Math.max(this.max, maxVal);
						}, this);

					} else {
						helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
							var meta = this.chart.getDatasetMeta(datasetIndex);
							if (this.chart.isDatasetVisible(datasetIndex) && (this.isHorizontal() ? meta.xAxisID === this.id : meta.yAxisID === this.id)) {
								helpers.each(dataset.data, function (rawValue, index) {
									var value = +this.getRightValue(rawValue);
									if (isNaN(value) || meta.data[index].hidden) {
										return;
									}

									if (this.min === null) {
										this.min = value;
									} else if (value < this.min) {
										this.min = value;
									}

									if (this.max === null) {
										this.max = value;
									} else if (value > this.max) {
										this.max = value;
									}
								}, this);
							}
						}, this);
					}

					// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
					// do nothing since that would make the chart weird. If the user really wants a weird chart
					// axis, they can manually override it
					if (this.options.ticks.beginAtZero) {
						var minSign = helpers.sign(this.min);
						var maxSign = helpers.sign(this.max);

						if (minSign < 0 && maxSign < 0) {
							// move the top up to 0
							this.max = 0;
						} else if (minSign > 0 && maxSign > 0) {
							// move the botttom down to 0
							this.min = 0;
						}
					}

					if (this.options.ticks.min !== undefined) {
						this.min = this.options.ticks.min;
					} else if (this.options.ticks.suggestedMin !== undefined) {
						this.min = Math.min(this.min, this.options.ticks.suggestedMin);
					}

					if (this.options.ticks.max !== undefined) {
						this.max = this.options.ticks.max;
					} else if (this.options.ticks.suggestedMax !== undefined) {
						this.max = Math.max(this.max, this.options.ticks.suggestedMax);
					}

					if (this.min === this.max) {
						this.max++;

						if (!this.options.ticks.beginAtZero) {
							this.min--;
						}
					}
				},
				buildTicks: function () {

					// Then calulate the ticks
					this.ticks = [];

					// Figure out what the max number of ticks we can support it is based on the size of
					// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
					// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
					// the graph

					var maxTicks;

					if (this.isHorizontal()) {
						maxTicks = Math.min(this.options.ticks.maxTicksLimit ? this.options.ticks.maxTicksLimit : 11, Math.ceil(this.width / 50));
					} else {
						// The factor of 2 used to scale the font size has been experimentally determined.
						var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
						maxTicks = Math.min(this.options.ticks.maxTicksLimit ? this.options.ticks.maxTicksLimit : 11, Math.ceil(this.height / (2 * tickFontSize)));
					}

					// Make sure we always have at least 2 ticks
					maxTicks = Math.max(2, maxTicks);

					// To get a "nice" value for the tick spacing, we will use the appropriately named
					// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
					// for details.

					var spacing;
					var fixedStepSizeSet = (this.options.ticks.fixedStepSize && this.options.ticks.fixedStepSize > 0) || (this.options.ticks.stepSize && this.options.ticks.stepSize > 0);
					if (fixedStepSizeSet) {
						spacing = helpers.getValueOrDefault(this.options.ticks.fixedStepSize, this.options.ticks.stepSize);
					} else {
						var niceRange = helpers.niceNum(this.max - this.min, false);
						spacing = helpers.niceNum(niceRange / (maxTicks - 1), true);
					}
					var niceMin = Math.floor(this.min / spacing) * spacing;
					var niceMax = Math.ceil(this.max / spacing) * spacing;
					var numSpaces = (niceMax - niceMin) / spacing;

					// If very close to our rounded value, use it.
					if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
						numSpaces = Math.round(numSpaces);
					} else {
						numSpaces = Math.ceil(numSpaces);
					}

					// Put the values into the ticks array
					this.ticks.push(this.options.ticks.min !== undefined ? this.options.ticks.min : niceMin);
					for (var j = 1; j < numSpaces; ++j) {
						this.ticks.push(niceMin + (j * spacing));
					}
					this.ticks.push(this.options.ticks.max !== undefined ? this.options.ticks.max : niceMax);

					if (this.options.position === "left" || this.options.position === "right") {
						// We are in a vertical orientation. The top value is the highest. So reverse the array
						this.ticks.reverse();
					}

					// At this point, we need to update our max and min given the tick values since we have expanded the
					// range of the scale
					this.max = helpers.max(this.ticks);
					this.min = helpers.min(this.ticks);

					if (this.options.ticks.reverse) {
						this.ticks.reverse();

						this.start = this.max;
						this.end = this.min;
					} else {
						this.start = this.min;
						this.end = this.max;
					}
				},
				getLabelForIndex: function (index, datasetIndex) {
					return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
				},
				convertTicksToLabels: function () {
					this.ticksAsNumbers = this.ticks.slice();
					this.zeroLineIndex = this.ticks.indexOf(0);

					Chart.Scale.prototype.convertTicksToLabels.call(this);
				},
				// Utils
				getPixelForValue: function (value, index, datasetIndex, includeOffset) {
					// This must be called after fit has been run so that
					//      this.left, this.top, this.right, and this.bottom have been defined
					var rightValue = +this.getRightValue(value);
					var pixel;
					var range = this.end - this.start;

					if (this.isHorizontal()) {
						var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
						pixel = this.left + (innerWidth / range * (rightValue - this.start));
						return Math.round(pixel + this.paddingLeft);
					} else {
						var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
						pixel = (this.bottom - this.paddingBottom) - (innerHeight / range * (rightValue - this.start));
						return Math.round(pixel);
					}
				},
				getValueForPixel: function (pixel) {
					var offset;

					if (this.isHorizontal()) {
						var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
						offset = (pixel - this.left - this.paddingLeft) / innerWidth;
					} else {
						var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
						offset = (this.bottom - this.paddingBottom - pixel) / innerHeight;
					}

					return this.start + ((this.end - this.start) * offset);
				},
				getPixelForTick: function (index, includeOffset) {
					return this.getPixelForValue(this.ticksAsNumbers[index], null, null, includeOffset);
				}
			});
			Chart.scaleService.registerScaleType("linear", LinearScale, defaultConfig);

		};
	}, {}], 40: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			var defaultConfig = {
				position: "left",

				// label settings
				ticks: {
					callback: function (value, index, arr) {
						var remain = value / (Math.pow(10, Math.floor(Chart.helpers.log10(value))));

						if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === arr.length - 1) {
							return value.toExponential();
						} else {
							return '';
						}
					}
				}
			};

			var LogarithmicScale = Chart.Scale.extend({
				determineDataLimits: function () {
					// Calculate Range
					this.min = null;
					this.max = null;

					if (this.options.stacked) {
						var valuesPerType = {};

						helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
							var meta = this.chart.getDatasetMeta(datasetIndex);
							if (this.chart.isDatasetVisible(datasetIndex) && (this.isHorizontal() ? meta.xAxisID === this.id : meta.yAxisID === this.id)) {
								if (valuesPerType[meta.type] === undefined) {
									valuesPerType[meta.type] = [];
								}

								helpers.each(dataset.data, function (rawValue, index) {
									var values = valuesPerType[meta.type];
									var value = +this.getRightValue(rawValue);
									if (isNaN(value) || meta.data[index].hidden) {
										return;
									}

									values[index] = values[index] || 0;

									if (this.options.relativePoints) {
										values[index] = 100;
									} else {
										// Don't need to split positive and negative since the log scale can't handle a 0 crossing
										values[index] += value;
									}
								}, this);
							}
						}, this);

						helpers.each(valuesPerType, function (valuesForType) {
							var minVal = helpers.min(valuesForType);
							var maxVal = helpers.max(valuesForType);
							this.min = this.min === null ? minVal : Math.min(this.min, minVal);
							this.max = this.max === null ? maxVal : Math.max(this.max, maxVal);
						}, this);

					} else {
						helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
							var meta = this.chart.getDatasetMeta(datasetIndex);
							if (this.chart.isDatasetVisible(datasetIndex) && (this.isHorizontal() ? meta.xAxisID === this.id : meta.yAxisID === this.id)) {
								helpers.each(dataset.data, function (rawValue, index) {
									var value = +this.getRightValue(rawValue);
									if (isNaN(value) || meta.data[index].hidden) {
										return;
									}

									if (this.min === null) {
										this.min = value;
									} else if (value < this.min) {
										this.min = value;
									}

									if (this.max === null) {
										this.max = value;
									} else if (value > this.max) {
										this.max = value;
									}
								}, this);
							}
						}, this);
					}

					this.min = this.options.ticks.min !== undefined ? this.options.ticks.min : this.min;
					this.max = this.options.ticks.max !== undefined ? this.options.ticks.max : this.max;

					if (this.min === this.max) {
						if (this.min !== 0 && this.min !== null) {
							this.min = Math.pow(10, Math.floor(helpers.log10(this.min)) - 1);
							this.max = Math.pow(10, Math.floor(helpers.log10(this.max)) + 1);
						} else {
							this.min = 1;
							this.max = 10;
						}
					}
				},
				buildTicks: function () {
					// Reset the ticks array. Later on, we will draw a grid line at these positions
					// The array simply contains the numerical value of the spots where ticks will be
					this.ticks = [];

					// Figure out what the max number of ticks we can support it is based on the size of
					// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
					// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
					// the graph

					var tickVal = this.options.ticks.min !== undefined ? this.options.ticks.min : Math.pow(10, Math.floor(helpers.log10(this.min)));

					while (tickVal < this.max) {
						this.ticks.push(tickVal);

						var exp = Math.floor(helpers.log10(tickVal));
						var significand = Math.floor(tickVal / Math.pow(10, exp)) + 1;

						if (significand === 10) {
							significand = 1;
							++exp;
						}

						tickVal = significand * Math.pow(10, exp);
					}

					var lastTick = this.options.ticks.max !== undefined ? this.options.ticks.max : tickVal;
					this.ticks.push(lastTick);

					if (this.options.position === "left" || this.options.position === "right") {
						// We are in a vertical orientation. The top value is the highest. So reverse the array
						this.ticks.reverse();
					}

					// At this point, we need to update our max and min given the tick values since we have expanded the
					// range of the scale
					this.max = helpers.max(this.ticks);
					this.min = helpers.min(this.ticks);

					if (this.options.ticks.reverse) {
						this.ticks.reverse();

						this.start = this.max;
						this.end = this.min;
					} else {
						this.start = this.min;
						this.end = this.max;
					}
				},
				convertTicksToLabels: function () {
					this.tickValues = this.ticks.slice();

					Chart.Scale.prototype.convertTicksToLabels.call(this);
				},
				// Get the correct tooltip label
				getLabelForIndex: function (index, datasetIndex) {
					return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
				},
				getPixelForTick: function (index, includeOffset) {
					return this.getPixelForValue(this.tickValues[index], null, null, includeOffset);
				},
				getPixelForValue: function (value, index, datasetIndex, includeOffset) {
					var pixel;

					var newVal = +this.getRightValue(value)
						; var range = helpers.log10(this.end) - helpers.log10(this.start);

					if (this.isHorizontal()) {

						if (newVal === 0) {
							pixel = this.left + this.paddingLeft;
						} else {
							var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
							pixel = this.left + (innerWidth / range * (helpers.log10(newVal) - helpers.log10(this.start)));
							pixel += this.paddingLeft;
						}
					} else {
						// Bottom - top since pixels increase downard on a screen
						if (newVal === 0) {
							pixel = this.top + this.paddingTop;
						} else {
							var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
							pixel = (this.bottom - this.paddingBottom) - (innerHeight / range * (helpers.log10(newVal) - helpers.log10(this.start)));
						}
					}

					return pixel;
				},
				getValueForPixel: function (pixel) {
					var offset;
					var range = helpers.log10(this.end) - helpers.log10(this.start);
					var value;

					if (this.isHorizontal()) {
						var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
						value = this.start * Math.pow(10, (pixel - this.left - this.paddingLeft) * range / innerWidth);
					} else {
						var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
						value = Math.pow(10, (this.bottom - this.paddingBottom - pixel) * range / innerHeight) / this.start;
					}

					return value;
				}

			});
			Chart.scaleService.registerScaleType("logarithmic", LogarithmicScale, defaultConfig);

		};
	}, {}], 41: [function (require, module, exports) {
		"use strict";

		module.exports = function (Chart) {

			var helpers = Chart.helpers;

			var defaultConfig = {
				display: true,

				//Boolean - Whether to animate scaling the chart from the centre
				animate: true,
				lineArc: false,
				position: "chartArea",

				angleLines: {
					display: true,
					color: "rgba(0, 0, 0, 0.1)",
					lineWidth: 1
				},

				// label settings
				ticks: {
					//Boolean - Show a backdrop to the scale label
					showLabelBackdrop: true,

					//String - The colour of the label backdrop
					backdropColor: "rgba(255,255,255,0.75)",

					//Number - The backdrop padding above & below the label in pixels
					backdropPaddingY: 2,

					//Number - The backdrop padding to the side of the label in pixels
					backdropPaddingX: 2
				},

				pointLabels: {
					//Number - Point label font size in pixels
					fontSize: 10,

					//Function - Used to convert point labels
					callback: function (label) {
						return label;
					}
				}
			};

			var LinearRadialScale = Chart.Scale.extend({
				getValueCount: function () {
					return this.chart.data.labels.length;
				},
				setDimensions: function () {
					// Set the unconstrained dimension before label rotation
					this.width = this.maxWidth;
					this.height = this.maxHeight;
					this.xCenter = Math.round(this.width / 2);
					this.yCenter = Math.round(this.height / 2);

					var minSize = helpers.min([this.height, this.width]);
					var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
					this.drawingArea = (this.options.display) ? (minSize / 2) - (tickFontSize / 2 + this.options.ticks.backdropPaddingY) : (minSize / 2);
				},
				determineDataLimits: function () {
					this.min = null;
					this.max = null;

					helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
						if (this.chart.isDatasetVisible(datasetIndex)) {
							var meta = this.chart.getDatasetMeta(datasetIndex);
							helpers.each(dataset.data, function (rawValue, index) {
								var value = +this.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								if (this.min === null) {
									this.min = value;
								} else if (value < this.min) {
									this.min = value;
								}

								if (this.max === null) {
									this.max = value;
								} else if (value > this.max) {
									this.max = value;
								}
							}, this);
						}
					}, this);

					// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
					// do nothing since that would make the chart weird. If the user really wants a weird chart
					// axis, they can manually override it
					if (this.options.ticks.beginAtZero) {
						var minSign = helpers.sign(this.min);
						var maxSign = helpers.sign(this.max);

						if (minSign < 0 && maxSign < 0) {
							// move the top up to 0
							this.max = 0;
						} else if (minSign > 0 && maxSign > 0) {
							// move the botttom down to 0
							this.min = 0;
						}
					}

					if (this.options.ticks.min !== undefined) {
						this.min = this.options.ticks.min;
					} else if (this.options.ticks.suggestedMin !== undefined) {
						this.min = Math.min(this.min, this.options.ticks.suggestedMin);
					}

					if (this.options.ticks.max !== undefined) {
						this.max = this.options.ticks.max;
					} else if (this.options.ticks.suggestedMax !== undefined) {
						this.max = Math.max(this.max, this.options.ticks.suggestedMax);
					}

					if (this.min === this.max) {
						this.min--;
						this.max++;
					}
				},
				buildTicks: function () {


					this.ticks = [];

					// Figure out what the max number of ticks we can support it is based on the size of
					// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
					// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
					// the graph
					var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
					var maxTicks = Math.min(this.options.ticks.maxTicksLimit ? this.options.ticks.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
					maxTicks = Math.max(2, maxTicks); // Make sure we always have at least 2 ticks

					// To get a "nice" value for the tick spacing, we will use the appropriately named
					// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
					// for details.

					var niceRange = helpers.niceNum(this.max - this.min, false);
					var spacing = helpers.niceNum(niceRange / (maxTicks - 1), true);
					var niceMin = Math.floor(this.min / spacing) * spacing;
					var niceMax = Math.ceil(this.max / spacing) * spacing;

					var numSpaces = Math.ceil((niceMax - niceMin) / spacing);

					// Put the values into the ticks array
					this.ticks.push(this.options.ticks.min !== undefined ? this.options.ticks.min : niceMin);
					for (var j = 1; j < numSpaces; ++j) {
						this.ticks.push(niceMin + (j * spacing));
					}
					this.ticks.push(this.options.ticks.max !== undefined ? this.options.ticks.max : niceMax);

					// At this point, we need to update our max and min given the tick values since we have expanded the
					// range of the scale
					this.max = helpers.max(this.ticks);
					this.min = helpers.min(this.ticks);

					if (this.options.ticks.reverse) {
						this.ticks.reverse();

						this.start = this.max;
						this.end = this.min;
					} else {
						this.start = this.min;
						this.end = this.max;
					}

					this.zeroLineIndex = this.ticks.indexOf(0);
				},
				convertTicksToLabels: function () {
					Chart.Scale.prototype.convertTicksToLabels.call(this);

					// Point labels
					this.pointLabels = this.chart.data.labels.map(this.options.pointLabels.callback, this);
				},
				getLabelForIndex: function (index, datasetIndex) {
					return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
				},
				fit: function () {
					/*
					 * Right, this is really confusing and there is a lot of maths going on here
					 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
					 *
					 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
					 *
					 * Solution:
					 *
					 * We assume the radius of the polygon is half the size of the canvas at first
					 * at each index we check if the text overlaps.
					 *
					 * Where it does, we store that angle and that index.
					 *
					 * After finding the largest index and angle we calculate how much we need to remove
					 * from the shape radius to move the point inwards by that x.
					 *
					 * We average the left and right distances to get the maximum shape radius that can fit in the box
					 * along with labels.
					 *
					 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
					 * on each side, removing that from the size, halving it and adding the left x protrusion width.
					 *
					 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
					 * and position it in the most space efficient manner
					 *
					 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
					 */

					var pointLabelFontSize = helpers.getValueOrDefault(this.options.pointLabels.fontSize, Chart.defaults.global.defaultFontSize);
					var pointLabeFontStyle = helpers.getValueOrDefault(this.options.pointLabels.fontStyle, Chart.defaults.global.defaultFontStyle);
					var pointLabeFontFamily = helpers.getValueOrDefault(this.options.pointLabels.fontFamily, Chart.defaults.global.defaultFontFamily);
					var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);

					// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
					// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
					var largestPossibleRadius = helpers.min([(this.height / 2 - pointLabelFontSize - 5), this.width / 2]),
						pointPosition,
						i,
						textWidth,
						halfTextWidth,
						furthestRight = this.width,
						furthestRightIndex,
						furthestRightAngle,
						furthestLeft = 0,
						furthestLeftIndex,
						furthestLeftAngle,
						xProtrusionLeft,
						xProtrusionRight,
						radiusReductionRight,
						radiusReductionLeft,
						maxWidthRadius;
					this.ctx.font = pointLabeFont;

					for (i = 0; i < this.getValueCount(); i++) {
						// 5px to space the text slightly out - similar to what we do in the draw function.
						pointPosition = this.getPointPosition(i, largestPossibleRadius);
						textWidth = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : '').width + 5;
						if (i === 0 || i === this.getValueCount() / 2) {
							// If we're at index zero, or exactly the middle, we're at exactly the top/bottom
							// of the radar chart, so text will be aligned centrally, so we'll half it and compare
							// w/left and right text sizes
							halfTextWidth = textWidth / 2;
							if (pointPosition.x + halfTextWidth > furthestRight) {
								furthestRight = pointPosition.x + halfTextWidth;
								furthestRightIndex = i;
							}
							if (pointPosition.x - halfTextWidth < furthestLeft) {
								furthestLeft = pointPosition.x - halfTextWidth;
								furthestLeftIndex = i;
							}
						} else if (i < this.getValueCount() / 2) {
							// Less than half the values means we'll left align the text
							if (pointPosition.x + textWidth > furthestRight) {
								furthestRight = pointPosition.x + textWidth;
								furthestRightIndex = i;
							}
						} else if (i > this.getValueCount() / 2) {
							// More than half the values means we'll right align the text
							if (pointPosition.x - textWidth < furthestLeft) {
								furthestLeft = pointPosition.x - textWidth;
								furthestLeftIndex = i;
							}
						}
					}

					xProtrusionLeft = furthestLeft;
					xProtrusionRight = Math.ceil(furthestRight - this.width);

					furthestRightAngle = this.getIndexAngle(furthestRightIndex);
					furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);

					radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);
					radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);

					// Ensure we actually need to reduce the size of the chart
					radiusReductionRight = (helpers.isNumber(radiusReductionRight)) ? radiusReductionRight : 0;
					radiusReductionLeft = (helpers.isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;

					this.drawingArea = Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2);
					this.setCenterPoint(radiusReductionLeft, radiusReductionRight);
				},
				setCenterPoint: function (leftMovement, rightMovement) {

					var maxRight = this.width - rightMovement - this.drawingArea,
						maxLeft = leftMovement + this.drawingArea;

					this.xCenter = Math.round(((maxLeft + maxRight) / 2) + this.left);
					// Always vertically in the centre as the text height doesn't change
					this.yCenter = Math.round((this.height / 2) + this.top);
				},

				getIndexAngle: function (index) {
					var angleMultiplier = (Math.PI * 2) / this.getValueCount();
					// Start from the top instead of right, so remove a quarter of the circle

					return index * angleMultiplier - (Math.PI / 2);
				},
				getDistanceFromCenterForValue: function (value) {
					if (value === null) {
						return 0; // null always in center
					}

					// Take into account half font size + the yPadding of the top value
					var scalingFactor = this.drawingArea / (this.max - this.min);
					if (this.options.reverse) {
						return (this.max - value) * scalingFactor;
					} else {
						return (value - this.min) * scalingFactor;
					}
				},
				getPointPosition: function (index, distanceFromCenter) {
					var thisAngle = this.getIndexAngle(index);
					return {
						x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + this.xCenter,
						y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + this.yCenter
					};
				},
				getPointPositionForValue: function (index, value) {
					return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
				},
				draw: function () {
					if (this.options.display) {
						var ctx = this.ctx;
						helpers.each(this.ticks, function (label, index) {
							// Don't draw a centre value (if it is minimum)
							if (index > 0 || this.options.reverse) {
								var yCenterOffset = this.getDistanceFromCenterForValue(this.ticks[index]);
								var yHeight = this.yCenter - yCenterOffset;

								// Draw circular lines around the scale
								if (this.options.gridLines.display) {
									ctx.strokeStyle = this.options.gridLines.color;
									ctx.lineWidth = this.options.gridLines.lineWidth;

									if (this.options.lineArc) {
										// Draw circular arcs between the points
										ctx.beginPath();
										ctx.arc(this.xCenter, this.yCenter, yCenterOffset, 0, Math.PI * 2);
										ctx.closePath();
										ctx.stroke();
									} else {
										// Draw straight lines connecting each index
										ctx.beginPath();
										for (var i = 0; i < this.getValueCount(); i++) {
											var pointPosition = this.getPointPosition(i, this.getDistanceFromCenterForValue(this.ticks[index]));
											if (i === 0) {
												ctx.moveTo(pointPosition.x, pointPosition.y);
											} else {
												ctx.lineTo(pointPosition.x, pointPosition.y);
											}
										}
										ctx.closePath();
										ctx.stroke();
									}
								}

								if (this.options.ticks.display) {
									var tickFontColor = helpers.getValueOrDefault(this.options.ticks.fontColor, Chart.defaults.global.defaultFontColor);
									var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
									var tickFontStyle = helpers.getValueOrDefault(this.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
									var tickFontFamily = helpers.getValueOrDefault(this.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
									var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
									ctx.font = tickLabelFont;

									if (this.options.ticks.showLabelBackdrop) {
										var labelWidth = ctx.measureText(label).width;
										ctx.fillStyle = this.options.ticks.backdropColor;
										ctx.fillRect(
											this.xCenter - labelWidth / 2 - this.options.ticks.backdropPaddingX,
											yHeight - tickFontSize / 2 - this.options.ticks.backdropPaddingY,
											labelWidth + this.options.ticks.backdropPaddingX * 2,
											tickFontSize + this.options.ticks.backdropPaddingY * 2
										);
									}

									ctx.textAlign = 'center';
									ctx.textBaseline = "middle";
									ctx.fillStyle = tickFontColor;
									ctx.fillText(label, this.xCenter, yHeight);
								}
							}
						}, this);

						if (!this.options.lineArc) {
							ctx.lineWidth = this.options.angleLines.lineWidth;
							ctx.strokeStyle = this.options.angleLines.color;

							for (var i = this.getValueCount() - 1; i >= 0; i--) {
								if (this.options.angleLines.display) {
									var outerPosition = this.getPointPosition(i, this.getDistanceFromCenterForValue(this.options.reverse ? this.min : this.max));
									ctx.beginPath();
									ctx.moveTo(this.xCenter, this.yCenter);
									ctx.lineTo(outerPosition.x, outerPosition.y);
									ctx.stroke();
									ctx.closePath();
								}
								// Extra 3px out for some label spacing
								var pointLabelPosition = this.getPointPosition(i, this.getDistanceFromCenterForValue(this.options.reverse ? this.min : this.max) + 5);

								var pointLabelFontColor = helpers.getValueOrDefault(this.options.pointLabels.fontColor, Chart.defaults.global.defaultFontColor);
								var pointLabelFontSize = helpers.getValueOrDefault(this.options.pointLabels.fontSize, Chart.defaults.global.defaultFontSize);
								var pointLabeFontStyle = helpers.getValueOrDefault(this.options.pointLabels.fontStyle, Chart.defaults.global.defaultFontStyle);
								var pointLabeFontFamily = helpers.getValueOrDefault(this.options.pointLabels.fontFamily, Chart.defaults.global.defaultFontFamily);
								var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);

								ctx.font = pointLabeFont;
								ctx.fillStyle = pointLabelFontColor;

								var labelsCount = this.pointLabels.length,
									halfLabelsCount = this.pointLabels.length / 2,
									quarterLabelsCount = halfLabelsCount / 2,
									upperHalf = (i < quarterLabelsCount || i > labelsCount - quarterLabelsCount),
									exactQuarter = (i === quarterLabelsCount || i === labelsCount - quarterLabelsCount);
								if (i === 0) {
									ctx.textAlign = 'center';
								} else if (i === halfLabelsCount) {
									ctx.textAlign = 'center';
								} else if (i < halfLabelsCount) {
									ctx.textAlign = 'left';
								} else {
									ctx.textAlign = 'right';
								}

								// Set the correct text baseline based on outer positioning
								if (exactQuarter) {
									ctx.textBaseline = 'middle';
								} else if (upperHalf) {
									ctx.textBaseline = 'bottom';
								} else {
									ctx.textBaseline = 'top';
								}

								ctx.fillText(this.pointLabels[i] ? this.pointLabels[i] : '', pointLabelPosition.x, pointLabelPosition.y);
							}
						}
					}
				}
			});
			Chart.scaleService.registerScaleType("radialLinear", LinearRadialScale, defaultConfig);

		};
	}, {}], 42: [function (require, module, exports) {
		/*global window: false */
		"use strict";

		var moment = require('moment');
		moment = typeof (moment) === 'function' ? moment : window.moment;

		module.exports = function (Chart) {

			var helpers = Chart.helpers;
			var time = {
				units: [{
					name: 'millisecond',
					steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
				}, {
					name: 'second',
					steps: [1, 2, 5, 10, 30]
				}, {
					name: 'minute',
					steps: [1, 2, 5, 10, 30]
				}, {
					name: 'hour',
					steps: [1, 2, 3, 6, 12]
				}, {
					name: 'day',
					steps: [1, 2, 5]
				}, {
					name: 'week',
					maxStep: 4
				}, {
					name: 'month',
					maxStep: 3
				}, {
					name: 'quarter',
					maxStep: 4
				}, {
					name: 'year',
					maxStep: false
				}]
			};

			var defaultConfig = {
				position: "bottom",

				time: {
					parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
					format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
					unit: false, // false == automatic or override with week, month, year, etc.
					round: false, // none, or override with week, month, year, etc.
					displayFormat: false, // DEPRECATED
					isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/

					// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
					displayFormats: {
						'millisecond': 'h:mm:ss.SSS a', // 11:20:01.123 AM,
						'second': 'h:mm:ss a', // 11:20:01 AM
						'minute': 'h:mm:ss a', // 11:20:01 AM
						'hour': 'MMM D, hA', // Sept 4, 5PM
						'day': 'll', // Sep 4 2015
						'week': 'll', // Week 46, or maybe "[W]WW - YYYY" ?
						'month': 'MMM YYYY', // Sept 2015
						'quarter': '[Q]Q - YYYY', // Q3
						'year': 'YYYY' // 2015
					}
				},
				ticks: {
					autoSkip: false
				}
			};

			var TimeScale = Chart.Scale.extend({
				initialize: function () {
					if (!moment) {
						throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
					}

					Chart.Scale.prototype.initialize.call(this);
				},
				getLabelMoment: function (datasetIndex, index) {
					return this.labelMoments[datasetIndex][index];
				},
				getMomentStartOf: function (tick) {
					if (this.options.time.unit === 'week' && this.options.time.isoWeekday !== false) {
						return tick.clone().startOf('isoWeek').isoWeekday(this.options.time.isoWeekday);
					} else {
						return tick.clone().startOf(this.tickUnit);
					}
				},
				determineDataLimits: function () {
					this.labelMoments = [];

					// Only parse these once. If the dataset does not have data as x,y pairs, we will use
					// these
					var scaleLabelMoments = [];
					if (this.chart.data.labels && this.chart.data.labels.length > 0) {
						helpers.each(this.chart.data.labels, function (label, index) {
							var labelMoment = this.parseTime(label);

							if (labelMoment.isValid()) {
								if (this.options.time.round) {
									labelMoment.startOf(this.options.time.round);
								}
								scaleLabelMoments.push(labelMoment);
							}
						}, this);

						this.firstTick = moment.min.call(this, scaleLabelMoments);
						this.lastTick = moment.max.call(this, scaleLabelMoments);
					} else {
						this.firstTick = null;
						this.lastTick = null;
					}

					helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
						var momentsForDataset = [];
						var datasetVisible = this.chart.isDatasetVisible(datasetIndex);

						if (typeof dataset.data[0] === 'object') {
							helpers.each(dataset.data, function (value, index) {
								var labelMoment = this.parseTime(this.getRightValue(value));

								if (labelMoment.isValid()) {
									if (this.options.time.round) {
										labelMoment.startOf(this.options.time.round);
									}
									momentsForDataset.push(labelMoment);

									if (datasetVisible) {
										// May have gone outside the scale ranges, make sure we keep the first and last ticks updated
										this.firstTick = this.firstTick !== null ? moment.min(this.firstTick, labelMoment) : labelMoment;
										this.lastTick = this.lastTick !== null ? moment.max(this.lastTick, labelMoment) : labelMoment;
									}
								}
							}, this);
						} else {
							// We have no labels. Use the ones from the scale
							momentsForDataset = scaleLabelMoments;
						}

						this.labelMoments.push(momentsForDataset);
					}, this);

					// Set these after we've done all the data
					if (this.options.time.min) {
						this.firstTick = this.parseTime(this.options.time.min);
					}

					if (this.options.time.max) {
						this.lastTick = this.parseTime(this.options.time.max);
					}

					// We will modify these, so clone for later
					this.firstTick = (this.firstTick || moment()).clone();
					this.lastTick = (this.lastTick || moment()).clone();
				},
				buildTicks: function (index) {

					this.ctx.save();
					var tickFontSize = helpers.getValueOrDefault(this.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
					var tickFontStyle = helpers.getValueOrDefault(this.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
					var tickFontFamily = helpers.getValueOrDefault(this.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
					var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
					this.ctx.font = tickLabelFont;

					this.ticks = [];
					this.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step
					this.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)

					// Set unit override if applicable
					if (this.options.time.unit) {
						this.tickUnit = this.options.time.unit || 'day';
						this.displayFormat = this.options.time.displayFormats[this.tickUnit];
						this.scaleSizeInUnits = this.lastTick.diff(this.firstTick, this.tickUnit, true);
						this.unitScale = helpers.getValueOrDefault(this.options.time.unitStepSize, 1);
					} else {
						// Determine the smallest needed unit of the time
						var innerWidth = this.isHorizontal() ? this.width - (this.paddingLeft + this.paddingRight) : this.height - (this.paddingTop + this.paddingBottom);

						// Crude approximation of what the label length might be
						var tempFirstLabel = this.tickFormatFunction(this.firstTick, 0, []);
						var tickLabelWidth = this.ctx.measureText(tempFirstLabel).width;
						var cosRotation = Math.cos(helpers.toRadians(this.options.ticks.maxRotation));
						var sinRotation = Math.sin(helpers.toRadians(this.options.ticks.maxRotation));
						tickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
						var labelCapacity = innerWidth / (tickLabelWidth);

						// Start as small as possible
						this.tickUnit = 'millisecond';
						this.scaleSizeInUnits = this.lastTick.diff(this.firstTick, this.tickUnit, true);
						this.displayFormat = this.options.time.displayFormats[this.tickUnit];

						var unitDefinitionIndex = 0;
						var unitDefinition = time.units[unitDefinitionIndex];

						// While we aren't ideal and we don't have units left
						while (unitDefinitionIndex < time.units.length) {
							// Can we scale this unit. If `false` we can scale infinitely
							this.unitScale = 1;

							if (helpers.isArray(unitDefinition.steps) && Math.ceil(this.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {
								// Use one of the prefedined steps
								for (var idx = 0; idx < unitDefinition.steps.length; ++idx) {
									if (unitDefinition.steps[idx] >= Math.ceil(this.scaleSizeInUnits / labelCapacity)) {
										this.unitScale = helpers.getValueOrDefault(this.options.time.unitStepSize, unitDefinition.steps[idx]);
										break;
									}
								}

								break;
							} else if ((unitDefinition.maxStep === false) || (Math.ceil(this.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {
								// We have a max step. Scale this unit
								this.unitScale = helpers.getValueOrDefault(this.options.time.unitStepSize, Math.ceil(this.scaleSizeInUnits / labelCapacity));
								break;
							} else {
								// Move to the next unit up
								++unitDefinitionIndex;
								unitDefinition = time.units[unitDefinitionIndex];

								this.tickUnit = unitDefinition.name;
								var leadingUnitBuffer = this.firstTick.diff(this.getMomentStartOf(this.firstTick), this.tickUnit, true);
								var trailingUnitBuffer = this.getMomentStartOf(this.lastTick.clone().add(1, this.tickUnit)).diff(this.lastTick, this.tickUnit, true);
								this.scaleSizeInUnits = this.lastTick.diff(this.firstTick, this.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;
								this.displayFormat = this.options.time.displayFormats[unitDefinition.name];
							}
						}
					}

					var roundedStart;

					// Only round the first tick if we have no hard minimum
					if (!this.options.time.min) {
						this.firstTick = this.getMomentStartOf(this.firstTick);
						roundedStart = this.firstTick;
					} else {
						roundedStart = this.getMomentStartOf(this.firstTick);
					}

					// Only round the last tick if we have no hard maximum
					if (!this.options.time.max) {
						var roundedEnd = this.getMomentStartOf(this.lastTick);
						if (roundedEnd.diff(this.lastTick, this.tickUnit, true) !== 0) {
							// Do not use end of because we need this to be in the next time unit
							this.lastTick = this.getMomentStartOf(this.lastTick.add(1, this.tickUnit));
						}
					}

					this.smallestLabelSeparation = this.width;

					helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
						for (var i = 1; i < this.labelMoments[datasetIndex].length; i++) {
							this.smallestLabelSeparation = Math.min(this.smallestLabelSeparation, this.labelMoments[datasetIndex][i].diff(this.labelMoments[datasetIndex][i - 1], this.tickUnit, true));
						}
					}, this);

					// Tick displayFormat override
					if (this.options.time.displayFormat) {
						this.displayFormat = this.options.time.displayFormat;
					}

					// first tick. will have been rounded correctly if options.time.min is not specified
					this.ticks.push(this.firstTick.clone());

					// For every unit in between the first and last moment, create a moment and add it to the ticks tick
					for (var i = 1; i <= this.scaleSizeInUnits; ++i) {
						var newTick = roundedStart.clone().add(i, this.tickUnit);

						// Are we greater than the max time
						if (this.options.time.max && newTick.diff(this.lastTick, this.tickUnit, true) >= 0) {
							break;
						}

						if (i % this.unitScale === 0) {
							this.ticks.push(newTick);
						}
					}

					// Always show the right tick
					var diff = this.ticks[this.ticks.length - 1].diff(this.lastTick, this.tickUnit);
					if (diff !== 0 || this.scaleSizeInUnits === 0) {
						// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart
						// but the last tick was not rounded.
						if (this.options.time.max) {
							this.ticks.push(this.lastTick.clone());
							this.scaleSizeInUnits = this.lastTick.diff(this.ticks[0], this.tickUnit, true);
						} else {
							this.ticks.push(this.lastTick.clone());
							this.scaleSizeInUnits = this.lastTick.diff(this.firstTick, this.tickUnit, true);
						}
					}

					this.ctx.restore();
				},
				// Get tooltip label
				getLabelForIndex: function (index, datasetIndex) {
					var label = this.chart.data.labels && index < this.chart.data.labels.length ? this.chart.data.labels[index] : '';

					if (typeof this.chart.data.datasets[datasetIndex].data[0] === 'object') {
						label = this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
					}

					// Format nicely
					if (this.options.time.tooltipFormat) {
						label = this.parseTime(label).format(this.options.time.tooltipFormat);
					}

					return label;
				},
				// Function to format an individual tick mark
				tickFormatFunction: function tickFormatFunction(tick, index, ticks) {
					var formattedTick = tick.format(this.displayFormat);
					var tickOpts = this.options.ticks;
					var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);

					if (callback) {
						return callback(formattedTick, index, ticks);
					} else {
						return formattedTick;
					}
				},
				convertTicksToLabels: function () {
					this.tickMoments = this.ticks;
					this.ticks = this.ticks.map(this.tickFormatFunction, this);
				},
				getPixelForValue: function (value, index, datasetIndex, includeOffset) {
					var labelMoment = value && value.isValid && value.isValid() ? value : this.getLabelMoment(datasetIndex, index);

					if (labelMoment) {
						var offset = labelMoment.diff(this.firstTick, this.tickUnit, true);

						var decimal = offset / this.scaleSizeInUnits;

						if (this.isHorizontal()) {
							var innerWidth = this.width - (this.paddingLeft + this.paddingRight);
							var valueWidth = innerWidth / Math.max(this.ticks.length - 1, 1);
							var valueOffset = (innerWidth * decimal) + this.paddingLeft;

							return this.left + Math.round(valueOffset);
						} else {
							var innerHeight = this.height - (this.paddingTop + this.paddingBottom);
							var valueHeight = innerHeight / Math.max(this.ticks.length - 1, 1);
							var heightOffset = (innerHeight * decimal) + this.paddingTop;

							return this.top + Math.round(heightOffset);
						}
					}
				},
				getPixelForTick: function (index, includeOffset) {
					return this.getPixelForValue(this.tickMoments[index], null, null, includeOffset);
				},
				getValueForPixel: function (pixel) {
					var innerDimension = this.isHorizontal() ? this.width - (this.paddingLeft + this.paddingRight) : this.height - (this.paddingTop + this.paddingBottom);
					var offset = (pixel - (this.isHorizontal() ? this.left + this.paddingLeft : this.top + this.paddingTop)) / innerDimension;
					offset *= this.scaleSizeInUnits;
					return this.firstTick.clone().add(moment.duration(offset, this.tickUnit).asSeconds(), 'seconds');
				},
				parseTime: function (label) {
					if (typeof this.options.time.parser === 'string') {
						return moment(label, this.options.time.parser);
					}
					if (typeof this.options.time.parser === 'function') {
						return this.options.time.parser(label);
					}
					// Date objects
					if (typeof label.getMonth === 'function' || typeof label === 'number') {
						return moment(label);
					}
					// Moment support
					if (label.isValid && label.isValid()) {
						return label;
					}
					// Custom parsing (return an instance of moment)
					if (typeof this.options.time.format !== 'string' && this.options.time.format.call) {
						console.warn("options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale");
						return this.options.time.format(label);
					}
					// Moment format parsing
					return moment(label, this.options.time.format);
				}
			});
			Chart.scaleService.registerScaleType("time", TimeScale, defaultConfig);

		};

	}, { "moment": 1 }]
}, {}, [7]);

var EbBasicChart = function (Option) {
    this.data = Option.data || null;
    this.XLabel = [];
    this.YLabel = [];
    this.dataset = [];
    this.chartApi = null;
    this.gdata = null;
    this.goptions = null;
    this.Xindx = []; this.Yindx = [];
    this.tableId = Option.tableId;
    this.sourceElement = null;
    this.flagAppendColumns = false;
    this.drake = null;
    this.EbObject = Option.dvObject || null;
    this.Refid = null;
    this.tabNum = null;
    this.type = null;
    this.PcFlag = false;
    this.login = null;
    this.relatedObjects = null;
    this.FD = false;
    this.piedataFlag = false;
    this.MainData = (Option.data === undefined) ? null : data;
    this.isPipped = false;
    this.isContextual = false;
    this.filterValues = [];
    this.rowData = null;
    this.isTagged = false;
    this.bot = false;
    this.cellData = null;
    this.filterHtml = "";
    var _icons = {
        "bar": "fa fa-bar-chart",
        "line": "fa fa-line-chart",
        "pie": "fa fa-pie-chart",
        "area": "fa fa-area-chart",
        "horizontalBar": "fa fa-bar-chart"
    };

    this.start = function () {
        if (this.EbObject === null)
            this.EbObject = new EbChartVisualization("Chart");
        this.type = this.EbObject.Type;
        if (this.data === null)
            this.call2FD();
        else
            this.drawGraphHelper(this.data);
    };

    this.call2FD = function () {
        if (this.EbObject.Columns === null) {
            $.ajax({
                type: "POST",
                url: "../boti/dvView1",
                data: { dvobj: JSON.stringify(this.EbObject) },
                success: this.ajaxSucc.bind(this)
            });
        }
        else {
            this.init();
        }
    };

    this.ajaxSucc = function (text) {
        $("#" + this.contId).append(text);////////////////        
        this.EbObject = dvGlobal.Current_obj;
        this.init();
    }.bind(this);

    this.init = function () {
        this.EbObject = this.EbObject;
        this.type = this.EbObject.Type;
        if (Option.filtervalues.length != 0)
            this.filterValues = Option.filtervalues;
        else
            this.filterValues = this.getFilterValues();
        
        $.ajax({
            type: 'POST',
            url: "../DV/getdata",
            data: { DataVizObjString: JSON.stringify(this.EbObject), draw: 1, RefId: this.EbObject.DataSourceRefId, Start: 0, Length: 50, TFilters: [], Params: this.filterValues },            
            success: this.getDataSuccess.bind(this),
            error: function () { }
        });
    };

    this.getFilterValues = function () {
        var fltr_collection = [];
        var FdCont = ".filterCont";
        var paramstxt = $(FdCont + " #all_control_names").val();//$('#hiddenparams').val().trim();datefrom,dateto
        if (paramstxt != undefined) {
            var params = paramstxt.split(',');
            $.each(params, function (i, id) {
                var v = null;
                var dtype = $(FdCont + ' #' + id).attr('data-ebtype');
                if (dtype === '6')
                    v = $(FdCont + ' #' + id).val().substring(0, 10);
                else if (dtype === '3')
                    v = $(FdCont).children().find("[name=" + id + "]:checked").val();
                else {
                    v = $(FdCont + ' #' + id).val();
                    if (dtype === '16' && !(isNaN(v))) {
                        v = parseInt(v);
                        dtype = 8;
                    }
                }

                if (v !== "")
                    fltr_collection.push(new fltr_obj(dtype, id, v));
            });
        }

        //if (this.rowData !== null) {
        //    $.each(this.rowData, this.rowObj2filter.bind(this, fltr_collection));
        //}

        return fltr_collection;
    };

    this.compareFilterValues = function () {
        var filter = this.getFilterValues();
        if (focusedId !== undefined) {
            $.each(filter, function (i, obj) {
                if (obj.value !== dvcontainerObj.dvcol[focusedId].filterValues[i].value) {
                    filterChanged = true;
                    return false;
                }

            }.bind(this));
            //if (f == null)
            //    return true;
            //else
            //    return false;
        }
        else
            filterChanged = true;
        //return false;
    }

    this.getDataSuccess = function (result) {
        //this.MainData = result.data; 
        if (this.login == "uc")
            dvcontainerObj.currentObj.data = result;
        this.drawGraphHelper(result.data);
    };

    this.drawGraphHelper = function (datain) {
        this.data = datain;
        this.drawGeneralGraph();
    };

    this.getBarData = function () {
        this.Xindx = [];
        this.Yindx = [];
        this.dataset = [];
        this.XLabel = [];
        this.YLabel = [];
        var xdx = [], ydx = [], ml = [], info = [];
        if (this.EbObject.Xaxis.$values.length > 0 && this.EbObject.Yaxis.$values.length > 0) {

            $.each(this.EbObject.Xaxis.$values, function (i, obj) {
                xdx.push(obj.data);
            });

            $.each(this.EbObject.Yaxis.$values, function (i, obj) {
                ydx.push(obj.data);
            });

            $.each(this.data, this.getBarDataLabel.bind(this, xdx));

            for (k = 0; k < ydx.length; k++) {
                this.YLabel = [];
                for (j = 0; j < this.data.length; j++)
                    this.YLabel.push(this.data[j][ydx[k]]);
                if (this.type !== "googlemap") {
                    if (this.type !== "pie") {
                        this.piedataFlag = false;
                        this.dataset.push(new datasetObj(this.EbObject.Yaxis.$values[k].name, this.YLabel, this.EbObject.LegendColor.$values[k].Color, this.EbObject.LegendColor.$values[k].Color, false));
                    }
                    else {
                        this.dataset.push(new datasetObj4Pie(this.EbObject.Yaxis.$values[k].name, this.YLabel, this.EbObject.LegendColor.$values[k].Color, this.EbObject.LegendColor.$values[k].Color, false));
                        this.piedataFlag = true;
                    }
                }
            }

            if (this.type === "googlemap") {
                $.each(this.EbObject.MarkerLabel.$values, function (i, obj) {
                    if (i === 0)
                        ml.push(obj.data);
                });

                if (ml.length > 0) {
                    $.each(this.data, function (i, value) {
                        markLabel.push(value[ml[0]].charAt(0));
                    });
                }
                Inform = [];
                $.each(this.EbObject.InfoWindow.$values, function (i, obj) {
                    info = [];
                    $.each(this.data, function (k, value) {
                        info.push(value[obj.data]);
                    });
                    Inform.push(new informaion(obj.name, info));
                }.bind(this));
            }

        }
    };

    this.getBarDataLabel = function (xdx, i, value) {
        for (k = 0; k < xdx.length; k++)
            this.XLabel.push(value[xdx[k]]);
    };

    this.drawGeneralGraph = function () {
        this.getBarData();
        if (this.type === "googlemap") {
            //this.getData4GoogleMap();
            TableId = this.tableId;
            $("#canvasDiv" + this.tableId).children("iframe").remove();
            $("#myChart" + this.tableId).remove();
            if ($("#map" + this.tableId).children().length === 0)
                $("#canvasDiv" + this.tableId).append("<div id='map" + this.tableId + "' style='height:inherit;width:100%;'></div>");
            Xlabel = this.XLabel;
            Ylabel = this.YLabel;
            showRoute = this.EbObject.ShowRoute;
            if (!this.isMyScriptLoaded("https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js")) {
                $("#layout_div").prepend(`
                <script src= "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js" ></script>
                <script async defer
                    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAh12bqSKCYb6sJ9EVzNkEyXEDZ__UA-TE&callback=initMap">
                </script>`);
            }
            else {
                $("#map" + this.tableId).empty();
                initMap();
            }
            if (this.bot) {
                $("#map" + this.tableId).css("height", "inherit");
                $("#map" + this.tableId).css("margin-top", "10px");
            }
            return false;
        }
        else {
            this.gdata = {
                labels: this.XLabel,
                datasets: this.dataset,
            };
            //this.animateOPtions = (this.EbObject.ShowValue) ? new animateObj(0) : false;
            this.goptions = {
                scales: {
                    yAxes: [{
                        scaleLabel: {
                            display: (this.type !== "pie") ? true : false,
                            labelString: (this.EbObject.YaxisTitle !== "") ? this.EbObject.YaxisTitle : "YLabel",
                            fontColor: (this.EbObject.YaxisTitleColor !== null && this.EbObject.YaxisTitleColor !== "#ffffff") ? this.EbObject.YaxisTitleColor : "#000000"
                        },
                        stacked: false,
                        gridLines: {
                            display: (this.type !== "pie") ? true : false
                        },
                        ticks: {
                            fontSize: 10,
                            fontColor: (this.EbObject.YaxisLabelColor !== null && this.EbObject.YaxisTitleColor !== "#ffffff") ? this.EbObject.YaxisLabelColor : "#000000"
                        },
                        display: (this.type !== "pie") ? true : false
                    }],
                    xAxes: [{
                        scaleLabel: {
                            display: (this.type !== "pie") ? true : false,
                            labelString: (this.EbObject.XaxisTitle !== "") ? this.EbObject.XaxisTitle : "XLabel",
                            fontColor: (this.EbObject.XaxisTitleColor !== null && this.EbObject.YaxisTitleColor !== "#ffffff") ? this.EbObject.XaxisTitleColor : "#000000"
                        },
                        gridLines: {
                            display: (this.type !== "pie") ? true : false
                        },
                        ticks: {
                            fontSize: 10,
                            fontColor: (this.EbObject.XaxisLabelColor !== null && this.EbObject.YaxisTitleColor !== "#ffffff") ? this.EbObject.XaxisLabelColor : "#000000"
                        },
                        display: (this.type !== "pie") ? true : false
                    }]
                },
                zoom: {
                    // Boolean to enable zooming
                    enabled: true,

                    // Zooming directions. Remove the appropriate direction to disable 
                    // Eg. 'y' would only allow zooming in the y direction
                    mode: 'x',
                },
                pan: {
                    enabled: true,
                    mode: 'x',
                },
                legend: {
                    onClick: this.legendClick.bind(this),
                    //position: "left"
                },
                //legend:false,
                //legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<segments.length; i++){%><li><span style=\"background-color:<%=segments[i].fillColor%>\"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>",

                tooltips: {
                    enabled: this.EbObject.ShowTooltip,
                    callbacks: {
                        label: this.toolTipCallback
                    }
                },
                segmentShowStroke: this.EbObject.ShowValue && this.type === "pie",
                segmentStrokeWidth: 2,
                animation: {
                    animateRotate: true,
                    duration: 1,
                    //onProgress: (this.EbObject.ShowValue && this.type === "pie") ? this.animationOnProgress : null,
                    onComplete: (this.EbObject.ShowValue && this.type !== "pie") ? this.animationOnComplete : null
                },
            };
            if (this.EbObject.Xaxis.$values.length > 0 && this.EbObject.Xaxis.$values.length > 0)
                this.RemoveCanvasandCheckButton();
        }

    };

    this.RemoveCanvasandCheckButton = function () {
        if (this.type == null) {
            this.type = "bar";
            //$("#graphDropdown_tab" + this.tableId + " button:first-child").html("<i class='"+_icons["bar"]+"'></i>" + "&nbsp;<span class = 'caret'></span>")
        }
        else {
            this.type = this.type.toLowerCase();
            //$("#graphDropdown_tab" + this.tableId + " button:first-child").html("<i class='" + _icons["bar"] + "'></i>" + "&nbsp;<span class = 'caret'></span>")
        }

        if (this.type == "area" || this.type == "line") {
            if (this.gdata !== null) {
                $.each(this.gdata.datasets, this.GdataDSiterFn.bind(this));
                if (this.piedataFlag)
                    this.drawGeneralGraph();
                this.type = "line";
                if (this.gdata.datasets[0].fill === true)
                    $("#graphDropdown_tab" + this.tableId + " button:first-child").html(`<i class='${_icons["area"]}'></i>&nbsp;<span class = 'caret'></span>`);
                else
                    $("#graphDropdown_tab" + this.tableId + " button:first-child").html(`<i class='${_icons["line"]}'></i>&nbsp;<span class = 'caret'></span>`);
            }
            else
                this.drawGeneralGraph();
        }
        else if (this.type == "bar") {
            if (this.piedataFlag) {
                this.drawGeneralGraph();
            }
            $("#graphDropdown_tab" + this.tableId + " button:first-child").html(`<i class='${_icons["bar"]}'></i>&nbsp;<span class = 'caret'></span>`);
        }
        else if (this.type == "pie") {
            if (!this.piedataFlag)
                this.drawGeneralGraph();
            $("#graphDropdown_tab" + this.tableId + " button:first-child").html(`<i class='${_icons["pie"]}'></i>&nbsp;<span class = 'caret'></span>`);
            delete this.goptions.legend["onClick"];
        }
        else if (this.type == "horizontalbar") {
            if (this.piedataFlag) {
                this.drawGeneralGraph();
            }
            this.type = "horizontalBar"
            $("#graphDropdown_tab" + this.tableId + " button:first-child").html(`<i class='${_icons["horizontalBar"]}'></i>&nbsp;<span class = 'caret'></span>`);
        }


        $("#canvasDiv" + this.tableId).children("iframe").remove();
        $("#myChart" + this.tableId).remove();
        //$("#graphcontainer_tab" + this.tableId).append("<canvas id='myChart" + this.tableId + "'></canvas>");
        $("#canvasDiv" + this.tableId).append("<canvas id='myChart" + this.tableId + "' class='chart-div'></canvas>");

        if (this.EbObject.Xaxis.$values.length > 0 && this.EbObject.Yaxis.$values.length > 0)
            this.drawGraph();


    };

    this.GdataDSiterFn = function (j, obj) {
        var cls = $("#graphDropdown_tab" + this.tableId + " button:eq(0) i").attr("class");

        if (cls !== undefined && cls.indexOf("area") !== -1) {
            this.gdata.datasets[j].fill = true;
            this.type = "area";
        }
        else {
            this.gdata.datasets[j].fill = false;
            this.type = "line";
        }
    }

    this.drawGraph = function () {
        this.EbObject.Type = this.type;
        var canvas = document.getElementById("myChart" + this.tableId);

        this.chartApi = new Chart(canvas, {
            type: this.EbObject.Type.trim(),
            data: this.gdata,
            options: this.goptions,
        });
    };

    this.ResetZoom = function () {
        this.chartApi.resetZoom();
    };

    this.setGraphType = function (e) {
        var current = this;
        this.type = $(e.target).parent().parent().next().text().toLowerCase();
        $("#graphDropdown_tab" + this.tableId + " button:first-child").html(`<i class='${_icons[this.type]}'></i>&nbsp;<span class = 'caret'></span>`);
        if (this.type.trim() !== "googlemap") {
            if (this.EbObject.$type.indexOf("EbGoogleMap") !== -1) {
                $("#canvasDiv" + this.tableId).children("#map").remove();
                var refid = this.EbObject.DataSourceRefId;
                var columns = JSON.parse(JSON.stringify(this.EbObject.Columns));
                var pipe = this.EbObject.Pippedfrom;
                this.EbObject = new EbObjects["EbChartVisualization"](this.EbObject.EbSid);
                this.EbObject.DataSourceRefId = refid;
                this.EbObject.DSColumns = columns;
                this.EbObject.Columns = columns;
                this.EbObject.Pippedfrom = pipe;

                this.propGrid.setObject(this.EbObject, AllMetas["EbChartVisualization"]);
                this.EbObject = this.EbObject;
                this.gdata = null;
                this.updateDragula();
            }
            if (this.EbObject.Xaxis.$values.length > 0 && this.EbObject.Xaxis.$values.length > 0)
                this.RemoveCanvasandCheckButton();
            else
                return false;
        }
        else {
            var refid = this.EbObject.DataSourceRefId;
            var columns = JSON.parse(JSON.stringify(this.EbObject.Columns));
            $("#canvasDiv" + this.tableId).children("iframe").remove();
            $("#myChart" + this.tableId).remove();
            var pipe = this.EbObject.Pippedfrom;
            this.EbObject = new EbObjects["EbGoogleMap"](this.EbObject.EbSid);
            this.EbObject.DataSourceRefId = refid;
            this.EbObject.DSColumns = columns;
            this.EbObject.Columns = columns;
            this.EbObject.Pippedfrom = pipe;
            this.propGrid.setObject(this.EbObject, AllMetas["EbGoogleMap"]);
            this.EbObject = this.EbObject;

            this.updateDragula();
        }
        e.preventDefault();
    };

    this.colDrag = function (e) {
        //e.dataTransfer.setData("text", e.target.id);
        //this.sourceElement = e.target.parentNode.tagName;
        //this.sourceElementId = e.target.parentElement.id;
    };

    this.colDrop = function (el, target, source, sibling) {
        if ($(target).attr("id") === "X_col_name" + this.tableId || $(target).attr("id") === "Y_col_name" + this.tableId) {
            $(el).addClass("columnDrag");
            $(el).children("span").remove();
            var temp;
            $(el).css("display", "inline-block");
            var name = $(el).text();
            $(el).append("<button class='close' type='button'>x</button>");
            if ($(target).attr("id") == "X_col_name" + this.tableId) {
                //this.EbObject.Xaxis.$values.push(new axis($(el).attr("data-id"), name));
                temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.name === name });
                this.EbObject.Xaxis.$values.push(temp[0]);
                //this.Xindx.push(temp[0].data);
            }
            if ($(target).attr("id") == "Y_col_name" + this.tableId) {
                //this.EbObject.Yaxis.$values.push(new axis($(el).attr("data-id"), name));
                temp = $.grep(this.EbObject.Columns.$values, function (obj) { return obj.name === name });
                this.EbObject.Yaxis.$values.push(temp[0]);
                //this.Yindx.push(temp[0].data);
                if (this.type !== "googlemap")
                    this.EbObject.LegendColor.$values.push(new ChartColor(name, randomColor()));
            }

            if ($("#X_col_name" + this.tableId + " li").length == 1 && $("#Y_col_name" + this.tableId + " li").length >= 1) {
                this.drawGeneralGraph();
            }
            else {
                $("#myChart" + this.tableId).remove();
                $("#canvasDiv" + this.tableId).append("<canvas id='myChart" + this.tableId + "' class='chart-div'></canvas>");
            }
            console.log(this.EbObject.Xaxis); console.log(this.EbObject.Yaxis);
            $("#X_col_name" + this.tableId + " button[class=close]").off("click").on("click", this.RemoveAndAddToColumns.bind(this));
            $("#Y_col_name" + this.tableId + " button[class=close]").off("click").on("click", this.RemoveAndAddToColumns.bind(this));
        }

    };

    this.colAllowDrop = function (e) {
        e.preventDefault();
    };

    this.NocolAllowDrop = function (e) {
        e.stopPropagation();
    };

    this.collapseGraph = function () {
        $("#columnsDisplay" + this.tableId).toggle();
        $("#xy" + this.tableId).toggle();
        if ($("#columnsDisplay" + this.tableId).css("display") === "none") {
            $("#canvasParentDiv" + this.tableId).removeClass("col-md-10").addClass("col-md-12");
            $("#canvasDiv" + this.tableId).css("height", "100%");
            //$("#myChart" + this.tableId).css("height", "inherit");
        }
        else {
            $("#canvasParentDiv" + this.tableId).removeClass("col-md-12").addClass("col-md-10");
            $("#canvasDiv" + this.tableId).css("height", "calc(100% - 67px)");
        }
    };

    this.toggleFilterdialog = function () {
        $(".filterCont").toggle();
    };

    this.togglePPGrid = function () {
        $("#Relateddiv").hide();
        $(".ppcont").toggle();
    };

    this.RemoveAndAddToColumns = function (e) {
        var str = $(e.target).parent().text();
        var index = parseInt($(e.target).parent().attr("data-id"));
        if ($(e.target).parent().parent().attr("id") === "X_col_name" + this.tableId) {
            if (gettypefromNumber($(e.target).parent().attr("data-type")) === "String")
                $("#diamension" + this.tableId).append(`<li class='colTiles' style='display: list-item;' id='li${str.substr(0, str.length - 1)}' data-id='${$(e.target).parent().attr("data-id")}' data-type='${$(e.target).parent().attr("data-type")}'><span><i class='fa fa-font'></i></span>${str.substr(0, str.length - 1)}</li>`);
            else if (gettypefromNumber($(e.target).parent().attr("data-type")) === "DateTime")
                $("#diamension" + this.tableId).append(`<li class='colTiles' style='display: list-item;' id='li${str.substr(0, str.length - 1)}' data-id='${$(e.target).parent().attr("data-id")}' data-type='${$(e.target).parent().attr("data-type")}'><span><i class='fa fa-calendar'></i></span>${str.substr(0, str.length - 1)}</li>`);
            //index = this.Xindx.indexOf($(e.target).parent().attr("data-id"));
            //this.Xindx.pop(index);
        }
        else if ($(e.target).parent().parent().attr("id") === "Y_col_name" + this.tableId) {
            $("#measure" + this.tableId).append(`<li class='colTiles' style='display: list-item;' id='li${str.substr(0, str.length - 1)}' data-id='${$(e.target).parent().attr("data-id")}' data-type='${$(e.target).parent().attr("data-type")}'><span><i class='fa fa-sort-numeric-asc'></i></span>${str.substr(0, str.length - 1)}</li>`);
            //index = this.Yindx.indexOf($(e.target).parent().attr("data-id"));
            //this.Yindx.pop(index);
        }
        //$("#columns4Drag" + this.tableId + " .list-group").append("<li class='alert alert-success columnDrag' id='" + $(e.target).parent().attr("id") + "' draggable='true' data-id='" + $(e.target).parent().attr("data-id") + "'>" + str.substring(0, str.length - 1).trim() + "</li>");
        $(e.target).parent().remove();
        //$("#columns4Drag" + this.tableId + " .columnDrag").off("dragstart").on("dragstart", this.colDrag.bind(this));
        this.EbObject.Xaxis.$values = $.grep(this.EbObject.Xaxis.$values, function (vobj) { return vobj.name !== str.substring(0, str.length - 1).trim() });
        this.EbObject.Yaxis.$values = $.grep(this.EbObject.Yaxis.$values, function (vobj) { return vobj.name !== str.substring(0, str.length - 1).trim() });
        if (this.type !== "googlemap")
            this.EbObject.LegendColor.$values = $.grep(this.EbObject.LegendColor.$values, function (vobj) { return vobj.name !== str.substring(0, str.length - 1).trim() });
        //this.EbObject.Xaxis = this.
        //this.Xindx = $.grep(this.Xindx, function (obj) { return obj.name !== str.substring(0, str.length - 1).trim() });
        //this.Yindx = $.grep(this.Yindx, function (obj) { return obj.name !== str.substring(0, str.length - 1).trim() });

        if ($("#X_col_name" + this.tableId + " li").length == 1 && $("#Y_col_name" + this.tableId + " li").length >= 1) {
            this.drawGeneralGraph();
        }
        else {
            $("#myChart" + this.tableId).remove();
            $("#canvasDiv" + this.tableId).append("<canvas id='myChart" + this.tableId + "' width='auto' height='auto' class='chart-div'></canvas>");
        }
    };

    this.searchDragNDropColumn = function (e) {
        var search_word = $("#searchColumn" + this.tableId).val();
        if (search_word !== "") {
            $("#columns4Drag" + this.tableId + " ul li").hide();
            $("#columns4Drag" + this.tableId + " ul li").each(function () {
                var current_keyword = $(this).text();
                if (current_keyword.indexOf(search_word) >= 0) {
                    $(this).show();
                };
            });
        }
        else {
            $("#columns4Drag" + this.tableId + " ul li").show();
        };

    };

    this.legendClick = function (event, legendItem) {
        if (this.chartApi !== null && this.type !== "pie") {
            $("#fontSel").click();
        }
        $("#fontSel").off("change").on("change", this.reloadChart.bind(this, legendItem));
    }

    this.reloadChart = function (legendItem) {
        $.each(this.EbObject.LegendColor.$values, function (i, obj) {
            if (legendItem.text === obj.name)
                this.EbObject.LegendColor.$values[i].color = $("#fontSel").val();
        }.bind(this));
        if (this.type !== "pie") {
            if (this.gdata.datasets[0].fill === true)
                this.type = "area";
            $.each(this.gdata.datasets, this.reloadChart_inner.bind(this, legendItem));
        }
        else
            $.each(this.gdata.datasets, this.reloadChart4pie.bind(this, legendItem));

        if (this.EbObject.Xaxis.$values.length > 0 && this.EbObject.Xaxis.$values.length > 0)
            this.RemoveCanvasandCheckButton();
    };

    this.reloadChart_inner = function (legendItem, i, obj) {
        if (i === legendItem.datasetIndex) {
            this.gdata.datasets[i].backgroundColor = $("#fontSel").val();
            this.gdata.datasets[i].borderColor = $("#fontSel").val();
        }
    };

    this.reloadChart4pie = function (legendItem, i, obj) {
        this.gdata.datasets[i].backgroundColor[legendItem.index] = $("#fontSel").val();
        this.gdata.datasets[i].borderColor[legendItem.index] = $("#fontSel").val();
    }

    this.animationOnComplete = function () {
        var chartInstance = this.chart,
            ctx = chartInstance.ctx;

        ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontSize, Chart.defaults.global.defaultFontStyle, Chart.defaults.global.defaultFontFamily);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        this.data.datasets.forEach(function (dataset, i) {
            var meta = chartInstance.controller.getDatasetMeta(i);
            meta.data.forEach(function (bar, index) {
                var data = dataset.data[index];
                ctx.fillText(data, bar._model.x, bar._model.y - 5);
            });
        });
    };

    this.animationOnProgress = function (animation) {
        var canvas = document.getElementById("myChart" + this.tableId);
        var ctx = canvas.getContext("2d");
        var midX = canvas.width / 2;
        var midY = canvas.height / 2

        var radius = this.chartApi.outerRadius;
        for (var i = 0; i < this.chartApi.segments.length; i++) {
            ctx.fillStyle = "white";
            var textSize = canvas.width / 10;
            ctx.font = textSize + "px Verdana";
            // Get needed variables
            var value = this.chartApi.segments[i].value;
            var startAngle = this.chartApi.segments[i].startAngle;
            var endAngle = this.chartApi.segments[i].endAngle;
            var middleAngle = startAngle + ((endAngle - startAngle) / 2);

            // Compute text location
            var posX = (radius / 2) * Math.cos(middleAngle) + midX;
            var posY = (radius / 2) * Math.sin(middleAngle) + midY;

            // Text offside by middle
            var w_offset = ctx.measureText(value).width / 2;
            var h_offset = textSize / 4;

            ctx.fillText(value, posX - w_offset, posY + h_offset);
        }
    }.bind(this);

    this.updateDragula = function (status) {
        if (this.EbObject.$type.indexOf("EbChartVisualization") !== -1) {
            if (this.drake)
                this.drake.destroy();
            this.drake = new dragula([document.getElementById("diamension" + this.tableId), document.getElementById("measure" + this.tableId), document.getElementById("X_col_name" + this.tableId), document.getElementById("Y_col_name" + this.tableId)], {
                accepts: this.acceptDrop.bind(this)
            });
            this.drake.on("drop", this.colDrop.bind(this));
            if (this.type === "")
                this.type = "bar";
            this.propGrid.setObject(this.EbObject, AllMetas["EbChartVisualization"]);
        }
        else {
            this.type = "googlemap";
            if (this.drake)
                this.drake.destroy();
            this.drake = new dragula([document.getElementById("diamension" + this.tableId), document.getElementById("measure" + this.tableId), document.getElementById("X_col_name" + this.tableId), document.getElementById("Y_col_name" + this.tableId)], {
                accepts: this.acceptDrop1.bind(this)
            });
            this.drake.on("drop", this.colDrop.bind(this));
            this.propGrid.setObject(this.EbObject, AllMetas["EbGoogleMap"]);
        }

        if (this.type !== "googlemap") {
            $("#X_col_name" + this.tableId).siblings("span").text("X-Axis");
            $("#Y_col_name" + this.tableId).siblings("span").text("Y-Axis");
            $("#graphDropdown_tab" + this.tableId).show();
        }
        else {
            $("#X_col_name" + this.tableId).siblings("span").text("Longitude");
            $("#Y_col_name" + this.tableId).siblings("span").text("Lattitude");
            $("#graphDropdown_tab" + this.tableId).hide();
        }

        if (status !== undefined) {
            if (this.EbObject.Xaxis.$values.length > 0 && this.EbObject.Xaxis.$values.length > 0) {
                if (this.type !== "googlemap") {
                    $.each(this.EbObject.Yaxis.$values, function (i, obj) {
                        this.EbObject.LegendColor.$values.push(new ChartColor(obj.name, randomColor()));
                    }.bind(this));
                }
                this.drawGeneralGraph();
            }

        }
    };

    this.acceptDrop1 = function (el, target, source, sibling) {
        if ($(source).attr("id") === "X_col_name" + this.tableId && $(target).attr("id") === "Y_col_name" + this.tableId) {
            return false;
        }
        else if ($(source).attr("id") === "Y_col_name" + this.tableId && $(target).attr("id") === "X_col_name" + this.tableId) {
            return false;
        }
        else if ($(target).children().length == 1) {
            return false;
        }
        return true;
    };

    this.isMyScriptLoaded = function (url) {
        var scripts = document.getElementsByTagName('script');
        for (var i = scripts.length; i--;) {
            if (scripts[i].src == url) return true;
        }
        return false;
    };

    this.rearrangeObjects = function () {
        this.EbObject.DataSourceRefId = this.prevObj.DataSourceRefId;
        this.EbObject.DSColumns = this.prevObj.DSColumns;
        this.EbObject.Columns = this.prevObj.Columns;
        this.EbObject.Xaxis = this.prevObj.Xaxis;
        this.EbObject.Yaxis = this.prevObj.Yaxis;
        this.EbObject.Pippedfrom = this.prevObj.Pippedfrom;
    }

    this.toolTipCallback = function (item, data) {
        if (this.type === "pie")
            return data.datasets[item.datasetIndex].label + ": " + data.labels[item.index] + ": " + data.datasets[item.datasetIndex].data[item.index];
    }.bind(this);

    this.CreateRelationString = function () { };

    this.start();
};
(function ($) {
    $.fn.ebFileViewer = function (options, tlbar) {
        let defaults = [{
            FileName: "",
            FileSize: "",
            FileRefId: "",
            Meta: {},
            UploadTime: "",
            FileCategory: ""

        }];
        dftlbar = {
            info: 1,
            zoomIn: 1,
            zoomOut: 1,
            oneToOne: 1,
            reset: 1,
            prev: 1,
            play: {
                show: 1,
                size: 'large',
            },
            next: 1,
            rotateLeft: 1,
            rotateRight: 1,
            flipHorizontal: 1,
            flipVertical: 1,
            download: 1,
            print: 1
        }
        let _toolbar = tlbar || dftlbar;
        this.imagelist = "";
        this.pgSettings = $.extend(defaults, options);

        this.init = function () {
            this.createViewer();

        }

        this.createViewer = function () {
            this.infono = 1;
            if (this.pgSettings.length) {
                let ulview = (`<div id='ebviewdiv_tmp-f' > <ul id='imageContainer'>`);
                ulview += `</ul> </div>`
                $("body").append(ulview);
                this.pgSettings.forEach(function (obj) {
                    if (obj.FileCategory == 1) {
                        let filethumbnail = "";
                        let filesrc = "";
                        if (obj.hasOwnProperty('Recent')) {
                            filethumbnail = obj.FileB64;
                            filesrc = obj.FileB64;
                        }
                        else {
                            filethumbnail = `/images/small/${obj.FileRefId}.jpg`;
                            filesrc = `/images/${obj.FileRefId}.jpg`;
                        }


                        let filename = obj.FileName || "image";
                        let lk = $(`<li class="fileviewerimg"><img id="tst" data-original='' data-src='${filesrc}' src='${filethumbnail}'  dtls='${obj.FileName}' alt='${filename}'></li>`);
                        var l = lk.find("img").data("details", obj.Meta);
                        $('#imageContainer').append(lk);
                    }
                });

                this.imagelist = $('#ebviewdiv_tmp-f');
                $('#ebviewdiv_tmp-f').remove();
                this.viewer = new Viewer(this.imagelist[0], {
                    url: 'data-src',
                    navbar: 1,
                    toolbar: _toolbar
                }
                );

            }
            else {
                ////commented because in fup control incase of single image after delete it shows this dailoguebox
                // EbMessage("show", { Message: "No image found", Background: 'red' });
            }
        }



        this.showimage = function (rfid) {
            if (!(!rfid || rfid.length === 0)) {
                let indx = this.pgSettings.findIndex(item => item.FileRefId == rfid);
                if (this.pgSettings[indx].FileCategory == 1) {
                    let temparr = [];
                    for (let i = 0; i < this.pgSettings.length; i++) {
                        if (this.pgSettings[i].FileCategory == 1) {
                            temparr.push(this.pgSettings[i]);
                        }
                    }
                    let j = temparr.findIndex(x => x.FileRefId == rfid);
                    this.viewer.view(j);
                }
                else if (this.pgSettings[indx].FileCategory == 0) {
                    let src = null;
                    let html = '';
                    src = `/files/${rfid}`;

                    var arr = this.pgSettings[indx].FileName.split('.');
                    var exten = arr[arr.length - 1];
                    let url = (this.pgSettings[indx].hasOwnProperty('Recent')) ? this.pgSettings[indx].FileB64 : `${src}.${exten}`;
                    if (exten == 'pdf') {

                        let html = $(`<div id='ebfileview_ContDiv' class='eb_fileview-Cont' style=''>
                                    <button id='' class="btn close-ebfileview_Cont ebclx_fileview-Cont" style=''><i class="fa fa-close"></i></button>
                                    <button id='' class="btn resize-ebfileview_Cont" style=''><i class="fa fa-long-arrow-right"></i></button> 
                                    </div>`);
                        //$("body").append(` <iframe id="display_file" src="${src}.${exten}" frameborder="0" style=" bottom: 0;direction: ltr; font-size: 0; left: 0; line-height: 0;  overflow: hidden;position: absolute;right: 0;"></iframe>`);
                        html.append(`<div id='ebfileview_Iframe-Cont' class='eb_iframe-Cont' style=" ">
                                    <iframe id='ebfileview_Iframe' class='ebfileview_Iframe' src="${url}" class='' style=''></iframe>
                                    </div>`);
                        $("body").append(html[0]);
                        $('.close-ebfileview_Cont').off('click').on('click', this.CloseFileviewFn.bind(this));
                        $('.resize-ebfileview_Cont').off('click').on('click', this.ResizeFileviewFn.bind(this));
                        console.log("need pdf viewer");
                    }
                    else {
                        if (confirm(`Download ${this.pgSettings[indx].FileName} ?`)) {
                            let link = document.createElement('a');
                            link.download = this.pgSettings[indx].FileName;
                            link.href = `${url}`;
                            link.click();
                        }

                    }
                }
                //pdf viewer


            }

        }

        this.deleteimage = function (refidarr) {
            if (refidarr.length > 0) {
                let refids = "";
                for (i = refidarr.length; i >= 0; i--) {
                    refids = refidarr[i];
                    if (!(!refids || refids.length === 0)) {
                        let indx = this.pgSettings.findIndex(item => item.FileRefId == refids);
                        this.pgSettings.splice(indx, 1);
                    }
                }
                this.createViewer();
            }
        }

        this.CloseFileviewFn = function (e) {
            let target = $(e.target).closest('button').parent();
            if (target.attr("id") == "ebfileview_ContDiv") {
                target.remove();
            }
        }

        this.ResizeFileviewFn = function (e) {
            let $c = $("#ebfileview_ContDiv");
            let $i = $(e.currentTarget).find('i');
            $i.removeClass('fa-long-arrow-right').removeClass('fa-long-arrow-left').removeClass('fa-arrows-h');
            if ($c[0].style.width === '50%') {
                if ($c[0].style.left === '50%') {
                    $c.css('left', '0');
                    $i.addClass('fa-arrows-h');
                }
                else {
                    $c.css('width', '100%').css('left', '0');
                    $i.addClass('fa-long-arrow-right');
                }
            }
            else {
                $c.css('width', '50%').css('left', '50%');
                $i.addClass('fa-long-arrow-left');
            }

        }

        this.addToImagelist = function (file) {
            if (file.hasOwnProperty('Recent')) {
                if (file.FileCategory == 1) {
                    let filethumbnail = file.FileB64;
                    let filesrc = file.FileB64;
                    let filename = file.FileName || "image";
                    let li = $(`<li class="fileviewerimg"><img id="tst" data-original='' data-src='${filesrc}' src='${filethumbnail}'  dtls='${file.FileName}' alt='${filename}'></li>`);
                    var l = li.find("img").data("details", file.Meta);
                    this.imagelist.find('#imageContainer').append(li);
                    this.pgSettings.push(file);
                    this.viewer.update();
                }
                else {
                    this.pgSettings.push(file);
                }
            }
            else {
                if (file.FileCategory == 1) {
                    let filethumbnail = `/images/small/${file.FileRefId}.jpg`;
                    let filesrc = `/images/${file.FileRefId}.jpg`;
                    let filename = file.FileName || "image";
                    let li = $(`<li class="fileviewerimg"><img id="tst" data-original='' data-src='${filesrc}' src='${filethumbnail}'  dtls='${file.FileName}' alt='${filename}'></li>`);
                    var l = li.find("img").data("details", file.Meta);
                    this.imagelist.find('#imageContainer').append(li);
                    this.pgSettings.push(file);
                    this.viewer.update();
                }
                else {
                    this.pgSettings.push(file);
                }
            }

        }
        this.init();
        return this;
    };





}(jQuery));
//also implemented download , print ,info

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global = global || self, global.Viewer = factory());
}(this, (function () {
    'use strict';

    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function (obj) {
                return typeof obj;
            };
        } else {
            _typeof = function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
        }

        return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
    }

    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }

        return obj;
    }

    function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
            keys.push.apply(keys, symbols);
        }

        return keys;
    }

    function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};

            if (i % 2) {
                ownKeys(Object(source), true).forEach(function (key) {
                    _defineProperty(target, key, source[key]);
                });
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
                ownKeys(Object(source)).forEach(function (key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
            }
        }

        return target;
    }

    function imgdivremove() {
        $(".imgDetail").remove();
    }
    var DEFAULTS = {
        /**
         * Enable a modal backdrop, specify `static` for a backdrop
         * which doesn't close the modal on click.
         * @type {boolean}
         */
        backdrop: true,

        /**
         * Show the button on the top-right of the viewer.
         * @type {boolean}
         */
        button: true,

        /**
         * Show the navbar.
         * @type {boolean | number}
         */
        navbar: true,

        /**
         * Specify the visibility and the content of the title.
         * @type {boolean | number | Function | Array}
         */
        title: true,

        /**
         * Show the toolbar.
         * @type {boolean | number | Object}
         */
        toolbar: true,

        /**
         * Custom class name(s) to add to the viewer's root element.
         * @type {string}
         */
        className: '',

        /**
         * Define where to put the viewer in modal mode.
         * @type {string | Element}
         */
        container: 'body',

        /**
         * Filter the images for viewing. Return true if the image is viewable.
         * @type {Function}
         */
        filter: null,

        /**
         * Enable to request fullscreen when play.
         * @type {boolean}
         */
        fullscreen: true,

        /**
         * Define the initial index of image for viewing.
         * @type {number}
         */
        initialViewIndex: 0,

        /**
         * Enable inline mode.
         * @type {boolean}
         */
        inline: false,

        /**
         * The amount of time to delay between automatically cycling an image when playing.
         * @type {number}
         */
        interval: 5000,

        /**
         * Enable keyboard support.
         * @type {boolean}
         */
        keyboard: true,

        /**
         * Indicate if show a loading spinner when load image or not.
         * @type {boolean}
         */
        loading: true,

        /**
         * Indicate if enable loop viewing or not.
         * @type {boolean}
         */
        loop: true,

        /**
         * Min width of the viewer in inline mode.
         * @type {number}
         */
        minWidth: 200,

        /**
         * Min height of the viewer in inline mode.
         * @type {number}
         */
        minHeight: 100,

        /**
         * Enable to move the image.
         * @type {boolean}
         */
        movable: true,

        /**
         * Enable to rotate the image.
         * @type {boolean}
         */
        rotatable: true,

        /**
         * Enable to scale the image.
         * @type {boolean}
         */
        scalable: true,

        /**
         * Enable to zoom the image.
         * @type {boolean}
         */
        zoomable: true,

        /**
         * Enable to zoom the current image by dragging on the touch screen.
         * @type {boolean}
         */
        zoomOnTouch: true,

        /**
         * Enable to zoom the image by wheeling mouse.
         * @type {boolean}
         */
        zoomOnWheel: true,

        /**
         * Enable to slide to the next or previous image by swiping on the touch screen.
         * @type {boolean}
         */
        slideOnTouch: true,

        /**
         * Indicate if toggle the image size between its natural size
         * and initial size when double click on the image or not.
         * @type {boolean}
         */
        toggleOnDblclick: true,

        /**
         * Show the tooltip with image ratio (percentage) when zoom in or zoom out.
         * @type {boolean}
         */
        tooltip: true,

        /**
         * Enable CSS3 Transition for some special elements.
         * @type {boolean}
         */
        transition: true,

        /**
         * Define the CSS `z-index` value of viewer in modal mode.
         * @type {number}
         */
        zIndex: 2015,

        /**
         * Define the CSS `z-index` value of viewer in inline mode.
         * @type {number}
         */
        zIndexInline: 0,

        /**
         * Define the ratio when zoom the image by wheeling mouse.
         * @type {number}
         */
        zoomRatio: 0.1,

        /**
         * Define the min ratio of the image when zoom out.
         * @type {number}
         */
        minZoomRatio: 0.01,

        /**
         * Define the max ratio of the image when zoom in.
         * @type {number}
         */
        maxZoomRatio: 100,

        /**
         * Define where to get the original image URL for viewing.
         * @type {string | Function}
         */
        url: 'src',

        /**
         * Event shortcuts.
         * @type {Function}
         */
        ready: null,
        show: null,
        shown: null,
        hide: null,
        hidden: null,
        view: null,
        viewed: null,
        zoom: null,
        zoomed: null
    };

    var TEMPLATE = '<div class="viewer-container" touch-action="none">' + '<div class="viewer-canvas"></div>' + '<div class="viewer-footer">' + '<div class="viewer-title"></div>' + '<div class="viewer-toolbar"></div>' + '<div class="viewer-navbar">' + '<ul class="viewer-list"></ul>' + '</div>' + '</div>' + '<div class="viewer-tooltip"></div>' + '<div role="button" class="viewer-button" data-viewer-action="mix"></div>' + '<div class="viewer-eb-button"><i class="fa fa-long-arrow-right"></i></div>' + '<div class="viewer-player"></div>' + '</div>';

    var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
    var WINDOW = IS_BROWSER ? window : {};
    var IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;
    var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
    var NAMESPACE = 'viewer'; // Actions

    var ACTION_MOVE = 'move';
    var ACTION_SWITCH = 'switch';
    var ACTION_ZOOM = 'zoom'; // Classes

    var CLASS_ACTIVE = "".concat(NAMESPACE, "-active");
    var CLASS_CLOSE = "".concat(NAMESPACE, "-close");
    var CLASS_FADE = "".concat(NAMESPACE, "-fade");
    var CLASS_FIXED = "".concat(NAMESPACE, "-fixed");
    var CLASS_FULLSCREEN = "".concat(NAMESPACE, "-fullscreen");
    var CLASS_FULLSCREEN_EXIT = "".concat(NAMESPACE, "-fullscreen-exit");
    var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
    var CLASS_HIDE_MD_DOWN = "".concat(NAMESPACE, "-hide-md-down");
    var CLASS_HIDE_SM_DOWN = "".concat(NAMESPACE, "-hide-sm-down");
    var CLASS_HIDE_XS_DOWN = "".concat(NAMESPACE, "-hide-xs-down");
    var CLASS_IN = "".concat(NAMESPACE, "-in");
    var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
    var CLASS_LOADING = "".concat(NAMESPACE, "-loading");
    var CLASS_MOVE = "".concat(NAMESPACE, "-move");
    var CLASS_OPEN = "".concat(NAMESPACE, "-open");
    var CLASS_SHOW = "".concat(NAMESPACE, "-show");
    var CLASS_TRANSITION = "".concat(NAMESPACE, "-transition"); // Events

    var EVENT_CLICK = 'click';
    var EVENT_DBLCLICK = 'dblclick';
    var EVENT_DRAG_START = 'dragstart';
    var EVENT_HIDDEN = 'hidden';
    var EVENT_HIDE = 'hide';
    var EVENT_KEY_DOWN = 'keydown';
    var EVENT_LOAD = 'load';
    var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
    var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
    var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
    var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
    var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
    var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
    var EVENT_READY = 'ready';
    var EVENT_RESIZE = 'resize';
    var EVENT_SHOW = 'show';
    var EVENT_SHOWN = 'shown';
    var EVENT_TRANSITION_END = 'transitionend';
    var EVENT_VIEW = 'view';
    var EVENT_VIEWED = 'viewed';
    var EVENT_WHEEL = 'wheel';
    var EVENT_ZOOM = 'zoom';
    var EVENT_ZOOMED = 'zoomed'; // Data keys

    var DATA_ACTION = "".concat(NAMESPACE, "Action"); // RegExps

    var REGEXP_SPACES = /\s\s*/; // Misc

    var BUTTONS = ['zoom-in', 'zoom-out', 'one-to-one', 'reset', 'prev', 'play', 'next', 'rotate-left', 'rotate-right', 'flip-horizontal', 'flip-vertical', 'info', 'print', 'download'];

    /**
     * Check if the given value is a string.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is a string, else `false`.
     */

    function isString(value) {
        return typeof value === 'string';
    }
    /**
     * Check if the given value is not a number.
     */

    var isNaN = Number.isNaN || WINDOW.isNaN;
    /**
     * Check if the given value is a number.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is a number, else `false`.
     */

    function isNumber(value) {
        return typeof value === 'number' && !isNaN(value);
    }
    /**
     * Check if the given value is undefined.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
     */

    function isUndefined(value) {
        return typeof value === 'undefined';
    }
    /**
     * Check if the given value is an object.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is an object, else `false`.
     */

    function isObject(value) {
        return _typeof(value) === 'object' && value !== null;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * Check if the given value is a plain object.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
     */

    function isPlainObject(value) {
        if (!isObject(value)) {
            return false;
        }

        try {
            var _constructor = value.constructor;
            var prototype = _constructor.prototype;
            return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
        } catch (error) {
            return false;
        }
    }
    /**
     * Check if the given value is a function.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is a function, else `false`.
     */

    function isFunction(value) {
        return typeof value === 'function';
    }
    /**
     * Iterate the given data.
     * @param {*} data - The data to iterate.
     * @param {Function} callback - The process function for each element.
     * @returns {*} The original data.
     */

    function forEach(data, callback) {
        if (data && isFunction(callback)) {
            if (Array.isArray(data) || isNumber(data.length)
                /* array-like */
            ) {
                var length = data.length;
                var i;

                for (i = 0; i < length; i += 1) {
                    if (callback.call(data, data[i], i, data) === false) {
                        break;
                    }
                }
            } else if (isObject(data)) {
                Object.keys(data).forEach(function (key) {
                    callback.call(data, data[key], key, data);
                });
            }
        }

        return data;
    }
    /**
     * Extend the given object.
     * @param {*} obj - The object to be extended.
     * @param {*} args - The rest objects which will be merged to the first object.
     * @returns {Object} The extended object.
     */

    var assign = Object.assign || function assign(obj) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        if (isObject(obj) && args.length > 0) {
            args.forEach(function (arg) {
                if (isObject(arg)) {
                    Object.keys(arg).forEach(function (key) {
                        obj[key] = arg[key];
                    });
                }
            });
        }

        return obj;
    };
    var REGEXP_SUFFIX = /^(?:width|height|left|top|marginLeft|marginTop)$/;
    /**
     * Apply styles to the given element.
     * @param {Element} element - The target element.
     * @param {Object} styles - The styles for applying.
     */

    function setStyle(element, styles) {
        var style = element.style;
        forEach(styles, function (value, property) {
            if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
                value += 'px';
            }

            style[property] = value;
        });
    }
    /**
     * Escape a string for using in HTML.
     * @param {String} value - The string to escape.
     * @returns {String} Returns the escaped string.
     */

    function escapeHTMLEntities(value) {
        return isString(value) ? value.replace(/&(?!amp;|quot;|#39;|lt;|gt;)/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : value;
    }
    /**
     * Check if the given element has a special class.
     * @param {Element} element - The element to check.
     * @param {string} value - The class to search.
     * @returns {boolean} Returns `true` if the special class was found.
     */

    function hasClass(element, value) {
        if (!element || !value) {
            return false;
        }

        return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
    }
    /**
     * Add classes to the given element.
     * @param {Element} element - The target element.
     * @param {string} value - The classes to be added.
     */

    function addClass(element, value) {
        if (!element || !value) {
            return;
        }

        if (isNumber(element.length)) {
            forEach(element, function (elem) {
                addClass(elem, value);
            });
            return;
        }

        if (element.classList) {
            element.classList.add(value);
            return;
        }

        var className = element.className.trim();

        if (!className) {
            element.className = value;
        } else if (className.indexOf(value) < 0) {
            element.className = "".concat(className, " ").concat(value);
        }
    }
    /**
     * Remove classes from the given element.
     * @param {Element} element - The target element.
     * @param {string} value - The classes to be removed.
     */

    function removeClass(element, value) {
        if (!element || !value) {
            return;
        }

        if (isNumber(element.length)) {
            forEach(element, function (elem) {
                removeClass(elem, value);
            });
            return;
        }

        if (element.classList) {
            element.classList.remove(value);
            return;
        }

        if (element.className.indexOf(value) >= 0) {
            element.className = element.className.replace(value, '');
        }
    }
    /**
     * Add or remove classes from the given element.
     * @param {Element} element - The target element.
     * @param {string} value - The classes to be toggled.
     * @param {boolean} added - Add only.
     */

    function toggleClass(element, value, added) {
        if (!value) {
            return;
        }

        if (isNumber(element.length)) {
            forEach(element, function (elem) {
                toggleClass(elem, value, added);
            });
            return;
        } // IE10-11 doesn't support the second parameter of `classList.toggle`


        if (added) {
            addClass(element, value);
        } else {
            removeClass(element, value);
        }
    }
    var REGEXP_HYPHENATE = /([a-z\d])([A-Z])/g;
    /**
     * Transform the given string from camelCase to kebab-case
     * @param {string} value - The value to transform.
     * @returns {string} The transformed value.
     */

    function hyphenate(value) {
        return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();
    }
    /**
     * Get data from the given element.
     * @param {Element} element - The target element.
     * @param {string} name - The data key to get.
     * @returns {string} The data value.
     */

    function getData(element, name) {
        if (isObject(element[name])) {
            return element[name];
        }

        if (element.dataset) {
            return element.dataset[name];
        }

        return element.getAttribute("data-".concat(hyphenate(name)));
    }
    /**
     * Set data to the given element.
     * @param {Element} element - The target element.
     * @param {string} name - The data key to set.
     * @param {string} data - The data value.
     */

    function setData(element, name, data) {
        if (isObject(data)) {
            element[name] = data;
        } else if (element.dataset) {
            element.dataset[name] = data;
        } else {
            element.setAttribute("data-".concat(hyphenate(name)), data);
        }
    }

    var onceSupported = function () {
        var supported = false;

        if (IS_BROWSER) {
            var once = false;

            var listener = function listener() { };

            var options = Object.defineProperty({}, 'once', {
                get: function get() {
                    supported = true;
                    return once;
                },

                /**
                 * This setter can fix a `TypeError` in strict mode
                 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
                 * @param {boolean} value - The value to set
                 */
                set: function set(value) {
                    once = value;
                }
            });
            WINDOW.addEventListener('test', listener, options);
            WINDOW.removeEventListener('test', listener, options);
        }

        return supported;
    }();
    /**
     * Remove event listener from the target element.
     * @param {Element} element - The event target.
     * @param {string} type - The event type(s).
     * @param {Function} listener - The event listener.
     * @param {Object} options - The event options.
     */


    function removeListener(element, type, listener) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var handler = listener;
        type.trim().split(REGEXP_SPACES).forEach(function (event) {
            if (!onceSupported) {
                var listeners = element.listeners;

                if (listeners && listeners[event] && listeners[event][listener]) {
                    handler = listeners[event][listener];
                    delete listeners[event][listener];

                    if (Object.keys(listeners[event]).length === 0) {
                        delete listeners[event];
                    }

                    if (Object.keys(listeners).length === 0) {
                        delete element.listeners;
                    }
                }
            }

            element.removeEventListener(event, handler, options);
        });
    }
    /**
     * Add event listener to the target element.
     * @param {Element} element - The event target.
     * @param {string} type - The event type(s).
     * @param {Function} listener - The event listener.
     * @param {Object} options - The event options.
     */

    function addListener(element, type, listener) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var _handler = listener;
        type.trim().split(REGEXP_SPACES).forEach(function (event) {
            if (options.once && !onceSupported) {
                var _element$listeners = element.listeners,
                    listeners = _element$listeners === void 0 ? {} : _element$listeners;

                _handler = function handler() {
                    delete listeners[event][listener];
                    element.removeEventListener(event, _handler, options);

                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args[_key2] = arguments[_key2];
                    }

                    listener.apply(element, args);
                };

                if (!listeners[event]) {
                    listeners[event] = {};
                }

                if (listeners[event][listener]) {
                    element.removeEventListener(event, listeners[event][listener], options);
                }

                listeners[event][listener] = _handler;
                element.listeners = listeners;
            }

            element.addEventListener(event, _handler, options);
        });
    }
    /**
     * Dispatch event on the target element.
     * @param {Element} element - The event target.
     * @param {string} type - The event type(s).
     * @param {Object} data - The additional event data.
     * @returns {boolean} Indicate if the event is default prevented or not.
     */

    function dispatchEvent(element, type, data) {
        var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

        if (isFunction(Event) && isFunction(CustomEvent)) {
            event = new CustomEvent(type, {
                detail: data,
                bubbles: true,
                cancelable: true
            });
        } else {
            event = document.createEvent('CustomEvent');
            event.initCustomEvent(type, true, true, data);
        }

        return element.dispatchEvent(event);
    }
    /**
     * Get the offset base on the document.
     * @param {Element} element - The target element.
     * @returns {Object} The offset data.
     */

    function getOffset(element) {
        var box = element.getBoundingClientRect();
        return {
            left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
            top: box.top + (window.pageYOffset - document.documentElement.clientTop)
        };
    }
    /**
     * Get transforms base on the given object.
     * @param {Object} obj - The target object.
     * @returns {string} A string contains transform values.
     */

    function getTransforms(_ref) {
        var rotate = _ref.rotate,
            scaleX = _ref.scaleX,
            scaleY = _ref.scaleY,
            translateX = _ref.translateX,
            translateY = _ref.translateY;
        var values = [];

        if (isNumber(translateX) && translateX !== 0) {
            values.push("translateX(".concat(translateX, "px)"));
        }

        if (isNumber(translateY) && translateY !== 0) {
            values.push("translateY(".concat(translateY, "px)"));
        } // Rotate should come first before scale to match orientation transform


        if (isNumber(rotate) && rotate !== 0) {
            values.push("rotate(".concat(rotate, "deg)"));
        }

        if (isNumber(scaleX) && scaleX !== 1) {
            values.push("scaleX(".concat(scaleX, ")"));
        }

        if (isNumber(scaleY) && scaleY !== 1) {
            values.push("scaleY(".concat(scaleY, ")"));
        }

        var transform = values.length ? values.join(' ') : 'none';
        return {
            WebkitTransform: transform,
            msTransform: transform,
            transform: transform
        };
    }
    /**
     * Get an image name from an image url.
     * @param {string} url - The target url.
     * @example
     * // picture.jpg
     * getImageNameFromURL('https://domain.com/path/to/picture.jpg?size=1280960')
     * @returns {string} A string contains the image name.
     */

    function getImageNameFromURL(url) {
        return isString(url) ? decodeURIComponent(url.replace(/^.*\//, '').replace(/[?&#].*$/, '')) : '';
    }
    var IS_SAFARI = WINDOW.navigator && /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i.test(WINDOW.navigator.userAgent);
    /**
     * Get an image's natural sizes.
     * @param {string} image - The target image.
     * @param {Function} callback - The callback function.
     * @returns {HTMLImageElement} The new image.
     */

    function getImageNaturalSizes(image, callback) {
        var newImage = document.createElement('img'); // Modern browsers (except Safari)

        if (image.naturalWidth && !IS_SAFARI) {
            callback(image.naturalWidth, image.naturalHeight);
            return newImage;
        }

        var body = document.body || document.documentElement;

        newImage.onload = function () {
            callback(newImage.width, newImage.height);

            if (!IS_SAFARI) {
                body.removeChild(newImage);
            }
        };

        newImage.src = image.src; // iOS Safari will convert the image automatically
        // with its orientation once append it into DOM

        if (!IS_SAFARI) {
            newImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
            body.appendChild(newImage);
        }

        return newImage;
    }
    /**
     * Get the related class name of a responsive type number.
     * @param {string} type - The responsive type.
     * @returns {string} The related class name.
     */

    function getResponsiveClass(type) {
        switch (type) {
            case 2:
                return CLASS_HIDE_XS_DOWN;

            case 3:
                return CLASS_HIDE_SM_DOWN;

            case 4:
                return CLASS_HIDE_MD_DOWN;

            default:
                return '';
        }
    }
    /**
     * Get the max ratio of a group of pointers.
     * @param {string} pointers - The target pointers.
     * @returns {number} The result ratio.
     */

    function getMaxZoomRatio(pointers) {
        var pointers2 = _objectSpread2({}, pointers);

        var ratios = [];
        forEach(pointers, function (pointer, pointerId) {
            delete pointers2[pointerId];
            forEach(pointers2, function (pointer2) {
                var x1 = Math.abs(pointer.startX - pointer2.startX);
                var y1 = Math.abs(pointer.startY - pointer2.startY);
                var x2 = Math.abs(pointer.endX - pointer2.endX);
                var y2 = Math.abs(pointer.endY - pointer2.endY);
                var z1 = Math.sqrt(x1 * x1 + y1 * y1);
                var z2 = Math.sqrt(x2 * x2 + y2 * y2);
                var ratio = (z2 - z1) / z1;
                ratios.push(ratio);
            });
        });
        ratios.sort(function (a, b) {
            return Math.abs(a) < Math.abs(b);
        });
        return ratios[0];
    }
    /**
     * Get a pointer from an event object.
     * @param {Object} event - The target event object.
     * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
     * @returns {Object} The result pointer contains start and/or end point coordinates.
     */

    function getPointer(_ref2, endOnly) {
        var pageX = _ref2.pageX,
            pageY = _ref2.pageY;
        var end = {
            endX: pageX,
            endY: pageY
        };
        return endOnly ? end : _objectSpread2({
            timeStamp: Date.now(),
            startX: pageX,
            startY: pageY
        }, end);
    }
    /**
     * Get the center point coordinate of a group of pointers.
     * @param {Object} pointers - The target pointers.
     * @returns {Object} The center point coordinate.
     */

    function getPointersCenter(pointers) {
        var pageX = 0;
        var pageY = 0;
        var count = 0;
        forEach(pointers, function (_ref3) {
            var startX = _ref3.startX,
                startY = _ref3.startY;
            pageX += startX;
            pageY += startY;
            count += 1;
        });
        pageX /= count;
        pageY /= count;
        return {
            pageX: pageX,
            pageY: pageY
        };
    }

    var render = {
        render: function render() {
            this.initContainer();
            this.initViewer();
            this.initList();
            this.renderViewer();
        },
        initContainer: function initContainer() {
            this.containerData = {
                width: this.eb_half_width ? (window.innerWidth / 2) : window.innerWidth,
                height: window.innerHeight
            };
        },
        initViewer: function initViewer() {
            var options = this.options,
                parent = this.parent;
            var viewerData;

            if (options.inline) {
                viewerData = {
                    width: Math.max(parent.offsetWidth, options.minWidth),
                    height: Math.max(parent.offsetHeight, options.minHeight)
                };
                this.parentData = viewerData;
            }

            if (this.fulled || !viewerData) {
                viewerData = this.containerData;
            }

            this.viewerData = assign({}, viewerData);
        },
        renderViewer: function renderViewer() {
            if (this.options.inline && !this.fulled) {
                setStyle(this.viewer, this.viewerData);
            }
        },
        initList: function initList() {
            var _this = this;

            var element = this.element,
                options = this.options,
                list = this.list;
            var items = []; // initList may be called in this.update, so should keep idempotent

            list.innerHTML = '';
            //for navbar ,thumbnails........set src as thumpnail
            forEach(this.images, function (image, index) {
                var src = image.src;
                var alt = image.alt || getImageNameFromURL(src);
                var url = options.url;

                if (isString(url)) {
                    url = image.getAttribute(url);
                } else if (isFunction(url)) {
                    url = url.call(_this, image);
                }

                if (src || url) {
                    var item = document.createElement('li');
                    var img = document.createElement('img');
                    // commented bcoz lazy load issue
                    img.src = src || url;
                    img.alt = alt;
                    img.setAttribute('class', 'viewerLzyImg');
                    img.setAttribute('data-index', index);
                    /////////////
                    img.setAttribute('data-src', url || src);
                    img.setAttribute('data-original-url', url || src);
                    img.setAttribute('data-viewer-action', 'view');
                    img.setAttribute('role', 'button');
                    img.setAttribute('dtls', image.attributes.dtls.value);
                    item.appendChild(img);
                    list.appendChild(item);
                    items.push(item);
                }
            });
            this.items = items;
            forEach(items, function (item) {
                var image = item.firstElementChild;
                setData(image, 'filled', true);

                if (options.loading) {
                    addClass(item, CLASS_LOADING);
                }

                addListener(image, EVENT_LOAD, function (event) {
                    if (options.loading) {
                        removeClass(item, CLASS_LOADING);
                    }

                    _this.loadImage(event);
                }, {
                    once: true
                });
            });

            if (options.transition) {
                addListener(element, EVENT_VIEWED, function () {
                    addClass(list, CLASS_TRANSITION);
                }, {
                    once: true
                });
            }
        },
        renderList: function renderList(index) {
            var i = index || this.index;
            var width = this.items[i].offsetWidth || 30;
            var outerWidth = width + 1; // 1 pixel of `margin-left` width
            // Place the active item in the center of the screen

            setStyle(this.list, assign({
                width: outerWidth * this.length
            }, getTransforms({
                translateX: (this.viewerData.width - width) / 2 - outerWidth * i
            })));
        },
        resetList: function resetList() {
            var list = this.list;
            list.innerHTML = '';
            removeClass(list, CLASS_TRANSITION);
            setStyle(list, getTransforms({
                translateX: 0
            }));
        },
        initImage: function initImage(done) {
            var _this2 = this;

            var options = this.options,
                image = this.image,
                viewerData = this.viewerData;
            var footerHeight = this.footer.offsetHeight;
            var viewerWidth = viewerData.width;
            var viewerHeight = Math.max(viewerData.height - footerHeight, footerHeight);
            var oldImageData = this.imageData || {};
            var sizingImage;
            this.imageInitializing = {
                abort: function abort() {
                    sizingImage.onload = null;
                }
            };
            sizingImage = getImageNaturalSizes(image, function (naturalWidth, naturalHeight) {
                var aspectRatio = naturalWidth / naturalHeight;
                var width = viewerWidth;
                var height = viewerHeight;
                _this2.imageInitializing = false;

                if (viewerHeight * aspectRatio > viewerWidth) {
                    height = viewerWidth / aspectRatio;
                } else {
                    width = viewerHeight * aspectRatio;
                }

                width = Math.min(width * 0.9, naturalWidth);
                height = Math.min(height * 0.9, naturalHeight);
                var imageData = {
                    naturalWidth: naturalWidth,
                    naturalHeight: naturalHeight,
                    aspectRatio: aspectRatio,
                    ratio: width / naturalWidth,
                    width: width,
                    height: height,
                    left: (viewerWidth - width) / 2,
                    top: (viewerHeight - height) / 2
                };
                var initialImageData = assign({}, imageData);

                if (options.rotatable) {
                    imageData.rotate = oldImageData.rotate || 0;
                    initialImageData.rotate = 0;
                }

                if (options.scalable) {
                    imageData.scaleX = oldImageData.scaleX || 1;
                    imageData.scaleY = oldImageData.scaleY || 1;
                    initialImageData.scaleX = 1;
                    initialImageData.scaleY = 1;
                }

                _this2.imageData = imageData;
                _this2.initialImageData = initialImageData;

                if (done) {
                    done();
                }
            });
        },
        renderImage: function renderImage(done) {
            var _this3 = this;

            var image = this.image,
                imageData = this.imageData;
            setStyle(image, assign({
                width: imageData.width,
                height: imageData.height,
                // XXX: Not to use translateX/Y to avoid image shaking when zooming
                marginLeft: imageData.left,
                marginTop: imageData.top
            }, getTransforms(imageData)));

            if (done) {
                if ((this.viewing || this.zooming) && this.options.transition) {
                    var onTransitionEnd = function onTransitionEnd() {
                        _this3.imageRendering = false;
                        done();
                    };

                    this.imageRendering = {
                        abort: function abort() {
                            removeListener(image, EVENT_TRANSITION_END, onTransitionEnd);
                        }
                    };
                    addListener(image, EVENT_TRANSITION_END, onTransitionEnd, {
                        once: true
                    });
                } else {
                    done();
                }
            }
        },
        resetImage: function resetImage() {
            // this.image only defined after viewed
            if (this.viewing || this.viewed) {
                var image = this.image;

                if (this.viewing) {
                    this.viewing.abort();
                }

                image.parentNode.removeChild(image);
                this.image = null;
            }
        }
    };

    var events = {
        bind: function bind() {
            var options = this.options,
                viewer = this.viewer,
                canvas = this.canvas;
            var document = this.element.ownerDocument;
            addListener(viewer, EVENT_CLICK, this.onClick = this.click.bind(this));
            addListener(viewer, EVENT_DRAG_START, this.onDragStart = this.dragstart.bind(this));
            addListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown = this.pointerdown.bind(this));
            addListener(document, EVENT_POINTER_MOVE, this.onPointerMove = this.pointermove.bind(this));
            addListener(document, EVENT_POINTER_UP, this.onPointerUp = this.pointerup.bind(this));
            addListener(document, EVENT_KEY_DOWN, this.onKeyDown = this.keydown.bind(this));
            addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));

            if (options.zoomable && options.zoomOnWheel) {
                addListener(viewer, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
                    passive: false,
                    capture: true
                });
            }

            if (options.toggleOnDblclick) {
                addListener(canvas, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
            }

            //eb_edited
            $(viewer).off('click', '.viewer-eb-button').on('click', '.viewer-eb-button', function (e) {
                let $v = $(this.viewer);
                let $i = $(e.currentTarget).find('i');
                $i.removeClass('fa-long-arrow-right').removeClass('fa-long-arrow-left').removeClass('fa-arrows-h');
                if (this.viewer.style.width === '50%') {
                    if (this.viewer.style.left === '50%') {
                        $v.css('left', '0');
                        $i.addClass('fa-arrows-h');
                    }
                    else {
                        $v.css('width', '100%').css('left', '0');
                        $i.addClass('fa-long-arrow-right');
                        this.eb_half_width = false;
                        this.resize();
                    }
                }
                else {
                    $v.css('width', '50%').css('left', '50%');
                    $i.addClass('fa-long-arrow-left');
                    this.eb_half_width = true;
                    this.resize();
                }
            }.bind(this));
        },
        unbind: function unbind() {
            var options = this.options,
                viewer = this.viewer,
                canvas = this.canvas;
            var document = this.element.ownerDocument;
            removeListener(viewer, EVENT_CLICK, this.onClick);
            removeListener(viewer, EVENT_DRAG_START, this.onDragStart);
            removeListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown);
            removeListener(document, EVENT_POINTER_MOVE, this.onPointerMove);
            removeListener(document, EVENT_POINTER_UP, this.onPointerUp);
            removeListener(document, EVENT_KEY_DOWN, this.onKeyDown);
            removeListener(window, EVENT_RESIZE, this.onResize);

            if (options.zoomable && options.zoomOnWheel) {
                removeListener(viewer, EVENT_WHEEL, this.onWheel, {
                    passive: false,
                    capture: true
                });
            }

            if (options.toggleOnDblclick) {
                removeListener(canvas, EVENT_DBLCLICK, this.onDblclick);
            }
        }
    };

    var handlers = {
        click: function click(event) {
            var target = event.target;
            var options = this.options,
                imageData = this.imageData;
            var action = getData(target, DATA_ACTION); // Cancel the emulated click when the native click event was triggered.

            if (IS_TOUCH_DEVICE && event.isTrusted && target === this.canvas) {
                clearTimeout(this.clickCanvasTimeout);
            }

            switch (action) {
                case 'mix':
                    if (this.played) {
                        this.stop();
                    } else if (options.inline) {
                        if (this.fulled) {
                            this.exit();
                        } else {
                            this.full();
                        }
                    } else {
                        this.hide();
                        imgdivremove();
                        this.infono = 1;
                        // $(".viewer-container").remove();
                    }

                    break;

                case 'hide':
                    this.hide();
                    imgdivremove();
                    this.infono = 1;
                    // $(".viewer-container").remove();
                    break;

                case 'view':
                    this.infono = 1;
                    this.view(getData(target, 'index'));
                    break;

                case 'zoom-in':
                    this.zoom(0.1, true);
                    break;

                case 'zoom-out':
                    this.zoom(-0.1, true);
                    break;

                case 'one-to-one':
                    this.toggle();
                    break;

                case 'reset':
                    this.reset();
                    break;

                case 'prev':
                    this.infono = 1;
                    imgdivremove();
                    this.prev(options.loop);
                    break;

                case 'play':
                    this.play(options.fullscreen);
                    break;

                case 'next':
                    this.infono = 1;
                    imgdivremove();
                    this.next(options.loop);
                    break;

                case 'rotate-left':
                    this.rotate(-90);
                    break;

                case 'rotate-right':
                    this.rotate(90);
                    break;

                case 'flip-horizontal':
                    this.scaleX(-imageData.scaleX || -1);
                    break;

                case 'flip-vertical':
                    this.scaleY(-imageData.scaleY || -1);
                    break;

                case 'info':
                    this.info();
                    break;

                case 'download':
                    this.download();
                    break;

                case 'print':
                    this.print();
                    break;

                default:
                    if (this.played) {
                        this.stop();
                    }

            }
        },
        dblclick: function dblclick(event) {
            event.preventDefault();

            if (this.viewed && event.target === this.image) {
                // Cancel the emulated double click when the native dblclick event was triggered.
                if (IS_TOUCH_DEVICE && event.isTrusted) {
                    clearTimeout(this.doubleClickImageTimeout);
                }

                this.toggle();
            }
        },
        load: function load() {
            var _this = this;

            if (this.timeout) {
                clearTimeout(this.timeout);
                this.timeout = false;
            }

            var element = this.element,
                options = this.options,
                image = this.image,
                index = this.index,
                viewerData = this.viewerData;
            removeClass(image, CLASS_INVISIBLE);

            if (options.loading) {
                removeClass(this.canvas, CLASS_LOADING);
            }

            image.style.cssText = 'height:0;' + "margin-left:".concat(viewerData.width / 2, "px;") + "margin-top:".concat(viewerData.height / 2, "px;") + 'max-width:none!important;' + 'position:absolute;' + 'width:0;';
            this.initImage(function () {
                toggleClass(image, CLASS_MOVE, options.movable);
                toggleClass(image, CLASS_TRANSITION, options.transition);

                _this.renderImage(function () {
                    _this.viewed = true;
                    _this.viewing = false;

                    if (isFunction(options.viewed)) {
                        addListener(element, EVENT_VIEWED, options.viewed, {
                            once: true
                        });
                    }

                    dispatchEvent(element, EVENT_VIEWED, {
                        originalImage: _this.images[index],
                        index: index,
                        image: image
                    });
                });
            });
        },
        loadImage: function loadImage(event) {
            var image = event.target;
            var parent = image.parentNode;
            var parentWidth = parent.offsetWidth || 30;
            var parentHeight = parent.offsetHeight || 50;
            var filled = !!getData(image, 'filled');
            getImageNaturalSizes(image, function (naturalWidth, naturalHeight) {
                var aspectRatio = naturalWidth / naturalHeight;
                var width = parentWidth;
                var height = parentHeight;

                if (parentHeight * aspectRatio > parentWidth) {
                    if (filled) {
                        width = parentHeight * aspectRatio;
                    } else {
                        height = parentWidth / aspectRatio;
                    }
                } else if (filled) {
                    height = parentWidth / aspectRatio;
                } else {
                    width = parentHeight * aspectRatio;
                }

                setStyle(image, assign({
                    width: width,
                    height: height
                }, getTransforms({
                    translateX: (parentWidth - width) / 2,
                    translateY: (parentHeight - height) / 2
                })));
            });
        },
        keydown: function keydown(event) {
            var options = this.options;

            if (!this.fulled || !options.keyboard) {
                return;
            }

            switch (event.keyCode || event.which || event.charCode) {
                // Escape
                case 27:
                    if (this.played) {
                        this.stop();
                    } else if (options.inline) {
                        if (this.fulled) {
                            this.exit();
                        }
                    } else {
                        this.hide();
                        imgdivremove();
                        // $(".viewer-container").remove();
                    }

                    break;
                // Space

                case 32:
                    if (this.played) {
                        this.stop();
                    }

                    break;
                // ArrowLeft

                case 37:
                    this.prev(options.loop);
                    break;
                // ArrowUp

                case 38:
                    // Prevent scroll on Firefox
                    event.preventDefault(); // Zoom in

                    this.zoom(options.zoomRatio, true);
                    break;
                // ArrowRight

                case 39:
                    this.next(options.loop);
                    break;
                // ArrowDown

                case 40:
                    // Prevent scroll on Firefox
                    event.preventDefault(); // Zoom out

                    this.zoom(-options.zoomRatio, true);
                    break;
                // Ctrl + 0

                case 48: // Fall through
                // Ctrl + 1
                // eslint-disable-next-line no-fallthrough

                case 49:
                    if (event.ctrlKey) {
                        event.preventDefault();
                        this.toggle();
                    }

                    break;
            }
        },
        dragstart: function dragstart(event) {
            if (event.target.tagName.toLowerCase() === 'img') {
                event.preventDefault();
            }
        },
        pointerdown: function pointerdown(event) {
            var options = this.options,
                pointers = this.pointers;
            var buttons = event.buttons,
                button = event.button;

            if (!this.viewed || this.showing || this.viewing || this.hiding // Handle mouse event and pointer event and ignore touch event
                || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
                    isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
                    || event.ctrlKey)) {
                return;
            } // Prevent default behaviours as page zooming in touch devices.


            event.preventDefault();

            if (event.changedTouches) {
                forEach(event.changedTouches, function (touch) {
                    pointers[touch.identifier] = getPointer(touch);
                });
            } else {
                pointers[event.pointerId || 0] = getPointer(event);
            }

            var action = options.movable ? ACTION_MOVE : false;

            if (options.zoomOnTouch && options.zoomable && Object.keys(pointers).length > 1) {
                action = ACTION_ZOOM;
            } else if (options.slideOnTouch && (event.pointerType === 'touch' || event.type === 'touchstart') && this.isSwitchable()) {
                action = ACTION_SWITCH;
            }

            if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {
                removeClass(this.image, CLASS_TRANSITION);
            }

            this.action = action;
        },
        pointermove: function pointermove(event) {
            var pointers = this.pointers,
                action = this.action;

            if (!this.viewed || !action) {
                return;
            }

            event.preventDefault();

            if (event.changedTouches) {
                forEach(event.changedTouches, function (touch) {
                    assign(pointers[touch.identifier] || {}, getPointer(touch, true));
                });
            } else {
                assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
            }

            this.change(event);
        },
        pointerup: function pointerup(event) {
            var _this2 = this;

            var options = this.options,
                action = this.action,
                pointers = this.pointers;
            var pointer;

            if (event.changedTouches) {
                forEach(event.changedTouches, function (touch) {
                    pointer = pointers[touch.identifier];
                    delete pointers[touch.identifier];
                });
            } else {
                pointer = pointers[event.pointerId || 0];
                delete pointers[event.pointerId || 0];
            }

            if (!action) {
                return;
            }

            event.preventDefault();

            if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {
                addClass(this.image, CLASS_TRANSITION);
            }

            this.action = false; // Emulate click and double click in touch devices to support backdrop and image zooming (#210).

            if (IS_TOUCH_DEVICE && action !== ACTION_ZOOM && pointer && Date.now() - pointer.timeStamp < 500) {
                clearTimeout(this.clickCanvasTimeout);
                clearTimeout(this.doubleClickImageTimeout);

                if (options.toggleOnDblclick && this.viewed && event.target === this.image) {
                    if (this.imageClicked) {
                        this.imageClicked = false; // This timeout will be cleared later when a native dblclick event is triggering

                        this.doubleClickImageTimeout = setTimeout(function () {
                            dispatchEvent(_this2.image, EVENT_DBLCLICK);
                        }, 50);
                    } else {
                        this.imageClicked = true; // The default timing of a double click in Windows is 500 ms

                        this.doubleClickImageTimeout = setTimeout(function () {
                            _this2.imageClicked = false;
                        }, 500);
                    }
                } else {
                    this.imageClicked = false;

                    if (options.backdrop && options.backdrop !== 'static' && event.target === this.canvas) {
                        // This timeout will be cleared later when a native click event is triggering
                        this.clickCanvasTimeout = setTimeout(function () {
                            dispatchEvent(_this2.canvas, EVENT_CLICK);
                        }, 50);
                    }
                }
            }
        },
        resize: function resize() {
            var _this3 = this;

            if (!this.isShown || this.hiding) {
                return;
            }

            this.initContainer();
            this.initViewer();
            this.renderViewer();
            this.renderList();

            if (this.viewed) {
                this.initImage(function () {
                    _this3.renderImage();
                });
            }

            if (this.played) {
                if (this.options.fullscreen && this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
                    this.stop();
                    return;
                }

                forEach(this.player.getElementsByTagName('img'), function (image) {
                    addListener(image, EVENT_LOAD, _this3.loadImage.bind(_this3), {
                        once: true
                    });
                    dispatchEvent(image, EVENT_LOAD);
                });
            }
        },
        wheel: function wheel(event) {
            var _this4 = this;

            if (!this.viewed) {
                return;
            }

            event.preventDefault(); // Limit wheel speed to prevent zoom too fast

            if (this.wheeling) {
                return;
            }

            this.wheeling = true;
            setTimeout(function () {
                _this4.wheeling = false;
            }, 50);
            var ratio = Number(this.options.zoomRatio) || 0.1;
            var delta = 1;

            if (event.deltaY) {
                delta = event.deltaY > 0 ? 1 : -1;
            } else if (event.wheelDelta) {
                delta = -event.wheelDelta / 120;
            } else if (event.detail) {
                delta = event.detail > 0 ? 1 : -1;
            }

            this.zoom(-delta * ratio, true, event);
        }
    };

    var methods = {
        /** Show the viewer (only available in modal mode)
         * @param {boolean} [immediate=false] - Indicates if show the viewer immediately or not.
         * @returns {Viewer} this
         */
        show: function show() {
            var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var element = this.element,
                options = this.options;

            if (options.inline || this.showing || this.isShown || this.showing) {
                return this;
            }

            if (!this.ready) {
                this.build();

                if (this.ready) {
                    this.show(immediate);
                }
                //lazy load function
                // $('.viewerLzyImg').Lazy();
                return this;
            }

            if (isFunction(options.show)) {
                addListener(element, EVENT_SHOW, options.show, {
                    once: true
                });
            }

            if (dispatchEvent(element, EVENT_SHOW) === false || !this.ready) {
                return this;
            }

            if (this.hiding) {
                this.transitioning.abort();
            }

            this.showing = true;
            this.open();
            var viewer = this.viewer;
            removeClass(viewer, CLASS_HIDE);

            if (options.transition && !immediate) {
                var shown = this.shown.bind(this);
                this.transitioning = {
                    abort: function abort() {
                        removeListener(viewer, EVENT_TRANSITION_END, shown);
                        removeClass(viewer, CLASS_IN);
                    }
                };
                addClass(viewer, CLASS_TRANSITION); // Force reflow to enable CSS3 transition

                viewer.initialOffsetWidth = viewer.offsetWidth;
                addListener(viewer, EVENT_TRANSITION_END, shown, {
                    once: true
                });
                addClass(viewer, CLASS_IN);
            } else {
                addClass(viewer, CLASS_IN);
                this.shown();
            }

            return this;
        },

        /**
         * Hide the viewer (only available in modal mode)
         * @param {boolean} [immediate=false] - Indicates if hide the viewer immediately or not.
         * @returns {Viewer} this
         */
        hide: function hide() {
            var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var element = this.element,
                options = this.options;

            if (options.inline || this.hiding || !(this.isShown || this.showing)) {
                return this;
            }

            if (isFunction(options.hide)) {
                addListener(element, EVENT_HIDE, options.hide, {
                    once: true
                });
            }

            if (dispatchEvent(element, EVENT_HIDE) === false) {
                return this;
            }

            if (this.showing) {
                this.transitioning.abort();
            }

            this.hiding = true;

            if (this.played) {
                this.stop();
            } else if (this.viewing) {
                this.viewing.abort();
            }

            var viewer = this.viewer;

            if (options.transition && !immediate) {
                var hidden = this.hidden.bind(this);

                var hide = function hide() {
                    // XXX: It seems the `event.stopPropagation()` method does not work here
                    setTimeout(function () {
                        addListener(viewer, EVENT_TRANSITION_END, hidden, {
                            once: true
                        });
                        removeClass(viewer, CLASS_IN);
                    }, 0);
                };

                this.transitioning = {
                    abort: function abort() {
                        if (this.viewed) {
                            removeListener(this.image, EVENT_TRANSITION_END, hide);
                        } else {
                            removeListener(viewer, EVENT_TRANSITION_END, hidden);
                        }
                    }
                }; // Note that the `CLASS_TRANSITION` class will be removed on pointer down (#255)

                if (this.viewed && hasClass(this.image, CLASS_TRANSITION)) {
                    addListener(this.image, EVENT_TRANSITION_END, hide, {
                        once: true
                    });
                    this.zoomTo(0, false, false, true);
                } else {
                    hide();
                }
            } else {
                removeClass(viewer, CLASS_IN);
                this.hidden();
            }

            return this;
        },

        /**
         * View one of the images with image's index
         * @param {number} index - The index of the image to view.
         * @returns {Viewer} this
         */
        view: function view() {
            var _this = this;

            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.initialViewIndex;
            index = Number(index) || 0;

            if (this.hiding || this.played || index < 0 || index >= this.length || this.viewed && index === this.index) {
                return this;
            }

            if (!this.isShown) {
                this.index = index;
                return this.show();
            }

            if (this.viewing) {
                this.viewing.abort();
            }

            var element = this.element,
                options = this.options,
                title = this.title,
                canvas = this.canvas;
            var item = this.items[index];
            var img = item.querySelector('img');
            var url = getData(img, 'originalUrl');
            var alt = img.getAttribute('alt');
            var image = document.createElement('img');
            image.src = url;
            image.alt = alt;
            image.setAttribute("class", "lzyCanvasimg");


            image.dtls = img.getAttribute('dtls');;

            if (isFunction(options.view)) {
                addListener(element, EVENT_VIEW, options.view, {
                    once: true
                });
            }

            if (dispatchEvent(element, EVENT_VIEW, {
                originalImage: this.images[index],
                index: index,
                image: image
            }) === false || !this.isShown || this.hiding || this.played) {
                return this;
            }

            this.image = image;
            removeClass(this.items[this.index], CLASS_ACTIVE);
            addClass(item, CLASS_ACTIVE);
            this.viewed = false;
            this.index = index;
            this.imageData = {};
            addClass(image, CLASS_INVISIBLE);

            if (options.loading) {
                addClass(canvas, CLASS_LOADING);
            }

            canvas.innerHTML = '';
            canvas.appendChild(image); // Center current item

            this.renderList(); // Clear title

            title.innerHTML = ''; // Generate title after viewed

            var onViewed = function onViewed() {
                var imageData = _this.imageData;
                var render = Array.isArray(options.title) ? options.title[1] : options.title;
                title.innerHTML = escapeHTMLEntities(isFunction(render) ? render.call(_this, image, imageData) : "".concat(alt, " (").concat(imageData.naturalWidth, " \xD7 ").concat(imageData.naturalHeight, ")"));
            };

            var onLoad;
            addListener(element, EVENT_VIEWED, onViewed, {
                once: true
            });
            this.viewing = {
                abort: function abort() {
                    removeListener(element, EVENT_VIEWED, onViewed);

                    if (image.complete) {
                        if (this.imageRendering) {
                            this.imageRendering.abort();
                        } else if (this.imageInitializing) {
                            this.imageInitializing.abort();
                        }
                    } else {
                        // Cancel download to save bandwidth.
                        image.src = '';
                        removeListener(image, EVENT_LOAD, onLoad);

                        if (this.timeout) {
                            clearTimeout(this.timeout);
                        }
                    }
                }
            };

            if (image.complete) {
                this.load();
            } else {
                addListener(image, EVENT_LOAD, onLoad = this.load.bind(this), {
                    once: true
                });

                if (this.timeout) {
                    clearTimeout(this.timeout);
                } // Make the image visible if it fails to load within 1s


                this.timeout = setTimeout(function () {
                    removeClass(image, CLASS_INVISIBLE);
                    _this.timeout = false;
                }, 1000);
            }

            return this;
        },

        /**
         * View the previous image
         * @param {boolean} [loop=false] - Indicate if view the last one
         * when it is the first one at present.
         * @returns {Viewer} this
         */
        prev: function prev() {
            var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var index = this.index - 1;

            if (index < 0) {
                index = loop ? this.length - 1 : 0;
            }

            this.view(index);
            return this;
        },

        /**
         * View the next image
         * @param {boolean} [loop=false] - Indicate if view the first one
         * when it is the last one at present.
         * @returns {Viewer} this
         */
        next: function next() {
            var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var maxIndex = this.length - 1;
            var index = this.index + 1;

            if (index > maxIndex) {
                index = loop ? 0 : maxIndex;
            }

            this.view(index);
            return this;
        },

        /**
         * Move the image with relative offsets.
         * @param {number} offsetX - The relative offset distance on the x-axis.
         * @param {number} offsetY - The relative offset distance on the y-axis.
         * @returns {Viewer} this
         */
        move: function move(offsetX, offsetY) {
            var imageData = this.imageData;
            this.moveTo(isUndefined(offsetX) ? offsetX : imageData.left + Number(offsetX), isUndefined(offsetY) ? offsetY : imageData.top + Number(offsetY));
            return this;
        },

        /**
         * Move the image to an absolute point.
         * @param {number} x - The x-axis coordinate.
         * @param {number} [y=x] - The y-axis coordinate.
         * @returns {Viewer} this
         */
        moveTo: function moveTo(x) {
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
            var imageData = this.imageData;
            x = Number(x);
            y = Number(y);

            if (this.viewed && !this.played && this.options.movable) {
                var changed = false;

                if (isNumber(x)) {
                    imageData.left = x;
                    changed = true;
                }

                if (isNumber(y)) {
                    imageData.top = y;
                    changed = true;
                }

                if (changed) {
                    this.renderImage();
                }
            }

            return this;
        },

        /**
         * Zoom the image with a relative ratio.
         * @param {number} ratio - The target ratio.
         * @param {boolean} [hasTooltip=false] - Indicates if it has a tooltip or not.
         * @param {Event} [_originalEvent=null] - The original event if any.
         * @returns {Viewer} this
         */
        zoom: function zoom(ratio) {
            var hasTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var _originalEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            var imageData = this.imageData;
            ratio = Number(ratio);

            if (ratio < 0) {
                ratio = 1 / (1 - ratio);
            } else {
                ratio = 1 + ratio;
            }

            this.zoomTo(imageData.width * ratio / imageData.naturalWidth, hasTooltip, _originalEvent);
            return this;
        },

        /**
         * Zoom the image to an absolute ratio.
         * @param {number} ratio - The target ratio.
         * @param {boolean} [hasTooltip=false] - Indicates if it has a tooltip or not.
         * @param {Event} [_originalEvent=null] - The original event if any.
         * @param {Event} [_zoomable=false] - Indicates if the current zoom is available or not.
         * @returns {Viewer} this
         */
        zoomTo: function zoomTo(ratio) {
            var _this2 = this;

            var hasTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var _originalEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            var _zoomable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

            var element = this.element,
                options = this.options,
                pointers = this.pointers,
                imageData = this.imageData;
            var width = imageData.width,
                height = imageData.height,
                left = imageData.left,
                top = imageData.top,
                naturalWidth = imageData.naturalWidth,
                naturalHeight = imageData.naturalHeight;
            ratio = Math.max(0, ratio);

            if (isNumber(ratio) && this.viewed && !this.played && (_zoomable || options.zoomable)) {
                if (!_zoomable) {
                    var minZoomRatio = Math.max(0.01, options.minZoomRatio);
                    var maxZoomRatio = Math.min(100, options.maxZoomRatio);
                    ratio = Math.min(Math.max(ratio, minZoomRatio), maxZoomRatio);
                }

                if (_originalEvent && ratio > 0.95 && ratio < 1.05) {
                    ratio = 1;
                }

                var newWidth = naturalWidth * ratio;
                var newHeight = naturalHeight * ratio;
                var offsetWidth = newWidth - width;
                var offsetHeight = newHeight - height;
                var oldRatio = width / naturalWidth;

                if (isFunction(options.zoom)) {
                    addListener(element, EVENT_ZOOM, options.zoom, {
                        once: true
                    });
                }

                if (dispatchEvent(element, EVENT_ZOOM, {
                    ratio: ratio,
                    oldRatio: oldRatio,
                    originalEvent: _originalEvent
                }) === false) {
                    return this;
                }

                this.zooming = true;

                if (_originalEvent) {
                    var offset = getOffset(this.viewer);
                    var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
                        pageX: _originalEvent.pageX,
                        pageY: _originalEvent.pageY
                    }; // Zoom from the triggering point of the event

                    imageData.left -= offsetWidth * ((center.pageX - offset.left - left) / width);
                    imageData.top -= offsetHeight * ((center.pageY - offset.top - top) / height);
                } else {
                    // Zoom from the center of the image
                    imageData.left -= offsetWidth / 2;
                    imageData.top -= offsetHeight / 2;
                }

                imageData.width = newWidth;
                imageData.height = newHeight;
                imageData.ratio = ratio;
                this.renderImage(function () {
                    _this2.zooming = false;

                    if (isFunction(options.zoomed)) {
                        addListener(element, EVENT_ZOOMED, options.zoomed, {
                            once: true
                        });
                    }

                    dispatchEvent(element, EVENT_ZOOMED, {
                        ratio: ratio,
                        oldRatio: oldRatio,
                        originalEvent: _originalEvent
                    });
                });

                if (hasTooltip) {
                    this.tooltip();
                }
            }

            return this;
        },

        /**
         * Rotate the image with a relative degree.
         * @param {number} degree - The rotate degree.
         * @returns {Viewer} this
         */
        rotate: function rotate(degree) {
            this.rotateTo((this.imageData.rotate || 0) + Number(degree));
            return this;
        },

        /**
         * Rotate the image to an absolute degree.
         * @param {number} degree - The rotate degree.
         * @returns {Viewer} this
         */
        rotateTo: function rotateTo(degree) {
            var imageData = this.imageData;
            degree = Number(degree);

            if (isNumber(degree) && this.viewed && !this.played && this.options.rotatable) {
                imageData.rotate = degree;
                this.renderImage();
            }

            return this;
        },

        /**
         * Scale the image on the x-axis.
         * @param {number} scaleX - The scale ratio on the x-axis.
         * @returns {Viewer} this
         */
        scaleX: function scaleX(_scaleX) {
            this.scale(_scaleX, this.imageData.scaleY);
            return this;
        },

        /**
         * Scale the image on the y-axis.
         * @param {number} scaleY - The scale ratio on the y-axis.
         * @returns {Viewer} this
         */
        scaleY: function scaleY(_scaleY) {
            this.scale(this.imageData.scaleX, _scaleY);
            return this;
        },

        /**
         * Scale the image.
         * @param {number} scaleX - The scale ratio on the x-axis.
         * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
         * @returns {Viewer} this
         */
        scale: function scale(scaleX) {
            var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
            var imageData = this.imageData;
            scaleX = Number(scaleX);
            scaleY = Number(scaleY);

            if (this.viewed && !this.played && this.options.scalable) {
                var changed = false;

                if (isNumber(scaleX)) {
                    imageData.scaleX = scaleX;
                    changed = true;
                }

                if (isNumber(scaleY)) {
                    imageData.scaleY = scaleY;
                    changed = true;
                }

                if (changed) {
                    this.renderImage();
                }
            }

            return this;
        },

        /**
         * Play the images
         * @param {boolean} [fullscreen=false] - Indicate if request fullscreen or not.
         * @returns {Viewer} this
         */
        play: function play() {
            var _this3 = this;

            var fullscreen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!this.isShown || this.played) {
                return this;
            }

            var options = this.options,
                player = this.player;
            var onLoad = this.loadImage.bind(this);
            var list = [];
            var total = 0;
            var index = 0;
            this.played = true;
            this.onLoadWhenPlay = onLoad;

            if (fullscreen) {
                this.requestFullscreen();
            }
            //comment usage here
            addClass(player, CLASS_SHOW);
            forEach(this.items, function (item, i) {
                var img = item.querySelector('img');
                var image = document.createElement('img');
                image.src = getData(img, 'originalUrl');
                image.alt = img.getAttribute('alt');
                //   image.dtls = img.getAttribute('dtls');
                total += 1;
                addClass(image, CLASS_FADE);
                toggleClass(image, CLASS_TRANSITION, options.transition);

                if (hasClass(item, CLASS_ACTIVE)) {
                    addClass(image, CLASS_IN);
                    index = i;
                }

                list.push(image);
                addListener(image, EVENT_LOAD, onLoad, {
                    once: true
                });
                player.appendChild(image);
            });

            if (isNumber(options.interval) && options.interval > 0) {
                var play = function play() {
                    _this3.playing = setTimeout(function () {
                        removeClass(list[index], CLASS_IN);
                        index += 1;
                        index = index < total ? index : 0;
                        addClass(list[index], CLASS_IN);
                        play();
                    }, options.interval);
                };

                if (total > 1) {
                    play();
                }
            }

            return this;
        },
        // Stop play
        stop: function stop() {
            var _this4 = this;

            if (!this.played) {
                return this;
            }

            var player = this.player;
            this.played = false;
            clearTimeout(this.playing);
            forEach(player.getElementsByTagName('img'), function (image) {
                removeListener(image, EVENT_LOAD, _this4.onLoadWhenPlay);
            });
            removeClass(player, CLASS_SHOW);
            player.innerHTML = '';
            this.exitFullscreen();
            return this;
        },
        // Enter modal mode (only available in inline mode)
        full: function full() {
            var _this5 = this;

            var options = this.options,
                viewer = this.viewer,
                image = this.image,
                list = this.list;

            if (!this.isShown || this.played || this.fulled || !options.inline) {
                return this;
            }

            this.fulled = true;
            this.open();
            addClass(this.button, CLASS_FULLSCREEN_EXIT);

            if (options.transition) {
                removeClass(list, CLASS_TRANSITION);

                if (this.viewed) {
                    removeClass(image, CLASS_TRANSITION);
                }
            }

            addClass(viewer, CLASS_FIXED);
            viewer.setAttribute('style', '');
            setStyle(viewer, {
                zIndex: options.zIndex
            });
            this.initContainer();
            this.viewerData = assign({}, this.containerData);
            this.renderList();

            if (this.viewed) {
                this.initImage(function () {
                    _this5.renderImage(function () {
                        if (options.transition) {
                            setTimeout(function () {
                                addClass(image, CLASS_TRANSITION);
                                addClass(list, CLASS_TRANSITION);
                            }, 0);
                        }
                    });
                });
            }

            return this;
        },
        // Exit modal mode (only available in inline mode)
        exit: function exit() {
            var _this6 = this;

            var options = this.options,
                viewer = this.viewer,
                image = this.image,
                list = this.list;

            if (!this.isShown || this.played || !this.fulled || !options.inline) {
                return this;
            }

            this.fulled = false;
            this.close();
            removeClass(this.button, CLASS_FULLSCREEN_EXIT);

            if (options.transition) {
                removeClass(list, CLASS_TRANSITION);

                if (this.viewed) {
                    removeClass(image, CLASS_TRANSITION);
                }
            }

            removeClass(viewer, CLASS_FIXED);
            setStyle(viewer, {
                zIndex: options.zIndexInline
            });
            this.viewerData = assign({}, this.parentData);
            this.renderViewer();
            this.renderList();

            if (this.viewed) {
                this.initImage(function () {
                    _this6.renderImage(function () {
                        if (options.transition) {
                            setTimeout(function () {
                                addClass(image, CLASS_TRANSITION);
                                addClass(list, CLASS_TRANSITION);
                            }, 0);
                        }
                    });
                });
            }

            return this;
        },
        // Show the current ratio of the image with percentage
        tooltip: function tooltip() {
            var _this7 = this;

            var options = this.options,
                tooltipBox = this.tooltipBox,
                imageData = this.imageData;

            if (!this.viewed || this.played || !options.tooltip) {
                return this;
            }

            tooltipBox.textContent = "".concat(Math.round(imageData.ratio * 100), "%");

            if (!this.tooltipping) {
                if (options.transition) {
                    if (this.fading) {
                        dispatchEvent(tooltipBox, EVENT_TRANSITION_END);
                    }

                    addClass(tooltipBox, CLASS_SHOW);
                    addClass(tooltipBox, CLASS_FADE);
                    addClass(tooltipBox, CLASS_TRANSITION); // Force reflow to enable CSS3 transition

                    tooltipBox.initialOffsetWidth = tooltipBox.offsetWidth;
                    addClass(tooltipBox, CLASS_IN);
                } else {
                    addClass(tooltipBox, CLASS_SHOW);
                }
            } else {
                clearTimeout(this.tooltipping);
            }

            this.tooltipping = setTimeout(function () {
                if (options.transition) {
                    addListener(tooltipBox, EVENT_TRANSITION_END, function () {
                        removeClass(tooltipBox, CLASS_SHOW);
                        removeClass(tooltipBox, CLASS_FADE);
                        removeClass(tooltipBox, CLASS_TRANSITION);
                        _this7.fading = false;
                    }, {
                        once: true
                    });
                    removeClass(tooltipBox, CLASS_IN);
                    _this7.fading = true;
                } else {
                    removeClass(tooltipBox, CLASS_SHOW);
                }

                _this7.tooltipping = false;
            }, 1000);
            return this;
        },
        // Toggle the image size between its natural size and initial size
        toggle: function toggle() {
            if (this.imageData.ratio === 1) {
                this.zoomTo(this.initialImageData.ratio, true);
            } else {
                this.zoomTo(1, true);
            }

            return this;
        },

        // Reset the image to its initial state
        reset: function reset() {
            if (this.viewed && !this.played) {
                this.imageData = assign({}, this.initialImageData);
                this.renderImage();
            }

            return this;
        },

        //for image information
        info: function info() {
            if (this.infono) {
                //if (!(this.image.dtls === ""))
                //    $(".viewer-canvas").append(`<div class='imgDetail'><h5>${this.image.dtls}</h5></div>`);
                let indx = this.index;
                var obj = this.$images[indx];
                if (!(Object.keys(obj).length == 0)) {

                    var ky = "";
                    $(".viewer-footer").prepend(`<div class='imgDetail'></div>`);
                    Object.entries(obj).forEach(([key, value]) => {

                        ky = key + " : " + value.values().next().value;
                        $(".imgDetail").append(`<P>${ky}</P>`);
                    })
                }
                this.infono = 0;
            } else {
                imgdivremove();
                this.infono = 1;
            }
        },

        //for image download
        download: function download() {
            const a = $("<a>").attr("href", `${this.image.src}`)
                .attr("download", "")
                .appendTo("body");
            a[0].click();
            a.remove();
        },

        //for printing file
        print: function print() {
            let win = window.open('');
            win.document.write(`<img src=${this.image.src} onload="window.print();window.close()" />`);
            win.focus();
        },

        // Update viewer when images changed
        update: function update() {
            var element = this.element,
                options = this.options,
                isImg = this.isImg; // Destroy viewer if the target image was deleted

            if (isImg && !element.parentNode) {
                return this.destroy();
            }

            var images = [];
            forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {
                if (options.filter) {
                    if (options.filter(image)) {
                        images.push(image);
                    }
                } else {
                    images.push(image);
                }
            });

            if (!images.length) {
                return this;
            }

            this.images = images;
            this.length = images.length;

            if (this.ready) {
                var indexes = [];
                forEach(this.items, function (item, i) {
                    var img = item.querySelector('img');
                    var image = images[i];

                    if (image && img) {
                        if (image.src !== img.src) {
                            indexes.push(i);
                        }
                    } else {
                        indexes.push(i);
                    }
                });
                setStyle(this.list, {
                    width: 'auto'
                });
                this.initList();

                if (this.isShown) {
                    if (this.length) {
                        if (this.viewed) {
                            var index = indexes.indexOf(this.index);

                            if (index >= 0) {
                                this.viewed = false;
                                this.view(Math.max(this.index - (index + 1), 0));
                            } else {
                                addClass(this.items[this.index], CLASS_ACTIVE);
                            }
                        }
                    } else {
                        this.image = null;
                        this.viewed = false;
                        this.index = 0;
                        this.imageData = {};
                        this.canvas.innerHTML = '';
                        this.title.innerHTML = '';
                    }
                }
            } else {
                this.build();
            }

            return this;
        },
        // Destroy the viewer
        destroy: function destroy() {
            var element = this.element,
                options = this.options;

            if (!element[NAMESPACE]) {
                return this;
            }

            this.destroyed = true;

            if (this.ready) {
                if (this.played) {
                    this.stop();
                }

                if (options.inline) {
                    if (this.fulled) {
                        this.exit();
                    }

                    this.unbind();
                } else if (this.isShown) {
                    if (this.viewing) {
                        if (this.imageRendering) {
                            this.imageRendering.abort();
                        } else if (this.imageInitializing) {
                            this.imageInitializing.abort();
                        }
                    }

                    if (this.hiding) {
                        this.transitioning.abort();
                    }

                    this.hidden();
                } else if (this.showing) {
                    this.transitioning.abort();
                    this.hidden();
                }

                this.ready = false;
                this.viewer.parentNode.removeChild(this.viewer);
            } else if (options.inline) {
                if (this.delaying) {
                    this.delaying.abort();
                } else if (this.initializing) {
                    this.initializing.abort();
                }
            }

            if (!options.inline) {
                removeListener(element, EVENT_CLICK, this.onStart);
            }

            element[NAMESPACE] = undefined;
            return this;
        }
    };

    var others = {
        open: function open() {
            var body = this.body;
            addClass(body, CLASS_OPEN);
            body.style.paddingRight = "".concat(this.scrollbarWidth + (parseFloat(this.initialBodyPaddingRight) || 0), "px");
        },
        close: function close() {
            var body = this.body;
            removeClass(body, CLASS_OPEN);
            body.style.paddingRight = this.initialBodyPaddingRight;
        },
        shown: function shown() {
            var element = this.element,
                options = this.options;
            this.fulled = true;
            this.isShown = true;
            this.render();
            this.bind();
            this.showing = false;

            if (isFunction(options.shown)) {
                addListener(element, EVENT_SHOWN, options.shown, {
                    once: true
                });
            }

            if (dispatchEvent(element, EVENT_SHOWN) === false) {
                return;
            }

            if (this.ready && this.isShown && !this.hiding) {
                this.view(this.index);
            }
        },
        hidden: function hidden() {
            var element = this.element,
                options = this.options;
            this.fulled = false;
            this.viewed = false;
            this.isShown = false;
            this.close();
            this.unbind();
            addClass(this.viewer, CLASS_HIDE);
            this.resetList();
            this.resetImage();
            this.hiding = false;

            if (!this.destroyed) {
                if (isFunction(options.hidden)) {
                    addListener(element, EVENT_HIDDEN, options.hidden, {
                        once: true
                    });
                }

                dispatchEvent(element, EVENT_HIDDEN);
            }
        },
        requestFullscreen: function requestFullscreen() {
            var document = this.element.ownerDocument;

            if (this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
                var documentElement = document.documentElement; // Element.requestFullscreen()

                if (documentElement.requestFullscreen) {
                    documentElement.requestFullscreen();
                } else if (documentElement.webkitRequestFullscreen) {
                    documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                } else if (documentElement.mozRequestFullScreen) {
                    documentElement.mozRequestFullScreen();
                } else if (documentElement.msRequestFullscreen) {
                    documentElement.msRequestFullscreen();
                }
            }
        },
        exitFullscreen: function exitFullscreen() {
            var document = this.element.ownerDocument;

            if (this.fulled && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
                // Document.exitFullscreen()
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        },
        change: function change(event) {
            var options = this.options,
                pointers = this.pointers;
            var pointer = pointers[Object.keys(pointers)[0]];
            var offsetX = pointer.endX - pointer.startX;
            var offsetY = pointer.endY - pointer.startY;

            switch (this.action) {
                // Move the current image
                case ACTION_MOVE:
                    this.move(offsetX, offsetY);
                    break;
                // Zoom the current image

                case ACTION_ZOOM:
                    this.zoom(getMaxZoomRatio(pointers), false, event);
                    break;

                case ACTION_SWITCH:
                    {
                        this.action = 'switched';
                        var absoluteOffsetX = Math.abs(offsetX);

                        if (absoluteOffsetX > 1 && absoluteOffsetX > Math.abs(offsetY)) {
                            // Empty `pointers` as `touchend` event will not be fired after swiped in iOS browsers.
                            this.pointers = {};

                            if (offsetX > 1) {
                                this.prev(options.loop);
                            } else if (offsetX < -1) {
                                this.next(options.loop);
                            }
                        }

                        break;
                    }
            } // Override


            forEach(pointers, function (p) {
                p.startX = p.endX;
                p.startY = p.endY;
            });
        },
        isSwitchable: function isSwitchable() {
            var imageData = this.imageData,
                viewerData = this.viewerData;
            return this.length > 1 && imageData.left >= 0 && imageData.top >= 0 && imageData.width <= viewerData.width && imageData.height <= viewerData.height;
        }
    };

    var AnotherViewer = WINDOW.Viewer;

    var Viewer =
        /*#__PURE__*/
        function () {
            /**
             * Create a new Viewer.
             * @param {Element} element - The target element for viewing.
             * @param {Object} [options={}] - The configuration options.
             */
            function Viewer(element) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                _classCallCheck(this, Viewer);

                if (!element || element.nodeType !== 1) {
                    throw new Error('The first argument is required and must be an element.');
                }
                this.infono = 1;
                this.element = element;
                this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
                this.action = false;
                this.fading = false;
                this.fulled = false;
                this.hiding = false;
                this.imageClicked = false;
                this.imageData = {};
                this.index = this.options.initialViewIndex;
                this.isImg = false;
                this.isShown = false;
                this.length = 0;
                this.played = false;
                this.playing = false;
                this.pointers = {};
                this.ready = false;
                this.showing = false;
                this.timeout = false;
                this.tooltipping = false;
                this.viewed = false;
                this.viewing = false;
                this.wheeling = false;
                this.zooming = false;
                this.init();
            }

            _createClass(Viewer, [{
                key: "init",
                value: function init() {
                    var _this = this;

                    var element = this.element,
                        options = this.options;

                    if (element[NAMESPACE]) {
                        return;
                    }

                    element[NAMESPACE] = this;
                    var isImg = element.tagName.toLowerCase() === 'img';
                    var images = [];
                    var $imgarr = [];
                    forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {
                        if (isFunction(options.filter)) {
                            if (options.filter.call(_this, image)) {
                                images.push(image);
                                $imgarr.push($(image));
                            }
                        } else {
                            images.push(image);
                            $imgarr.push($(image).data("details"));
                        }
                    });
                    this.isImg = isImg;
                    this.length = images.length;
                    this.images = images;
                    // this.$images - to store .data(), ie meta from ebfileviewerplugin to use in info click
                    this.$images = $imgarr;
                    var ownerDocument = element.ownerDocument;
                    var body = ownerDocument.body || ownerDocument.documentElement;
                    this.body = body;
                    this.scrollbarWidth = window.innerWidth - ownerDocument.documentElement.clientWidth;
                    this.initialBodyPaddingRight = window.getComputedStyle(body).paddingRight; // Override `transition` option if it is not supported

                    if (isUndefined(document.createElement(NAMESPACE).style.transition)) {
                        options.transition = false;
                    }

                    if (options.inline) {
                        var count = 0;

                        var progress = function progress() {
                            count += 1;

                            if (count === _this.length) {
                                var timeout;
                                _this.initializing = false;
                                _this.delaying = {
                                    abort: function abort() {
                                        clearTimeout(timeout);
                                    }
                                }; // build asynchronously to keep `this.viewer` is accessible in `ready` event handler.

                                timeout = setTimeout(function () {
                                    _this.delaying = false;

                                    _this.build();
                                }, 0);
                            }
                        };

                        this.initializing = {
                            abort: function abort() {
                                forEach(images, function (image) {
                                    if (!image.complete) {
                                        removeListener(image, EVENT_LOAD, progress);
                                    }
                                });
                            }
                        };
                        forEach(images, function (image) {
                            if (image.complete) {
                                progress();
                            } else {
                                addListener(image, EVENT_LOAD, progress, {
                                    once: true
                                });
                            }
                        });
                    } else {
                        addListener(element, EVENT_CLICK, this.onStart = function (_ref) {
                            var target = _ref.target;

                            if (target.tagName.toLowerCase() === 'img' && (!isFunction(options.filter) || options.filter.call(_this, target))) {
                                _this.view(_this.images.indexOf(target));
                            }
                        });
                    }
                }
            }, {
                key: "build",
                value: function build() {
                    if (this.ready) {
                        return;
                    }

                    var element = this.element,
                        options = this.options;
                    var parent = element.parentNode;
                    var template = document.createElement('div');
                    template.innerHTML = TEMPLATE;
                    var viewer = template.querySelector(".".concat(NAMESPACE, "-container"));
                    var title = viewer.querySelector(".".concat(NAMESPACE, "-title"));
                    var toolbar = viewer.querySelector(".".concat(NAMESPACE, "-toolbar"));
                    var navbar = viewer.querySelector(".".concat(NAMESPACE, "-navbar"));
                    var button = viewer.querySelector(".".concat(NAMESPACE, "-button"));
                    var canvas = viewer.querySelector(".".concat(NAMESPACE, "-canvas"));
                    this.parent = parent;
                    this.viewer = viewer;
                    this.title = title;
                    this.toolbar = toolbar;
                    this.navbar = navbar;
                    this.button = button;
                    this.canvas = canvas;
                    this.footer = viewer.querySelector(".".concat(NAMESPACE, "-footer"));
                    this.tooltipBox = viewer.querySelector(".".concat(NAMESPACE, "-tooltip"));
                    this.player = viewer.querySelector(".".concat(NAMESPACE, "-player"));
                    this.list = viewer.querySelector(".".concat(NAMESPACE, "-list"));
                    addClass(title, !options.title ? CLASS_HIDE : getResponsiveClass(Array.isArray(options.title) ? options.title[0] : options.title));
                    addClass(navbar, !options.navbar ? CLASS_HIDE : getResponsiveClass(options.navbar));
                    toggleClass(button, CLASS_HIDE, !options.button);

                    if (options.backdrop) {
                        addClass(viewer, "".concat(NAMESPACE, "-backdrop"));

                        if (!options.inline && options.backdrop !== 'static') {
                            setData(canvas, DATA_ACTION, 'hide');
                        }
                    }

                    if (isString(options.className) && options.className) {
                        // In case there are multiple class names
                        options.className.split(REGEXP_SPACES).forEach(function (className) {
                            addClass(viewer, className);
                        });
                    }

                    if (options.toolbar) {
                        var list = document.createElement('ul');
                        var custom = isPlainObject(options.toolbar);
                        var zoomButtons = BUTTONS.slice(0, 3);
                        var rotateButtons = BUTTONS.slice(7, 9);
                        var scaleButtons = BUTTONS.slice(9);

                        if (!custom) {
                            addClass(toolbar, getResponsiveClass(options.toolbar));
                        }

                        forEach(custom ? options.toolbar : BUTTONS, function (value, index) {
                            var deep = custom && isPlainObject(value);
                            var name = custom ? hyphenate(index) : value;
                            var show = deep && !isUndefined(value.show) ? value.show : value;

                            if (!show || !options.zoomable && zoomButtons.indexOf(name) !== -1 || !options.rotatable && rotateButtons.indexOf(name) !== -1 || !options.scalable && scaleButtons.indexOf(name) !== -1) {
                                return;
                            }

                            var size = deep && !isUndefined(value.size) ? value.size : value;
                            var click = deep && !isUndefined(value.click) ? value.click : value;
                            var item = document.createElement('li');
                            item.setAttribute('role', 'button');
                            item.setAttribute('title', name);
                            addClass(item, "".concat(NAMESPACE, "-").concat(name));

                            if (!isFunction(click)) {
                                setData(item, DATA_ACTION, name);
                            }

                            if (isNumber(show)) {
                                addClass(item, getResponsiveClass(show));
                            }

                            if (['small', 'large'].indexOf(size) !== -1) {
                                addClass(item, "".concat(NAMESPACE, "-").concat(size));
                            } else if (name === 'play') {
                                addClass(item, "".concat(NAMESPACE, "-large"));
                            }

                            if (isFunction(click)) {
                                addListener(item, EVENT_CLICK, click);
                            }

                            list.appendChild(item);
                        });
                        toolbar.appendChild(list);
                    } else {
                        addClass(toolbar, CLASS_HIDE);
                    }

                    if (!options.rotatable) {
                        var rotates = toolbar.querySelectorAll('li[class*="rotate"]');
                        addClass(rotates, CLASS_INVISIBLE);
                        forEach(rotates, function (rotate) {
                            toolbar.appendChild(rotate);
                        });
                    }

                    if (options.inline) {
                        addClass(button, CLASS_FULLSCREEN);
                        setStyle(viewer, {
                            zIndex: options.zIndexInline
                        });

                        if (window.getComputedStyle(parent).position === 'static') {
                            setStyle(parent, {
                                position: 'relative'
                            });
                        }

                        parent.insertBefore(viewer, element.nextSibling);
                    } else {
                        addClass(button, CLASS_CLOSE);
                        addClass(viewer, CLASS_FIXED);
                        addClass(viewer, CLASS_FADE);
                        addClass(viewer, CLASS_HIDE);
                        setStyle(viewer, {
                            zIndex: options.zIndex
                        });
                        var container = options.container;

                        if (isString(container)) {
                            container = element.ownerDocument.querySelector(container);
                        }

                        if (!container) {
                            container = this.body;
                        }

                        container.appendChild(viewer);
                    }

                    if (options.inline) {
                        this.render();
                        this.bind();
                        this.isShown = true;
                    }

                    this.ready = true;

                    if (isFunction(options.ready)) {
                        addListener(element, EVENT_READY, options.ready, {
                            once: true
                        });
                    }

                    if (dispatchEvent(element, EVENT_READY) === false) {
                        this.ready = false;
                        return;
                    }

                    if (this.ready && options.inline) {
                        this.view(this.index);
                    }
                }
                /**
                 * Get the no conflict viewer class.
                 * @returns {Viewer} The viewer class.
                 */

            }], [{
                key: "noConflict",
                value: function noConflict() {
                    window.Viewer = AnotherViewer;
                    return Viewer;
                }
                /**
                 * Change the default options.
                 * @param {Object} options - The new default options.
                 */

            }, {
                key: "setDefaults",
                value: function setDefaults(options) {
                    assign(DEFAULTS, isPlainObject(options) && options);
                }
            }]);

            return Viewer;
        }();

    assign(Viewer.prototype, render, events, handlers, methods, others);

    return Viewer;

})));

/*
 * International Telephone Input v17.0.3
 * https://github.com/jackocnr/intl-tel-input.git
 * Licensed under the MIT license
 */

// wrap in UMD
(function (factory) {
    if (typeof module === "object" && module.exports) module.exports = factory(); else window.intlTelInput = factory();
})(function (undefined) {
    "use strict";
    return function () {
        // Array of country objects for the flag dropdown.
        // Here is the criteria for the plugin to support a given country/territory
        // - It has an iso2 code: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
        // - It has it's own country calling code (it is not a sub-region of another country): https://en.wikipedia.org/wiki/List_of_country_calling_codes
        // - It has a flag in the region-flags project: https://github.com/behdad/region-flags/tree/gh-pages/png
        // - It is supported by libphonenumber (it must be listed on this page): https://github.com/googlei18n/libphonenumber/blob/master/resources/ShortNumberMetadata.xml
        // Each country array has the following information:
        // [
        //    Country name,
        //    iso2 code,
        //    International dial code,
        //    Order (if >1 country with same dial code),
        //    Area codes
        // ]
        var allCountries = [["Afghanistan ()", "af", "93"], ["Albania (Shqipri)", "al", "355"], ["Algeria ()", "dz", "213"], ["American Samoa", "as", "1", 5, ["684"]], ["Andorra", "ad", "376"], ["Angola", "ao", "244"], ["Anguilla", "ai", "1", 6, ["264"]], ["Antigua and Barbuda", "ag", "1", 7, ["268"]], ["Argentina", "ar", "54"], ["Armenia ()", "am", "374"], ["Aruba", "aw", "297"], ["Australia", "au", "61", 0], ["Austria (sterreich)", "at", "43"], ["Azerbaijan (Azrbaycan)", "az", "994"], ["Bahamas", "bs", "1", 8, ["242"]], ["Bahrain ()", "bh", "973"], ["Bangladesh ()", "bd", "880"], ["Barbados", "bb", "1", 9, ["246"]], ["Belarus ()", "by", "375"], ["Belgium (Belgi)", "be", "32"], ["Belize", "bz", "501"], ["Benin (Bnin)", "bj", "229"], ["Bermuda", "bm", "1", 10, ["441"]], ["Bhutan ()", "bt", "975"], ["Bolivia", "bo", "591"], ["Bosnia and Herzegovina (  )", "ba", "387"], ["Botswana", "bw", "267"], ["Brazil (Brasil)", "br", "55"], ["British Indian Ocean Territory", "io", "246"], ["British Virgin Islands", "vg", "1", 11, ["284"]], ["Brunei", "bn", "673"], ["Bulgaria ()", "bg", "359"], ["Burkina Faso", "bf", "226"], ["Burundi (Uburundi)", "bi", "257"], ["Cambodia ()", "kh", "855"], ["Cameroon (Cameroun)", "cm", "237"], ["Canada", "ca", "1", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde (Kabu Verdi)", "cv", "238"], ["Caribbean Netherlands", "bq", "599", 1, ["3", "4", "7"]], ["Cayman Islands", "ky", "1", 12, ["345"]], ["Central African Republic (Rpublique centrafricaine)", "cf", "236"], ["Chad (Tchad)", "td", "235"], ["Chile", "cl", "56"], ["China ()", "cn", "86"], ["Christmas Island", "cx", "61", 2, ["89164"]], ["Cocos (Keeling) Islands", "cc", "61", 1, ["89162"]], ["Colombia", "co", "57"], ["Comoros ( )", "km", "269"], ["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243"], ["Congo (Republic) (Congo-Brazzaville)", "cg", "242"], ["Cook Islands", "ck", "682"], ["Costa Rica", "cr", "506"], ["Cte dIvoire", "ci", "225"], ["Croatia (Hrvatska)", "hr", "385"], ["Cuba", "cu", "53"], ["Curaao", "cw", "599", 0], ["Cyprus ()", "cy", "357"], ["Czech Republic (esk republika)", "cz", "420"], ["Denmark (Danmark)", "dk", "45"], ["Djibouti", "dj", "253"], ["Dominica", "dm", "1", 13, ["767"]], ["Dominican Republic (Repblica Dominicana)", "do", "1", 2, ["809", "829", "849"]], ["Ecuador", "ec", "593"], ["Egypt ()", "eg", "20"], ["El Salvador", "sv", "503"], ["Equatorial Guinea (Guinea Ecuatorial)", "gq", "240"], ["Eritrea", "er", "291"], ["Estonia (Eesti)", "ee", "372"], ["Ethiopia", "et", "251"], ["Falkland Islands (Islas Malvinas)", "fk", "500"], ["Faroe Islands (Froyar)", "fo", "298"], ["Fiji", "fj", "679"], ["Finland (Suomi)", "fi", "358", 0], ["France", "fr", "33"], ["French Guiana (Guyane franaise)", "gf", "594"], ["French Polynesia (Polynsie franaise)", "pf", "689"], ["Gabon", "ga", "241"], ["Gambia", "gm", "220"], ["Georgia ()", "ge", "995"], ["Germany (Deutschland)", "de", "49"], ["Ghana (Gaana)", "gh", "233"], ["Gibraltar", "gi", "350"], ["Greece ()", "gr", "30"], ["Greenland (Kalaallit Nunaat)", "gl", "299"], ["Grenada", "gd", "1", 14, ["473"]], ["Guadeloupe", "gp", "590", 0], ["Guam", "gu", "1", 15, ["671"]], ["Guatemala", "gt", "502"], ["Guernsey", "gg", "44", 1, ["1481", "7781", "7839", "7911"]], ["Guinea (Guine)", "gn", "224"], ["Guinea-Bissau (Guin Bissau)", "gw", "245"], ["Guyana", "gy", "592"], ["Haiti", "ht", "509"], ["Honduras", "hn", "504"], ["Hong Kong ()", "hk", "852"], ["Hungary (Magyarorszg)", "hu", "36"], ["Iceland (sland)", "is", "354"], ["India ()", "in", "91"], ["Indonesia", "id", "62"], ["Iran ()", "ir", "98"], ["Iraq ()", "iq", "964"], ["Ireland", "ie", "353"], ["Isle of Man", "im", "44", 2, ["1624", "74576", "7524", "7924", "7624"]], ["Israel ()", "il", "972"], ["Italy (Italia)", "it", "39", 0], ["Jamaica", "jm", "1", 4, ["876", "658"]], ["Japan ()", "jp", "81"], ["Jersey", "je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"]], ["Jordan ()", "jo", "962"], ["Kazakhstan ()", "kz", "7", 1, ["33", "7"]], ["Kenya", "ke", "254"], ["Kiribati", "ki", "686"], ["Kosovo", "xk", "383"], ["Kuwait ()", "kw", "965"], ["Kyrgyzstan ()", "kg", "996"], ["Laos ()", "la", "856"], ["Latvia (Latvija)", "lv", "371"], ["Lebanon ()", "lb", "961"], ["Lesotho", "ls", "266"], ["Liberia", "lr", "231"], ["Libya ()", "ly", "218"], ["Liechtenstein", "li", "423"], ["Lithuania (Lietuva)", "lt", "370"], ["Luxembourg", "lu", "352"], ["Macau ()", "mo", "853"], ["Macedonia (FYROM) ()", "mk", "389"], ["Madagascar (Madagasikara)", "mg", "261"], ["Malawi", "mw", "265"], ["Malaysia", "my", "60"], ["Maldives", "mv", "960"], ["Mali", "ml", "223"], ["Malta", "mt", "356"], ["Marshall Islands", "mh", "692"], ["Martinique", "mq", "596"], ["Mauritania ()", "mr", "222"], ["Mauritius (Moris)", "mu", "230"], ["Mayotte", "yt", "262", 1, ["269", "639"]], ["Mexico (Mxico)", "mx", "52"], ["Micronesia", "fm", "691"], ["Moldova (Republica Moldova)", "md", "373"], ["Monaco", "mc", "377"], ["Mongolia ()", "mn", "976"], ["Montenegro (Crna Gora)", "me", "382"], ["Montserrat", "ms", "1", 16, ["664"]], ["Morocco ()", "ma", "212", 0], ["Mozambique (Moambique)", "mz", "258"], ["Myanmar (Burma) ()", "mm", "95"], ["Namibia (Namibi)", "na", "264"], ["Nauru", "nr", "674"], ["Nepal ()", "np", "977"], ["Netherlands (Nederland)", "nl", "31"], ["New Caledonia (Nouvelle-Caldonie)", "nc", "687"], ["New Zealand", "nz", "64"], ["Nicaragua", "ni", "505"], ["Niger (Nijar)", "ne", "227"], ["Nigeria", "ng", "234"], ["Niue", "nu", "683"], ["Norfolk Island", "nf", "672"], ["North Korea (   )", "kp", "850"], ["Northern Mariana Islands", "mp", "1", 17, ["670"]], ["Norway (Norge)", "no", "47", 0], ["Oman ()", "om", "968"], ["Pakistan ()", "pk", "92"], ["Palau", "pw", "680"], ["Palestine ()", "ps", "970"], ["Panama (Panam)", "pa", "507"], ["Papua New Guinea", "pg", "675"], ["Paraguay", "py", "595"], ["Peru (Per)", "pe", "51"], ["Philippines", "ph", "63"], ["Poland (Polska)", "pl", "48"], ["Portugal", "pt", "351"], ["Puerto Rico", "pr", "1", 3, ["787", "939"]], ["Qatar ()", "qa", "974"], ["Runion (La Runion)", "re", "262", 0], ["Romania (Romnia)", "ro", "40"], ["Russia ()", "ru", "7", 0], ["Rwanda", "rw", "250"], ["Saint Barthlemy", "bl", "590", 1], ["Saint Helena", "sh", "290"], ["Saint Kitts and Nevis", "kn", "1", 18, ["869"]], ["Saint Lucia", "lc", "1", 19, ["758"]], ["Saint Martin (Saint-Martin (partie franaise))", "mf", "590", 2], ["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508"], ["Saint Vincent and the Grenadines", "vc", "1", 20, ["784"]], ["Samoa", "ws", "685"], ["San Marino", "sm", "378"], ["So Tom and Prncipe (So Tom e Prncipe)", "st", "239"], ["Saudi Arabia (  )", "sa", "966"], ["Senegal (Sngal)", "sn", "221"], ["Serbia ()", "rs", "381"], ["Seychelles", "sc", "248"], ["Sierra Leone", "sl", "232"], ["Singapore", "sg", "65"], ["Sint Maarten", "sx", "1", 21, ["721"]], ["Slovakia (Slovensko)", "sk", "421"], ["Slovenia (Slovenija)", "si", "386"], ["Solomon Islands", "sb", "677"], ["Somalia (Soomaaliya)", "so", "252"], ["South Africa", "za", "27"], ["South Korea ()", "kr", "82"], ["South Sudan ( )", "ss", "211"], ["Spain (Espaa)", "es", "34"], ["Sri Lanka ( )", "lk", "94"], ["Sudan ()", "sd", "249"], ["Suriname", "sr", "597"], ["Svalbard and Jan Mayen", "sj", "47", 1, ["79"]], ["Swaziland", "sz", "268"], ["Sweden (Sverige)", "se", "46"], ["Switzerland (Schweiz)", "ch", "41"], ["Syria ()", "sy", "963"], ["Taiwan ()", "tw", "886"], ["Tajikistan", "tj", "992"], ["Tanzania", "tz", "255"], ["Thailand ()", "th", "66"], ["Timor-Leste", "tl", "670"], ["Togo", "tg", "228"], ["Tokelau", "tk", "690"], ["Tonga", "to", "676"], ["Trinidad and Tobago", "tt", "1", 22, ["868"]], ["Tunisia ()", "tn", "216"], ["Turkey (Trkiye)", "tr", "90"], ["Turkmenistan", "tm", "993"], ["Turks and Caicos Islands", "tc", "1", 23, ["649"]], ["Tuvalu", "tv", "688"], ["U.S. Virgin Islands", "vi", "1", 24, ["340"]], ["Uganda", "ug", "256"], ["Ukraine ()", "ua", "380"], ["United Arab Emirates (  )", "ae", "971"], ["United Kingdom", "gb", "44", 0], ["United States", "us", "1", 0], ["Uruguay", "uy", "598"], ["Uzbekistan (Ozbekiston)", "uz", "998"], ["Vanuatu", "vu", "678"], ["Vatican City (Citt del Vaticano)", "va", "39", 1, ["06698"]], ["Venezuela", "ve", "58"], ["Vietnam (Vit Nam)", "vn", "84"], ["Wallis and Futuna (Wallis-et-Futuna)", "wf", "681"], ["Western Sahara ( )", "eh", "212", 1, ["5288", "5289"]], ["Yemen ()", "ye", "967"], ["Zambia", "zm", "260"], ["Zimbabwe", "zw", "263"], ["land Islands", "ax", "358", 1, ["18"]]];
        // loop over all of the countries above, restructuring the data to be objects with named keys
        for (var i = 0; i < allCountries.length; i++) {
            var c = allCountries[i];
            allCountries[i] = {
                name: c[0],
                iso2: c[1],
                dialCode: c[2],
                priority: c[3] || 0,
                areaCodes: c[4] || null
            };
        }
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
        }
        var intlTelInputGlobals = {
            getInstance: function getInstance(input) {
                var id = input.getAttribute("data-intl-tel-input-id");
                return window.intlTelInputGlobals.instances[id];
            },
            instances: {}
        };
        if (typeof window === "object") window.intlTelInputGlobals = intlTelInputGlobals;
        // these vars persist through all instances of the plugin
        var id = 0;
        var defaults = {
            // whether or not to allow the dropdown
            allowDropdown: true,
            // if there is just a dial code in the input: remove it on blur
            autoHideDialCode: true,
            // add a placeholder in the input with an example number for the selected country
            autoPlaceholder: "polite",
            // modify the parentClass
            customContainer: "",
            // modify the auto placeholder
            customPlaceholder: null,
            // append menu to specified element
            dropdownContainer: null,
            // don't display these countries
            excludeCountries: [],
            // format the input value during initialisation and on setNumber
            formatOnDisplay: true,
            // geoIp lookup function
            geoIpLookup: null,
            // inject a hidden input with this name, and on submit, populate it with the result of getNumber
            hiddenInput: "",
            // initial country
            initialCountry: "",
            // localized country names e.g. { 'de': 'Deutschland' }
            localizedCountries: null,
            // don't insert international dial codes
            nationalMode: true,
            // display only these countries
            onlyCountries: [],
            // number type to use for placeholders
            placeholderNumberType: "MOBILE",
            // the countries at the top of the list. defaults to united states and united kingdom
            preferredCountries: ["us", "gb"],
            // display the country dial code next to the selected flag so it's not part of the typed number
            separateDialCode: false,
            //country list dropdown height
            dropdown_maxheight: "100px",
            // specify the path to the libphonenumber script to enable validation/formatting
            utilsScript: ""
        };
        // https://en.wikipedia.org/wiki/List_of_North_American_Numbering_Plan_area_codes#Non-geographic_area_codes
        var regionlessNanpNumbers = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"];
        if (typeof window === "object") {
            // keep track of if the window.load event has fired as impossible to check after the fact
            window.addEventListener("load", function () {
                // UPDATE: use a public static field so we can fudge it in the tests
                window.intlTelInputGlobals.windowLoaded = true;
            });
        }
        // utility function to iterate over an object. can't use Object.entries or native forEach because
        // of IE11
        var forEachProp = function forEachProp(obj, callback) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                callback(keys[i], obj[keys[i]]);
            }
        };
        // run a method on each instance of the plugin
        var forEachInstance = function forEachInstance(method) {
            forEachProp(window.intlTelInputGlobals.instances, function (key) {
                window.intlTelInputGlobals.instances[key][method]();
            });
        };
        // this is our plugin class that we will create an instance of
        // eslint-disable-next-line no-unused-vars
        var Iti = /*#__PURE__*/
            function () {
                function Iti(input, options) {
                    var _this = this;
                    _classCallCheck(this, Iti);
                    this.id = id++;
                    this.telInput = input;
                    this.activeItem = null;
                    this.highlightedItem = null;
                    // process specified options / defaults
                    // alternative to Object.assign, which isn't supported by IE11
                    var customOptions = options || {};
                    this.options = {};
                    forEachProp(defaults, function (key, value) {
                        _this.options[key] = customOptions.hasOwnProperty(key) ? customOptions[key] : value;
                    });
                    this.hadInitialPlaceholder = Boolean(input.getAttribute("placeholder"));
                }
                _createClass(Iti, [{
                    key: "_init",
                    value: function _init() {
                        var _this2 = this;
                        // if in nationalMode, disable options relating to dial codes
                        if (this.options.nationalMode) this.options.autoHideDialCode = false;
                        // if separateDialCode then doesn't make sense to A) insert dial code into input
                        // (autoHideDialCode), and B) display national numbers (because we're displaying the country
                        // dial code next to them)
                        if (this.options.separateDialCode) {
                            this.options.autoHideDialCode = this.options.nationalMode = false;
                        }
                        // we cannot just test screen size as some smartphones/website meta tags will report desktop
                        // resolutions
                        // Note: for some reason jasmine breaks if you put this in the main Plugin function with the
                        // rest of these declarations
                        // Note: to target Android Mobiles (and not Tablets), we must find 'Android' and 'Mobile'
                        this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        if (this.isMobile) {
                            // trigger the mobile dropdown css
                            document.body.classList.add("iti-mobile");
                            // on mobile, we want a full screen dropdown, so we must append it to the body
                            if (!this.options.dropdownContainer) this.options.dropdownContainer = document.body;
                        }
                        // these promises get resolved when their individual requests complete
                        // this way the dev can do something like iti.promise.then(...) to know when all requests are
                        // complete
                        if (typeof Promise !== "undefined") {
                            var autoCountryPromise = new Promise(function (resolve, reject) {
                                _this2.resolveAutoCountryPromise = resolve;
                                _this2.rejectAutoCountryPromise = reject;
                            });
                            var utilsScriptPromise = new Promise(function (resolve, reject) {
                                _this2.resolveUtilsScriptPromise = resolve;
                                _this2.rejectUtilsScriptPromise = reject;
                            });
                            this.promise = Promise.all([autoCountryPromise, utilsScriptPromise]);
                        } else {
                            // prevent errors when Promise doesn't exist
                            this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = function () { };
                            this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = function () { };
                        }
                        // in various situations there could be no country selected initially, but we need to be able
                        // to assume this variable exists
                        this.selectedCountryData = {};
                        // process all the data: onlyCountries, excludeCountries, preferredCountries etc
                        this._processCountryData();
                        // generate the markup
                        this._generateMarkup();
                        // set the initial state of the input value and the selected flag
                        this._setInitialState();
                        // start all of the event listeners: autoHideDialCode, input keydown, selectedFlag click
                        this._initListeners();
                        // utils script, and auto country
                        this._initRequests();
                    }
                }, {
                    key: "_processCountryData",
                    value: function _processCountryData() {
                        // process onlyCountries or excludeCountries array if present
                        this._processAllCountries();
                        // process the countryCodes map
                        this._processCountryCodes();
                        // process the preferredCountries
                        this._processPreferredCountries();
                        // translate countries according to localizedCountries option
                        if (this.options.localizedCountries) this._translateCountriesByLocale();
                        // sort countries by name
                        if (this.options.onlyCountries.length || this.options.localizedCountries) {
                            this.countries.sort(this._countryNameSort);
                        }
                    }
                }, {
                    key: "_addCountryCode",
                    value: function _addCountryCode(iso2, countryCode, priority) {
                        if (countryCode.length > this.countryCodeMaxLen) {
                            this.countryCodeMaxLen = countryCode.length;
                        }
                        if (!this.countryCodes.hasOwnProperty(countryCode)) {
                            this.countryCodes[countryCode] = [];
                        }
                        // bail if we already have this country for this countryCode
                        for (var i = 0; i < this.countryCodes[countryCode].length; i++) {
                            if (this.countryCodes[countryCode][i] === iso2) return;
                        }
                        // check for undefined as 0 is falsy
                        var index = priority !== undefined ? priority : this.countryCodes[countryCode].length;
                        this.countryCodes[countryCode][index] = iso2;
                    }
                }, {
                    key: "_processAllCountries",
                    value: function _processAllCountries() {
                        if (this.options.onlyCountries.length) {
                            var lowerCaseOnlyCountries = this.options.onlyCountries.map(function (country) {
                                return country.toLowerCase();
                            });
                            this.countries = allCountries.filter(function (country) {
                                return lowerCaseOnlyCountries.indexOf(country.iso2) > -1;
                            });
                        } else if (this.options.excludeCountries.length) {
                            var lowerCaseExcludeCountries = this.options.excludeCountries.map(function (country) {
                                return country.toLowerCase();
                            });
                            this.countries = allCountries.filter(function (country) {
                                return lowerCaseExcludeCountries.indexOf(country.iso2) === -1;
                            });
                        } else {
                            this.countries = allCountries;
                        }
                    }
                }, {
                    key: "_translateCountriesByLocale",
                    value: function _translateCountriesByLocale() {
                        for (var i = 0; i < this.countries.length; i++) {
                            var iso = this.countries[i].iso2.toLowerCase();
                            if (this.options.localizedCountries.hasOwnProperty(iso)) {
                                this.countries[i].name = this.options.localizedCountries[iso];
                            }
                        }
                    }
                }, {
                    key: "_countryNameSort",
                    value: function _countryNameSort(a, b) {
                        return a.name.localeCompare(b.name);
                    }
                }, {
                    key: "_processCountryCodes",
                    value: function _processCountryCodes() {
                        this.countryCodeMaxLen = 0;
                        // here we store just dial codes
                        this.dialCodes = {};
                        // here we store "country codes" (both dial codes and their area codes)
                        this.countryCodes = {};
                        // first: add dial codes
                        for (var i = 0; i < this.countries.length; i++) {
                            var c = this.countries[i];
                            if (!this.dialCodes[c.dialCode]) this.dialCodes[c.dialCode] = true;
                            this._addCountryCode(c.iso2, c.dialCode, c.priority);
                        }
                        // next: add area codes
                        // this is a second loop over countries, to make sure we have all of the "root" countries
                        // already in the map, so that we can access them, as each time we add an area code substring
                        // to the map, we also need to include the "root" country's code, as that also matches
                        for (var _i = 0; _i < this.countries.length; _i++) {
                            var _c = this.countries[_i];
                            // area codes
                            if (_c.areaCodes) {
                                var rootCountryCode = this.countryCodes[_c.dialCode][0];
                                // for each area code
                                for (var j = 0; j < _c.areaCodes.length; j++) {
                                    var areaCode = _c.areaCodes[j];
                                    // for each digit in the area code to add all partial matches as well
                                    for (var k = 1; k < areaCode.length; k++) {
                                        var partialDialCode = _c.dialCode + areaCode.substr(0, k);
                                        // start with the root country, as that also matches this dial code
                                        this._addCountryCode(rootCountryCode, partialDialCode);
                                        this._addCountryCode(_c.iso2, partialDialCode);
                                    }
                                    // add the full area code
                                    this._addCountryCode(_c.iso2, _c.dialCode + areaCode);
                                }
                            }
                        }
                    }
                }, {
                    key: "_processPreferredCountries",
                    value: function _processPreferredCountries() {
                        this.preferredCountries = [];
                        for (var i = 0; i < this.options.preferredCountries.length; i++) {
                            var countryCode = this.options.preferredCountries[i].toLowerCase();
                            var countryData = this._getCountryData(countryCode, false, true);
                            if (countryData) this.preferredCountries.push(countryData);
                        }
                    }
                }, {
                    key: "_createEl",
                    value: function _createEl(name, attrs, container) {
                        var el = document.createElement(name);
                        if (attrs) forEachProp(attrs, function (key, value) {
                            return el.setAttribute(key, value);
                        });
                        if (container) container.appendChild(el);
                        return el;
                    }
                }, {
                    key: "_generateMarkup",
                    value: function _generateMarkup() {
                        // if autocomplete does not exist on the element and its form, then
                        // prevent autocomplete as there's no safe, cross-browser event we can react to, so it can
                        // easily put the plugin in an inconsistent state e.g. the wrong flag selected for the
                        // autocompleted number, which on submit could mean wrong number is saved (esp in nationalMode)
                        if (!this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete"))) {
                            this.telInput.setAttribute("autocomplete", "off");
                        }
                        // containers (mostly for positioning)
                        var parentClass = "iti";
                        if (this.options.allowDropdown) parentClass += " iti--allow-dropdown";
                        if (this.options.separateDialCode) parentClass += " iti--separate-dial-code";
                        if (this.options.customContainer) {
                            parentClass += " ";
                            parentClass += this.options.customContainer;
                        }
                        var wrapper = this._createEl("div", {
                            "class": parentClass
                        });
                        this.telInput.parentNode.insertBefore(wrapper, this.telInput);
                        this.flagsContainer = this._createEl("div", {
                            "class": "iti__flag-container"
                        }, wrapper);
                        wrapper.appendChild(this.telInput);
                        // selected flag (displayed to left of input)
                        this.selectedFlag = this._createEl("div", {
                            "class": "iti__selected-flag",
                            role: "combobox",
                            "aria-owns": "iti-".concat(this.id, "__country-listbox"),
                            "aria-expanded": "false"
                        }, this.flagsContainer);
                        this.selectedFlagInner = this._createEl("div", {
                            "class": "iti__flag"
                        }, this.selectedFlag);
                        if (this.options.separateDialCode) {
                            this.selectedDialCode = this._createEl("div", {
                                "class": "iti__selected-dial-code"
                            }, this.selectedFlag);
                        }
                        if (this.options.allowDropdown) {
                            // make element focusable and tab navigable
                            this.selectedFlag.setAttribute("tabindex", "0");
                            this.dropdownArrow = this._createEl("div", {
                                "class": "iti__arrow"
                            }, this.selectedFlag);
                            // country dropdown: preferred countries, then divider, then all countries
                            this.countryList = this._createEl("ul", {
                                "class": "iti__country-list iti__hide",
                                id: "iti-".concat(this.id, "__country-listbox"),
                                role: "listbox",
                                style: `max-height:${this.options.dropdown_maxheight}`
                            });
                            if (this.preferredCountries.length) {
                                this._appendListItems(this.preferredCountries, "iti__preferred", true);
                                this._createEl("li", {
                                    "class": "iti__divider",
                                    role: "separator",
                                    "aria-disabled": "true"
                                }, this.countryList);
                            }
                            this._appendListItems(this.countries, "iti__standard");
                            // create dropdownContainer markup
                            if (this.options.dropdownContainer) {
                                this.dropdown = this._createEl("div", {
                                    "class": "iti iti--container"
                                });
                                this.dropdown.appendChild(this.countryList);
                            } else {
                                this.flagsContainer.appendChild(this.countryList);
                            }
                        }
                        if (this.options.hiddenInput) {
                            var hiddenInputName = this.options.hiddenInput;
                            var name = this.telInput.getAttribute("name");
                            if (name) {
                                var i = name.lastIndexOf("[");
                                // if input name contains square brackets, then give the hidden input the same name,
                                // replacing the contents of the last set of brackets with the given hiddenInput name
                                if (i !== -1) hiddenInputName = "".concat(name.substr(0, i), "[").concat(hiddenInputName, "]");
                            }
                            this.hiddenInput = this._createEl("input", {
                                type: "hidden",
                                name: hiddenInputName
                            });
                            wrapper.appendChild(this.hiddenInput);
                        }
                    }
                }, {
                    key: "_appendListItems",
                    value: function _appendListItems(countries, className, preferred) {
                        // we create so many DOM elements, it is faster to build a temp string
                        // and then add everything to the DOM in one go at the end
                        var tmp = "";
                        // for each country
                        for (var i = 0; i < countries.length; i++) {
                            var c = countries[i];
                            var idSuffix = preferred ? "-preferred" : "";
                            // open the list item
                            tmp += "<li class='iti__country ".concat(className, "' tabIndex='-1' id='iti-").concat(this.id, "__item-").concat(c.iso2).concat(idSuffix, "' role='option' data-dial-code='").concat(c.dialCode, "' data-country-code='").concat(c.iso2, "'>");
                            // add the flag
                            tmp += "<div class='iti__flag-box'><div class='iti__flag iti__".concat(c.iso2, "'></div></div>");
                            // and the country name and dial code
                            tmp += "<span class='iti__country-name'>".concat(c.name, "</span>");
                            tmp += "<span class='iti__dial-code'>+".concat(c.dialCode, "</span>");
                            // close the list item
                            tmp += "</li>";
                        }
                        this.countryList.insertAdjacentHTML("beforeend", tmp);
                    }
                }, {
                    key: "_setInitialState",
                    value: function _setInitialState() {
                        var val = this.telInput.value;
                        var dialCode = this._getDialCode(val);
                        var isRegionlessNanp = this._isRegionlessNanp(val);
                        var _this$options = this.options, initialCountry = _this$options.initialCountry, nationalMode = _this$options.nationalMode, autoHideDialCode = _this$options.autoHideDialCode, separateDialCode = _this$options.separateDialCode;
                        // if we already have a dial code, and it's not a regionlessNanp, we can go ahead and set the
                        // flag, else fall back to the default country
                        if (dialCode && !isRegionlessNanp) {
                            this._updateFlagFromNumber(val);
                        } else if (initialCountry !== "auto") {
                            // see if we should select a flag
                            if (initialCountry) {
                                this._setFlag(initialCountry.toLowerCase());
                            } else {
                                if (dialCode && isRegionlessNanp) {
                                    // has intl dial code, is regionless nanp, and no initialCountry, so default to US
                                    this._setFlag("us");
                                } else {
                                    // no dial code and no initialCountry, so default to first in list
                                    this.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0].iso2 : this.countries[0].iso2;
                                    if (!val) {
                                        this._setFlag(this.defaultCountry);
                                    }
                                }
                            }
                            // if empty and no nationalMode and no autoHideDialCode then insert the default dial code
                            if (!val && !nationalMode && !autoHideDialCode && !separateDialCode) {
                                this.telInput.value = "+".concat(this.selectedCountryData.dialCode);
                            }
                        }
                        // NOTE: if initialCountry is set to auto, that will be handled separately
                        // format - note this wont be run after _updateDialCode as that's only called if no val
                        if (val) this._updateValFromNumber(val);
                    }
                }, {
                    key: "_initListeners",
                    value: function _initListeners() {
                        this._initKeyListeners();
                        if (this.options.autoHideDialCode) this._initBlurListeners();
                        if (this.options.allowDropdown) this._initDropdownListeners();
                        if (this.hiddenInput) this._initHiddenInputListener();
                    }
                }, {
                    key: "_initHiddenInputListener",
                    value: function _initHiddenInputListener() {
                        var _this3 = this;
                        this._handleHiddenInputSubmit = function () {
                            _this3.hiddenInput.value = _this3.getNumber();
                        };
                        if (this.telInput.form) this.telInput.form.addEventListener("submit", this._handleHiddenInputSubmit);
                    }
                }, {
                    key: "_getClosestLabel",
                    value: function _getClosestLabel() {
                        var el = this.telInput;
                        while (el && el.tagName !== "LABEL") {
                            el = el.parentNode;
                        }
                        return el;
                    }
                }, {
                    key: "_initDropdownListeners",
                    value: function _initDropdownListeners() {
                        var _this4 = this;
                        // hack for input nested inside label (which is valid markup): clicking the selected-flag to
                        // open the dropdown would then automatically trigger a 2nd click on the input which would
                        // close it again
                        this._handleLabelClick = function (e) {
                            // if the dropdown is closed, then focus the input, else ignore the click
                            if (_this4.countryList.classList.contains("iti__hide")) _this4.telInput.focus(); else e.preventDefault();
                        };
                        var label = this._getClosestLabel();
                        if (label) label.addEventListener("click", this._handleLabelClick);
                        // toggle country dropdown on click
                        this._handleClickSelectedFlag = function () {
                            // only intercept this event if we're opening the dropdown
                            // else let it bubble up to the top ("click-off-to-close" listener)
                            // we cannot just stopPropagation as it may be needed to close another instance
                            if (_this4.countryList.classList.contains("iti__hide") && !_this4.telInput.disabled && !_this4.telInput.readOnly) {
                                _this4._showDropdown();
                            }
                        };
                        this.selectedFlag.addEventListener("click", this._handleClickSelectedFlag);
                        // open dropdown list if currently focused
                        this._handleFlagsContainerKeydown = function (e) {
                            var isDropdownHidden = _this4.countryList.classList.contains("iti__hide");
                            if (isDropdownHidden && ["ArrowUp", "Up", "ArrowDown", "Down", " ", "Enter"].indexOf(e.key) !== -1) {
                                // prevent form from being submitted if "ENTER" was pressed
                                e.preventDefault();
                                // prevent event from being handled again by document
                                e.stopPropagation();
                                _this4._showDropdown();
                            }
                            // allow navigation from dropdown to input on TAB
                            if (e.key === "Tab") _this4._closeDropdown();
                        };
                        this.flagsContainer.addEventListener("keydown", this._handleFlagsContainerKeydown);
                    }
                }, {
                    key: "_initRequests",
                    value: function _initRequests() {
                        var _this5 = this;
                        // if the user has specified the path to the utils script, fetch it on window.load, else resolve
                        if (this.options.utilsScript && !window.intlTelInputUtils) {
                            // if the plugin is being initialised after the window.load event has already been fired
                            if (window.intlTelInputGlobals.windowLoaded) {
                                window.intlTelInputGlobals.loadUtils(this.options.utilsScript);
                            } else {
                                // wait until the load event so we don't block any other requests e.g. the flags image
                                window.addEventListener("load", function () {
                                    window.intlTelInputGlobals.loadUtils(_this5.options.utilsScript);
                                });
                            }
                        } else this.resolveUtilsScriptPromise();
                        if (this.options.initialCountry === "auto") this._loadAutoCountry(); else this.resolveAutoCountryPromise();
                    }
                }, {
                    key: "_loadAutoCountry",
                    value: function _loadAutoCountry() {
                        // 3 options:
                        // 1) already loaded (we're done)
                        // 2) not already started loading (start)
                        // 3) already started loading (do nothing - just wait for loading callback to fire)
                        if (window.intlTelInputGlobals.autoCountry) {
                            this.handleAutoCountry();
                        } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {
                            // don't do this twice!
                            window.intlTelInputGlobals.startedLoadingAutoCountry = true;
                            if (typeof this.options.geoIpLookup === "function") {
                                this.options.geoIpLookup(function (countryCode) {
                                    window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();
                                    // tell all instances the auto country is ready
                                    // TODO: this should just be the current instances
                                    // UPDATE: use setTimeout in case their geoIpLookup function calls this callback straight
                                    // away (e.g. if they have already done the geo ip lookup somewhere else). Using
                                    // setTimeout means that the current thread of execution will finish before executing
                                    // this, which allows the plugin to finish initialising.
                                    setTimeout(function () {
                                        return forEachInstance("handleAutoCountry");
                                    });
                                }, function () {
                                    return forEachInstance("rejectAutoCountryPromise");
                                });
                            }
                        }
                    }
                }, {
                    key: "_initKeyListeners",
                    value: function _initKeyListeners() {
                        var _this6 = this;
                        // update flag on keyup
                        this._handleKeyupEvent = function () {
                            if (_this6._updateFlagFromNumber(_this6.telInput.value)) {
                                _this6._triggerCountryChange();
                            }
                        };
                        this.telInput.addEventListener("keyup", this._handleKeyupEvent);
                        // update flag on cut/paste events (now supported in all major browsers)
                        this._handleClipboardEvent = function () {
                            // hack because "paste" event is fired before input is updated
                            setTimeout(_this6._handleKeyupEvent);
                        };
                        this.telInput.addEventListener("cut", this._handleClipboardEvent);
                        this.telInput.addEventListener("paste", this._handleClipboardEvent);
                    }
                }, {
                    key: "_cap",
                    value: function _cap(number) {
                        var max = this.telInput.getAttribute("maxlength");
                        return max && number.length > max ? number.substr(0, max) : number;
                    }
                }, {
                    key: "_initBlurListeners",
                    value: function _initBlurListeners() {
                        var _this7 = this;
                        // on blur or form submit: if just a dial code then remove it
                        this._handleSubmitOrBlurEvent = function () {
                            _this7._removeEmptyDialCode();
                        };
                        if (this.telInput.form) this.telInput.form.addEventListener("submit", this._handleSubmitOrBlurEvent);
                        this.telInput.addEventListener("blur", this._handleSubmitOrBlurEvent);
                    }
                }, {
                    key: "_removeEmptyDialCode",
                    value: function _removeEmptyDialCode() {
                        if (this.telInput.value.charAt(0) === "+") {
                            var numeric = this._getNumeric(this.telInput.value);
                            // if just a plus, or if just a dial code
                            if (!numeric || this.selectedCountryData.dialCode === numeric) {
                                this.telInput.value = "";
                            }
                        }
                    }
                }, {
                    key: "_getNumeric",
                    value: function _getNumeric(s) {
                        return s.replace(/\D/g, "");
                    }
                }, {
                    key: "_trigger",
                    value: function _trigger(name) {
                        // have to use old school document.createEvent as IE11 doesn't support `new Event()` syntax
                        var e = document.createEvent("Event");
                        e.initEvent(name, true, true);
                        // can bubble, and is cancellable
                        this.telInput.dispatchEvent(e);
                    }
                }, {
                    key: "_showDropdown",
                    value: function _showDropdown() {
                        this.countryList.classList.remove("iti__hide");
                        this.selectedFlag.setAttribute("aria-expanded", "true");
                        this._setDropdownPosition();
                        // update highlighting and scroll to active list item
                        if (this.activeItem) {
                            this._highlightListItem(this.activeItem, false);
                            this._scrollTo(this.activeItem, true);
                        }
                        // bind all the dropdown-related listeners: mouseover, click, click-off, keydown
                        this._bindDropdownListeners();
                        // update the arrow
                        this.dropdownArrow.classList.add("iti__arrow--up");
                        this._trigger("open:countrydropdown");
                    }
                }, {
                    key: "_toggleClass",
                    value: function _toggleClass(el, className, shouldHaveClass) {
                        if (shouldHaveClass && !el.classList.contains(className)) el.classList.add(className); else if (!shouldHaveClass && el.classList.contains(className)) el.classList.remove(className);
                    }
                }, {
                    key: "_setDropdownPosition",
                    value: function _setDropdownPosition() {
                        var _this8 = this;
                        if (this.options.dropdownContainer) {
                            this.options.dropdownContainer.appendChild(this.dropdown);
                        }
                        if (!this.isMobile) {
                            var pos = this.telInput.getBoundingClientRect();
                            // windowTop from https://stackoverflow.com/a/14384091/217866
                            var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                            var inputTop = pos.top + windowTop;
                            var dropdownHeight = this.countryList.offsetHeight;
                            // dropdownFitsBelow = (dropdownBottom < windowBottom)
                            var dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;
                            var dropdownFitsAbove = inputTop - dropdownHeight > windowTop;
                            // by default, the dropdown will be below the input. If we want to position it above the
                            // input, we add the dropup class.
                            this._toggleClass(this.countryList, "iti__country-list--dropup", !dropdownFitsBelow && dropdownFitsAbove);
                            // if dropdownContainer is enabled, calculate postion
                            if (this.options.dropdownContainer) {
                                // by default the dropdown will be directly over the input because it's not in the flow.
                                // If we want to position it below, we need to add some extra top value.
                                var extraTop = !dropdownFitsBelow && dropdownFitsAbove ? 0 : this.telInput.offsetHeight;
                                // calculate placement
                                this.dropdown.style.top = "".concat(inputTop + extraTop, "px");
                                this.dropdown.style.left = "".concat(pos.left + document.body.scrollLeft, "px");
                                // close menu on window scroll
                                this._handleWindowScroll = function () {
                                    return _this8._closeDropdown();
                                };
                                window.addEventListener("scroll", this._handleWindowScroll);
                            }
                        }
                    }
                }, {
                    key: "_getClosestListItem",
                    value: function _getClosestListItem(target) {
                        var el = target;
                        while (el && el !== this.countryList && !el.classList.contains("iti__country")) {
                            el = el.parentNode;
                        }
                        // if we reached the countryList element, then return null
                        return el === this.countryList ? null : el;
                    }
                }, {
                    key: "_bindDropdownListeners",
                    value: function _bindDropdownListeners() {
                        var _this9 = this;
                        // when mouse over a list item, just highlight that one
                        // we add the class "highlight", so if they hit "enter" we know which one to select
                        this._handleMouseoverCountryList = function (e) {
                            // handle event delegation, as we're listening for this event on the countryList
                            var listItem = _this9._getClosestListItem(e.target);
                            if (listItem) _this9._highlightListItem(listItem, false);
                        };
                        this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList);
                        // listen for country selection
                        this._handleClickCountryList = function (e) {
                            var listItem = _this9._getClosestListItem(e.target);
                            if (listItem) _this9._selectListItem(listItem);
                        };
                        this.countryList.addEventListener("click", this._handleClickCountryList);
                        // click off to close
                        // (except when this initial opening click is bubbling up)
                        // we cannot just stopPropagation as it may be needed to close another instance
                        var isOpening = true;
                        this._handleClickOffToClose = function () {
                            if (!isOpening) _this9._closeDropdown();
                            isOpening = false;
                        };
                        document.documentElement.addEventListener("click", this._handleClickOffToClose);
                        // listen for up/down scrolling, enter to select, or letters to jump to country name.
                        // use keydown as keypress doesn't fire for non-char keys and we want to catch if they
                        // just hit down and hold it to scroll down (no keyup event).
                        // listen on the document because that's where key events are triggered if no input has focus
                        var query = "";
                        var queryTimer = null;
                        this._handleKeydownOnDropdown = function (e) {
                            // prevent down key from scrolling the whole page,
                            // and enter key from submitting a form etc
                            e.preventDefault();
                            // up and down to navigate
                            if (e.key === "ArrowUp" || e.key === "Up" || e.key === "ArrowDown" || e.key === "Down") _this9._handleUpDownKey(e.key); else if (e.key === "Enter") _this9._handleEnterKey(); else if (e.key === "Escape") _this9._closeDropdown(); else if (/^[a-zA-Z--- ]$/.test(e.key)) {
                                // jump to countries that start with the query string
                                if (queryTimer) clearTimeout(queryTimer);
                                query += e.key.toLowerCase();
                                _this9._searchForCountry(query);
                                // if the timer hits 1 second, reset the query
                                queryTimer = setTimeout(function () {
                                    query = "";
                                }, 1e3);
                            }
                        };
                        document.addEventListener("keydown", this._handleKeydownOnDropdown);
                    }
                }, {
                    key: "_handleUpDownKey",
                    value: function _handleUpDownKey(key) {
                        var next = key === "ArrowUp" || key === "Up" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;
                        if (next) {
                            // skip the divider
                            if (next.classList.contains("iti__divider")) {
                                next = key === "ArrowUp" || key === "Up" ? next.previousElementSibling : next.nextElementSibling;
                            }
                            this._highlightListItem(next, true);
                        }
                    }
                }, {
                    key: "_handleEnterKey",
                    value: function _handleEnterKey() {
                        if (this.highlightedItem) this._selectListItem(this.highlightedItem);
                    }
                }, {
                    key: "_searchForCountry",
                    value: function _searchForCountry(query) {
                        for (var i = 0; i < this.countries.length; i++) {
                            if (this._startsWith(this.countries[i].name, query)) {
                                var listItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(this.countries[i].iso2));
                                // update highlighting and scroll
                                this._highlightListItem(listItem, false);
                                this._scrollTo(listItem, true);
                                break;
                            }
                        }
                    }
                }, {
                    key: "_startsWith",
                    value: function _startsWith(a, b) {
                        return a.substr(0, b.length).toLowerCase() === b;
                    }
                }, {
                    key: "_updateValFromNumber",
                    value: function _updateValFromNumber(originalNumber) {
                        var number = originalNumber;
                        if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {
                            var useNational = !this.options.separateDialCode && (this.options.nationalMode || number.charAt(0) !== "+");
                            var _intlTelInputUtils$nu = intlTelInputUtils.numberFormat, NATIONAL = _intlTelInputUtils$nu.NATIONAL, INTERNATIONAL = _intlTelInputUtils$nu.INTERNATIONAL;
                            var format = useNational ? NATIONAL : INTERNATIONAL;
                            number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format);
                        }
                        number = this._beforeSetNumber(number);
                        let numChanged = false;
                        if (this.telInput.value !== number)
                            numChanged = true;
                        this.telInput.value = number;
                        return numChanged;
                    }
                }, {
                    key: "_updateFlagFromNumber",
                    value: function _updateFlagFromNumber(originalNumber) {
                        // if we're in nationalMode and we already have US/Canada selected, make sure the number starts
                        // with a +1 so _getDialCode will be able to extract the area code
                        // update: if we dont yet have selectedCountryData, but we're here (trying to update the flag
                        // from the number), that means we're initialising the plugin with a number that already has a
                        // dial code, so fine to ignore this bit
                        var number = originalNumber;
                        var selectedDialCode = this.selectedCountryData.dialCode;
                        var isNanp = selectedDialCode === "1";
                        if (number && this.options.nationalMode && isNanp && number.charAt(0) !== "+") {
                            if (number.charAt(0) !== "1") number = "1".concat(number);
                            number = "+".concat(number);
                        }
                        // update flag if user types area code for another country
                        if (this.options.separateDialCode && selectedDialCode && number.charAt(0) !== "+") {
                            number = "+".concat(selectedDialCode).concat(number);
                        }
                        // try and extract valid dial code from input
                        var dialCode = this._getDialCode(number, true);
                        var numeric = this._getNumeric(number);
                        var countryCode = null;
                        if (dialCode) {
                            var countryCodes = this.countryCodes[this._getNumeric(dialCode)];
                            // check if the right country is already selected. this should be false if the number is
                            // longer than the matched dial code because in this case we need to make sure that if
                            // there are multiple country matches, that the first one is selected (note: we could
                            // just check that here, but it requires the same loop that we already have later)
                            var alreadySelected = countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;
                            var isRegionlessNanpNumber = selectedDialCode === "1" && this._isRegionlessNanp(numeric);
                            // only update the flag if:
                            // A) NOT (we currently have a NANP flag selected, and the number is a regionlessNanp)
                            // AND
                            // B) the right country is not already selected
                            if (!isRegionlessNanpNumber && !alreadySelected) {
                                // if using onlyCountries option, countryCodes[0] may be empty, so we must find the first
                                // non-empty index
                                for (var j = 0; j < countryCodes.length; j++) {
                                    if (countryCodes[j]) {
                                        countryCode = countryCodes[j];
                                        break;
                                    }
                                }
                            }
                        } else if (number.charAt(0) === "+" && numeric.length) {
                            // invalid dial code, so empty
                            // Note: use getNumeric here because the number has not been formatted yet, so could contain
                            // bad chars
                            countryCode = "";
                        } else if (!number || number === "+") {
                            // empty, or just a plus, so default
                            countryCode = this.defaultCountry;
                        }
                        if (countryCode !== null) {
                            return this._setFlag(countryCode);
                        }
                        return false;
                    }
                }, {
                    key: "_isRegionlessNanp",
                    value: function _isRegionlessNanp(number) {
                        var numeric = this._getNumeric(number);
                        if (numeric.charAt(0) === "1") {
                            var areaCode = numeric.substr(1, 3);
                            return regionlessNanpNumbers.indexOf(areaCode) !== -1;
                        }
                        return false;
                    }
                }, {
                    key: "_highlightListItem",
                    value: function _highlightListItem(listItem, shouldFocus) {
                        var prevItem = this.highlightedItem;
                        if (prevItem) prevItem.classList.remove("iti__highlight");
                        this.highlightedItem = listItem;
                        this.highlightedItem.classList.add("iti__highlight");
                        if (shouldFocus) this.highlightedItem.focus();
                    }
                }, {
                    key: "_getCountryData",
                    value: function _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {
                        var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;
                        for (var i = 0; i < countryList.length; i++) {
                            if (countryList[i].iso2 === countryCode) {
                                return countryList[i];
                            }
                        }
                        if (allowFail) {
                            return null;
                        }
                        throw new Error("No country data for '".concat(countryCode, "'"));
                    }
                }, {
                    key: "_setFlag",
                    value: function _setFlag(countryCode) {
                        var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
                        // do this first as it will throw an error and stop if countryCode is invalid
                        this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};
                        // update the defaultCountry - we only need the iso2 from now on, so just store that
                        if (this.selectedCountryData.iso2) {
                            this.defaultCountry = this.selectedCountryData.iso2;
                        }
                        this.selectedFlagInner.setAttribute("class", "iti__flag iti__".concat(countryCode));
                        // update the selected country's title attribute
                        var title = countryCode ? "".concat(this.selectedCountryData.name, ": +").concat(this.selectedCountryData.dialCode) : "Unknown";
                        this.selectedFlag.setAttribute("title", title);
                        if (this.options.separateDialCode) {
                            var dialCode = this.selectedCountryData.dialCode ? "+".concat(this.selectedCountryData.dialCode) : "";
                            this.selectedDialCode.innerHTML = dialCode;
                            // offsetWidth is zero if input is in a hidden container during initialisation
                            var selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();
                            // add 6px of padding after the grey selected-dial-code box, as this is what we use in the css
                            this.telInput.style.paddingLeft = "".concat(selectedFlagWidth + 6, "px");
                        }
                        // and the input's placeholder
                        this._updatePlaceholder();
                        // update the active list item
                        if (this.options.allowDropdown) {
                            var prevItem = this.activeItem;
                            if (prevItem) {
                                prevItem.classList.remove("iti__active");
                                prevItem.setAttribute("aria-selected", "false");
                            }
                            if (countryCode) {
                                // check if there is a preferred item first, else fall back to standard
                                var nextItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode, "-preferred")) || this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode));
                                nextItem.setAttribute("aria-selected", "true");
                                nextItem.classList.add("iti__active");
                                this.activeItem = nextItem;
                                this.selectedFlag.setAttribute("aria-activedescendant", nextItem.getAttribute("id"));
                            }
                        }
                        // return if the flag has changed or not
                        return prevCountry.iso2 !== countryCode;
                    }
                }, {
                    key: "_getHiddenSelectedFlagWidth",
                    value: function _getHiddenSelectedFlagWidth() {
                        // to get the right styling to apply, all we need is a shallow clone of the container,
                        // and then to inject a deep clone of the selectedFlag element
                        var containerClone = this.telInput.parentNode.cloneNode();
                        containerClone.style.visibility = "hidden";
                        document.body.appendChild(containerClone);
                        var flagsContainerClone = this.flagsContainer.cloneNode();
                        containerClone.appendChild(flagsContainerClone);
                        var selectedFlagClone = this.selectedFlag.cloneNode(true);
                        flagsContainerClone.appendChild(selectedFlagClone);
                        var width = selectedFlagClone.offsetWidth;
                        containerClone.parentNode.removeChild(containerClone);
                        return width;
                    }
                }, {
                    key: "_updatePlaceholder",
                    value: function _updatePlaceholder() {
                        var shouldSetPlaceholder = this.options.autoPlaceholder === "aggressive" || !this.hadInitialPlaceholder && this.options.autoPlaceholder === "polite";
                        if (window.intlTelInputUtils && shouldSetPlaceholder) {
                            var numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];
                            var placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, numberType) : "";
                            placeholder = this._beforeSetNumber(placeholder);
                            if (typeof this.options.customPlaceholder === "function") {
                                placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData);
                            }
                            this.telInput.setAttribute("placeholder", placeholder);
                        }
                    }
                }, {
                    key: "_selectListItem",
                    value: function _selectListItem(listItem) {
                        // update selected flag and active list item
                        var flagChanged = this._setFlag(listItem.getAttribute("data-country-code"));
                        this._closeDropdown();
                        this._updateDialCode(listItem.getAttribute("data-dial-code"), true);
                        // focus the input
                        this.telInput.focus();
                        // put cursor at end - this fix is required for FF and IE11 (with nationalMode=false i.e. auto
                        // inserting dial code), who try to put the cursor at the beginning the first time
                        var len = this.telInput.value.length;
                        this.telInput.setSelectionRange(len, len);
                        if (flagChanged) {
                            this._triggerCountryChange();
                        }
                    }
                }, {
                    key: "_closeDropdown",
                    value: function _closeDropdown() {
                        this.countryList.classList.add("iti__hide");
                        this.selectedFlag.setAttribute("aria-expanded", "false");
                        // update the arrow
                        this.dropdownArrow.classList.remove("iti__arrow--up");
                        // unbind key events
                        document.removeEventListener("keydown", this._handleKeydownOnDropdown);
                        document.documentElement.removeEventListener("click", this._handleClickOffToClose);
                        this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList);
                        this.countryList.removeEventListener("click", this._handleClickCountryList);
                        // remove menu from container
                        if (this.options.dropdownContainer) {
                            if (!this.isMobile) window.removeEventListener("scroll", this._handleWindowScroll);
                            if (this.dropdown.parentNode) this.dropdown.parentNode.removeChild(this.dropdown);
                        }
                        this._trigger("close:countrydropdown");
                    }
                }, {
                    key: "_scrollTo",
                    value: function _scrollTo(element, middle) {
                        var container = this.countryList;
                        // windowTop from https://stackoverflow.com/a/14384091/217866
                        var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                        var containerHeight = container.offsetHeight;
                        var containerTop = container.getBoundingClientRect().top + windowTop;
                        var containerBottom = containerTop + containerHeight;
                        var elementHeight = element.offsetHeight;
                        var elementTop = element.getBoundingClientRect().top + windowTop;
                        var elementBottom = elementTop + elementHeight;
                        var newScrollTop = elementTop - containerTop + container.scrollTop;
                        var middleOffset = containerHeight / 2 - elementHeight / 2;
                        if (elementTop < containerTop) {
                            // scroll up
                            if (middle) newScrollTop -= middleOffset;
                            container.scrollTop = newScrollTop;
                        } else if (elementBottom > containerBottom) {
                            // scroll down
                            if (middle) newScrollTop += middleOffset;
                            var heightDifference = containerHeight - elementHeight;
                            container.scrollTop = newScrollTop - heightDifference;
                        }
                    }
                }, {
                    key: "_updateDialCode",
                    value: function _updateDialCode(newDialCodeBare, hasSelectedListItem) {
                        var inputVal = this.telInput.value;
                        // save having to pass this every time
                        var newDialCode = "+".concat(newDialCodeBare);
                        var newNumber;
                        if (inputVal.charAt(0) === "+") {
                            // there's a plus so we're dealing with a replacement (doesn't matter if nationalMode or not)
                            var prevDialCode = this._getDialCode(inputVal);
                            if (prevDialCode) {
                                // current number contains a valid dial code, so replace it
                                newNumber = inputVal.replace(prevDialCode, newDialCode);
                            } else {
                                // current number contains an invalid dial code, so ditch it
                                // (no way to determine where the invalid dial code ends and the rest of the number begins)
                                newNumber = newDialCode;
                            }
                        } else if (this.options.nationalMode || this.options.separateDialCode) {
                            // don't do anything
                            return;
                        } else {
                            // nationalMode is disabled
                            if (inputVal) {
                                // there is an existing value with no dial code: prefix the new dial code
                                newNumber = newDialCode + inputVal;
                            } else if (hasSelectedListItem || !this.options.autoHideDialCode) {
                                // no existing value and either they've just selected a list item, or autoHideDialCode is
                                // disabled: insert new dial code
                                newNumber = newDialCode;
                            } else {
                                return;
                            }
                        }
                        this.telInput.value = newNumber;
                    }
                }, {
                    key: "_getDialCode",
                    value: function _getDialCode(number, includeAreaCode) {
                        var dialCode = "";
                        // only interested in international numbers (starting with a plus)
                        if (number.charAt(0) === "+") {
                            var numericChars = "";
                            // iterate over chars
                            for (var i = 0; i < number.length; i++) {
                                var c = number.charAt(i);
                                // if char is number (https://stackoverflow.com/a/8935649/217866)
                                if (!isNaN(parseInt(c, 10))) {
                                    numericChars += c;
                                    // if current numericChars make a valid dial code
                                    if (includeAreaCode) {
                                        if (this.countryCodes[numericChars]) {
                                            // store the actual raw string (useful for matching later)
                                            dialCode = number.substr(0, i + 1);
                                        }
                                    } else {
                                        if (this.dialCodes[numericChars]) {
                                            dialCode = number.substr(0, i + 1);
                                            // if we're just looking for a dial code, we can break as soon as we find one
                                            break;
                                        }
                                    }
                                    // stop searching as soon as we can - in this case when we hit max len
                                    if (numericChars.length === this.countryCodeMaxLen) {
                                        break;
                                    }
                                }
                            }
                        }
                        return dialCode;
                    }
                }, {
                    key: "_getFullNumber",
                    value: function _getFullNumber() {
                        var val = this.telInput.value.trim();
                        var dialCode = this.selectedCountryData.dialCode;
                        var prefix;
                        var numericVal = this._getNumeric(val);
                        if (this.options.separateDialCode && val.charAt(0) !== "+" && dialCode && numericVal) {
                            // when using separateDialCode, it is visible so is effectively part of the typed number
                            prefix = "+".concat(dialCode);
                        } else {
                            prefix = "";
                        }
                        return prefix + val;
                    }
                }, {
                    key: "_beforeSetNumber",
                    value: function _beforeSetNumber(originalNumber) {
                        var number = originalNumber;
                        if (this.options.separateDialCode) {
                            var dialCode = this._getDialCode(number);
                            // if there is a valid dial code
                            if (dialCode) {
                                // in case _getDialCode returned an area code as well
                                dialCode = "+".concat(this.selectedCountryData.dialCode);
                                // a lot of numbers will have a space separating the dial code and the main number, and
                                // some NANP numbers will have a hyphen e.g. +1 684-733-1234 - in both cases we want to get
                                // rid of it
                                // NOTE: don't just trim all non-numerics as may want to preserve an open parenthesis etc
                                var start = number[dialCode.length] === " " || number[dialCode.length] === "-" ? dialCode.length + 1 : dialCode.length;
                                number = number.substr(start);
                            }
                        }
                        return this._cap(number);
                    }
                }, {
                    key: "_triggerCountryChange",
                    value: function _triggerCountryChange() {
                        this._trigger("countrychange");
                    }
                }, {
                    key: "handleAutoCountry",
                    value: function handleAutoCountry() {
                        if (this.options.initialCountry === "auto") {
                            // we must set this even if there is an initial val in the input: in case the initial val is
                            // invalid and they delete it - they should see their auto country
                            this.defaultCountry = window.intlTelInputGlobals.autoCountry;
                            // if there's no initial value in the input, then update the flag
                            if (!this.telInput.value) {
                                this.setCountry(this.defaultCountry);
                            }
                            this.resolveAutoCountryPromise();
                        }
                    }
                }, {
                    key: "handleUtils",
                    value: function handleUtils() {
                        // if the request was successful
                        if (window.intlTelInputUtils) {
                            // if there's an initial value in the input, then format it
                            if (this.telInput.value) {
                                this._updateValFromNumber(this.telInput.value);
                            }
                            this._updatePlaceholder();
                        }
                        this.resolveUtilsScriptPromise();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var form = this.telInput.form;
                        if (this.options.allowDropdown) {
                            // make sure the dropdown is closed (and unbind listeners)
                            this._closeDropdown();
                            this.selectedFlag.removeEventListener("click", this._handleClickSelectedFlag);
                            this.flagsContainer.removeEventListener("keydown", this._handleFlagsContainerKeydown);
                            // label click hack
                            var label = this._getClosestLabel();
                            if (label) label.removeEventListener("click", this._handleLabelClick);
                        }
                        // unbind hiddenInput listeners
                        if (this.hiddenInput && form) form.removeEventListener("submit", this._handleHiddenInputSubmit);
                        // unbind autoHideDialCode listeners
                        if (this.options.autoHideDialCode) {
                            if (form) form.removeEventListener("submit", this._handleSubmitOrBlurEvent);
                            this.telInput.removeEventListener("blur", this._handleSubmitOrBlurEvent);
                        }
                        // unbind key events, and cut/paste events
                        this.telInput.removeEventListener("keyup", this._handleKeyupEvent);
                        this.telInput.removeEventListener("cut", this._handleClipboardEvent);
                        this.telInput.removeEventListener("paste", this._handleClipboardEvent);
                        // remove attribute of id instance: data-intl-tel-input-id
                        this.telInput.removeAttribute("data-intl-tel-input-id");
                        // remove markup (but leave the original input)
                        var wrapper = this.telInput.parentNode;
                        wrapper.parentNode.insertBefore(this.telInput, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                        delete window.intlTelInputGlobals.instances[this.id];
                    }
                }, {
                    key: "getExtension",
                    value: function getExtension() {
                        if (window.intlTelInputUtils) {
                            return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);
                        }
                        return "";
                    }
                }, {
                    key: "getNumber",
                    value: function getNumber(format) {
                        if (window.intlTelInputUtils) {
                            var iso2 = this.selectedCountryData.iso2;
                            return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format);
                        }
                        return "";
                    }
                }, {
                    key: "getNumberType",
                    value: function getNumberType() {
                        if (window.intlTelInputUtils) {
                            return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);
                        }
                        return -99;
                    }
                }, {
                    key: "getSelectedCountryData",
                    value: function getSelectedCountryData() {
                        return this.selectedCountryData;
                    }
                }, {
                    key: "getValidationError",
                    value: function getValidationError() {
                        if (window.intlTelInputUtils) {
                            var iso2 = this.selectedCountryData.iso2;
                            return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);
                        }
                        return -99;
                    }
                }, {
                    key: "isValidNumber",
                    value: function isValidNumber() {
                        var val = this._getFullNumber().trim();
                        var countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
                        return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;
                    }
                }, {
                    key: "setCountry",
                    value: function setCountry(originalCountryCode) {
                        var countryCode = originalCountryCode.toLowerCase();
                        // check if already selected
                        if (!this.selectedFlagInner.classList.contains("iti__".concat(countryCode))) {
                            this._setFlag(countryCode);
                            this._updateDialCode(this.selectedCountryData.dialCode, false);
                            this._triggerCountryChange();
                        }
                    }
                }, {
                    key: "setNumber",
                    value: function setNumber(number) {
                        // we must update the flag first, which updates this.selectedCountryData, which is used for
                        // formatting the number before displaying it
                        var flagChanged = this._updateFlagFromNumber(number);
                        var numChanged = this._updateValFromNumber(number);
                        if (flagChanged) {
                            this._triggerCountryChange();
                        }
                        else if (numChanged) {
                            $(this.telInput).trigger('change');
                        }
                    }
                }, {
                    key: "setPlaceholderNumberType",
                    value: function setPlaceholderNumberType(type) {
                        this.options.placeholderNumberType = type;
                        this._updatePlaceholder();
                    }
                }]);
                return Iti;
            }();
        /********************
 *  STATIC METHODS
 ********************/
        // get the country data object
        intlTelInputGlobals.getCountryData = function () {
            return allCountries;
        };
        // inject a <script> element to load utils.js
        var injectScript = function injectScript(path, handleSuccess, handleFailure) {
            // inject a new script element into the page
            var script = document.createElement("script");
            script.onload = function () {
                forEachInstance("handleUtils");
                if (handleSuccess) handleSuccess();
            };
            script.onerror = function () {
                forEachInstance("rejectUtilsScriptPromise");
                if (handleFailure) handleFailure();
            };
            script.className = "iti-load-utils";
            script.async = true;
            script.src = path;
            document.body.appendChild(script);
        };
        // load the utils script
        intlTelInputGlobals.loadUtils = function (path) {
            // 2 options:
            // 1) not already started loading (start)
            // 2) already started loading (do nothing - just wait for the onload callback to fire, which will
            // trigger handleUtils on all instances, invoking their resolveUtilsScriptPromise functions)
            if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {
                // only do this once
                window.intlTelInputGlobals.startedLoadingUtilsScript = true;
                // if we have promises, then return a promise
                if (typeof Promise !== "undefined") {
                    return new Promise(function (resolve, reject) {
                        return injectScript(path, resolve, reject);
                    });
                }
                injectScript(path);
            }
            return null;
        };
        // default options
        intlTelInputGlobals.defaults = defaults;
        // version
        intlTelInputGlobals.version = "17.0.3";
        // convenience wrapper
        return function (input, options) {
            var iti = new Iti(input, options);
            iti._init();
            input.setAttribute("data-intl-tel-input-id", iti.id);
            window.intlTelInputGlobals.instances[iti.id] = iti;
            return iti;
        };
    }();
});